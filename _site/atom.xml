<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>박영기 BLOG</title>
 <link href="http://ygpark.github.com/atom.xml" rel="self"/>
 <link href="http://ygpark.github.com"/>
 <updated>2012-08-29T18:28:16+09:00</updated>
 <id>http://ygpark.github.com</id>
 <author>
   <name>Young-Gi Park</name>
   <email>ghostyak@gmail.com</email>
 </author>

 
 <entry>
   <title>Pro Git - 2. Git의 기초</title>
   <link href="http://ygpark.github.com/Pro Git/2012/08/29/pro-git-2-git-basics"/>
   <updated>2012-08-29T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Pro Git/2012/08/29/pro-git-2-git-basics</id>
   <content type="html">&lt;h1 id='git_'&gt;Git의 기초&lt;/h1&gt;

&lt;p&gt;Git을 사용하는 방법을 알고 싶은데 단 한 챕터밖에 읽을 시간이 없을 때 2장이 딱 맞다. Git을 사용하면서 자주 사용하는 명령어들은 모두 2장에 등장한다. 2장을 다 읽으면 저장소를 만들고 설정하는 방법, 파일을 추적하거나(Track) 추적을 그만두는 방법, 변경 내용을 Stage하고 커밋할 수 있는 방법을 알 수 있다. 우리는 또 특정 파일이나 파일의 패턴을 무시하도록 Git을 설정하는 방법, 실수를 쉽고 빠르게 만회하는 방법, 프로젝트의 히스토리를 조회하고 커밋을 서로 비교하는 방법, 원격 저장소에 Push하고 Pull하는 방법을 살펴볼 것이다.&lt;/p&gt;

&lt;h2 id='git__'&gt;Git 저장소 만들기&lt;/h2&gt;

&lt;p&gt;보통 프로젝트의 Git 저장소를 만드는 방법은 두 가지다. 하나는 기존에 있는 프로젝트를 Git 저장소로 만드는 방법이고 하나는 다른 서버에 있는 저장소를 Clone하는 것이다.&lt;/p&gt;

&lt;h3 id='_____'&gt;이미 있는 디렉토리에서 새 저장소 만들기&lt;/h3&gt;

&lt;p&gt;이미 있는 프로젝트를 추적하고 싶을 때, 프로젝트의 디렉토리로 이동해서 다음과 같은 명령을 실행한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git init&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 &lt;code&gt;.git&lt;/code&gt;이라는 하위디렉토리를 만든다. &lt;code&gt;.git&lt;/code&gt; 디렉토리에는 저장소를 이루는 뼈대가 되는 파일(Skeleton)이 들어 있다(&lt;code&gt;.git&lt;/code&gt; 디렉토리가 막 만들어진 직후 어떤 파일이 포함되는지에 대한 자세한 내용은 9장에서 다룬다). 하지만, 위 명령만으로는 아직 Git은 프로젝트의 어떤 파일도 추적하지 않는다.&lt;/p&gt;

&lt;p&gt;그리고 파일들의 버전을 관리하려면 Git이 파일을 관리하도록 저장소에 추가하고 최초로 커밋한다. &lt;code&gt;git add&lt;/code&gt; 명령으로 여러 파일을 추가하고 커밋한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add *.c
$ git add README
$ git commit -m &amp;#39;initial project version&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1분도 되지 않는 짧은 시간에 위의 명령어들을 실행하여 Git 저장소를 만들었고 파일을 추적하게 하였다.&lt;/p&gt;

&lt;h3 id='___clone'&gt;이미 있는 저장소를 Clone하기&lt;/h3&gt;

&lt;p&gt;다른 프로젝트에 참여하거나(Contribute) Git 저장소를 복사하고 싶을 때 &lt;code&gt;git clone&lt;/code&gt; 명령을 사용한다. 이미 Subversion 같은 VCS에 익숙하면 &lt;code&gt;checkout&lt;/code&gt;이 아니라 &lt;code&gt;clone&lt;/code&gt; 이라는 점이 눈에 띌 것이다. Subversion과 git의 가장 큰 차이점은 서버에 있는 모든 데이터를 복사한다는 것이다. &lt;code&gt;git clone&lt;/code&gt;을 실행하면 프로젝트 히스토리를 전부 받아온다. 실제로 서버의 디스크가 망가져도 클라이언트들의 저장소 중에서 아무거나 하나 가져다가 복구할 수 있다(서버에 특화된 설정은 복구하지 못하지만 모든 데이터는 복구된다 - 4장에서 좀 더 자세히 다룬다).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git clone [url]&lt;/code&gt;로 저장소를 Clone한다. 예를 들어, Ruby용 Git 라이브러리인 Grit을 Clone하려면 다음과 같이 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git://github.com/schacon/grit.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 &amp;#8220;grit&amp;#8221;이라는 디렉토리를 만들고 그 안에 &lt;code&gt;.git&lt;/code&gt; 디렉토리를 만든다. 그리고 저장소의 데이터도 모두 가져오고 자동으로 가장 최신 버전을 Checkout한다. &lt;code&gt;grit&lt;/code&gt; 디렉토리로 이동하면 Checkout으로 생성된 파일을 볼 수 있고 당장 하고자 하는 일을 바로 시작할 수 있다. 다음과 같은 명령을 사용하여 저장소를 Clone하면 &amp;#8220;grit&amp;#8221;이 아니라 다른 이름으로 Clone할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git://github.com/schacon/grit.git mygrit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;디렉토리 이름이 &lt;code&gt;mygrit&lt;/code&gt;이라는 것만 빼면 이 명령의 결과와 앞선 명령의 결과는 같다.&lt;/p&gt;

&lt;p&gt;Git은 다양한 프로토콜을 지원한다. 이제까지는 &lt;code&gt;git://&lt;/code&gt; 프로토콜을 사용했지만 &lt;code&gt;http(s)://&lt;/code&gt;를 사용할 수도 있고 &lt;code&gt;user@server:/path.git&lt;/code&gt;처럼 SSH 프로토콜을 사용할 수도 있다. 자세한 내용은 4장에서 다룬다. 4장에서는 각 프로토콜의 장단점도 알아보고 Git 저장소에 접근하는 방법들을 알아본다.&lt;/p&gt;

&lt;h2 id='__'&gt;수정하고 저장소에 저장하기&lt;/h2&gt;

&lt;p&gt;Git 저장소를 하나 만들고 일할 수 있도록 Checkout했다. 이제는 파일을 수정하고 파일의 Snapshot을 커밋해 보자. 파일들을 수정하다가 저장하고 싶으면 Snapshot을 커밋한다.&lt;/p&gt;

&lt;p&gt;작업 디렉토리의 모든 파일은 크게 Tracked(관리대상임)와 Untracked(관리대상이 아님)로 나눈다. Tracked 파일은 이미 Snapshot에 포함돼 있던 파일이다. Tracked 파일들은 또 Unmodified(수정하지 않음)와 Modified(수정함) 그리고 Staged(커밋을 하면 현재 수정 사항을 저장소에 기록함) 상태 중 하나이다. 그리고 나머지 파일들은 모두 Untracked 파일이다. Untracked 파일은 작업 디렉토리에 있는 모든 파일이 Snapshot에 포함돼 있는 것은 아니고 Staging Area에 있는 것도 아니다. 처음 저장소를 Clone하고 나면 모든 파일은 Tracked이면서 Unmodified 상태이다. Git은 저장소를 Clone하면 자동으로 파일을 Checkout하고 아직 아무것도 편집하지 않은 상태다.&lt;/p&gt;

&lt;p&gt;마지막 커밋 이후 아직 아무것도 수정하지 않은 상태에서 어떤 파일이 수정되면 Git은 그 즉시 파일을 Modified 상태로 인식한다. 그리고 이 수정한 파일을 Stage하고 Staged 상태인 파일들을 커밋한다. 이 라이프사이클을 그림 2-1처럼 계속 반복한다.&lt;/p&gt;

&lt;p&gt;&lt;img src='/images/progit/18333fig0201-tn.png' alt='' /&gt;&lt;/p&gt;

&lt;p&gt;Figure 2-1. 파일의 라이프사이클&lt;/p&gt;

&lt;h3 id='__'&gt;파일의 상태 확인하기&lt;/h3&gt;

&lt;p&gt;파일의 상태를 확인하려면 보통 &lt;code&gt;git status&lt;/code&gt; 명령을 사용한다. Clone한 후에 바로 이 명령을 실행하면 다음과 같은 메시지를 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git status
# On branch master
nothing to commit (working directory clean)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 내용은 파일을 하나도 수정하지 않았다는 것을 말해준다. 즉, Tracked와 Modified 상태의 파일이 없다. Untracked 파일은 아직 없어서 목록에 나타나지 않는다. 그리고 현재 작업 중인 브랜치를 알려준다. 기본 브랜치가 master이기 때문에 현재 master로 나오는 것이다. 브랜치 관련 내용은 차차 알아가자. 다음 장에서 브랜치와 레퍼런스에 대해 자세히 다룬다.&lt;/p&gt;

&lt;p&gt;프로젝트에 README 파일을 만들어보자. README 파일은 새로 만든 파일이기 때문에 &lt;code&gt;git status&lt;/code&gt;를 실행하면 Untracked에 들어 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vim README
$ git status
# On branch master
# Untracked files:
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to include in what will be committed)
#
#	README
nothing added to commit but untracked files present (use &amp;quot;git add&amp;quot; to track)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;README 파일은 &lt;code&gt;Untracked files&lt;/code&gt; 부분에 속해 있는데 이것은 README 파일이 Untracked 상태라는 것을 말한다. Git은 Untracked 파일을 이전 Snapshot(커밋)에는 없는 파일이라고 본다. Git은 파일이 Tracked 상태가 되기 전까지는 절대 그 파일들을 커밋하지 않는다. 그래서 일하는 동안 생성된 파일인 바이너리 파일 같은 것을 커밋하는 실수는 하지 않게 된다. README파일을 포함해 직접 Tracked 상태로 만들어 보자.&lt;/p&gt;

&lt;h3 id='__'&gt;새 파일을 추적하기&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;git add&lt;/code&gt; 명령을 사용하여 새로운 파일을 추적할 수 있다. 다음 명령을 실행하면 Git은 README 파일을 추적한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add README&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git status&lt;/code&gt; 명령을 다시 실행하면 README 파일이 Tracked 상태이면서 Staged 상태라는 것을 확인할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#	new file:   README
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#8216;Changes to be committed&amp;#8217; 에 들어 있는 파일은 Staged 상태라는 것을 의미한다. 커밋하면 &lt;code&gt;git add&lt;/code&gt;를 실행한 시점의 파일이 커밋되어 저장소 히스토리에 남는다. 우선 &lt;code&gt;git init&lt;/code&gt; 명령을 실행하고 나서 &lt;code&gt;git add&lt;/code&gt; 명령을 실행하면 Git은 앞으로 작업 디렉토리에 있는 파일들을 추적한다. 파일의 경로를 전부 적어주지 않아도 &lt;code&gt;git add&lt;/code&gt; 명령이 알아서 찾는다. 디렉토리를 추가하면 디렉토리 하위에 있는 파일들을 모두 추가한다.&lt;/p&gt;

&lt;h3 id='modified___stage'&gt;Modified 상태의 파일을 Stage하기&lt;/h3&gt;

&lt;p&gt;이미 Tracked 상태인 파일을 수정하는 법을 알아보자. &lt;code&gt;benchmarks.rb&lt;/code&gt;라는 파일을 수정하고 나서 &lt;code&gt;git status&lt;/code&gt; 명령을 다시 실행하면 결과는 다음과 같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#	new file:   README
#
# Changed but not updated:
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
#
#	modified:   benchmarks.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 &lt;code&gt;benchmarks.rb&lt;/code&gt; 파일은 &lt;code&gt;Changed but not updated&lt;/code&gt;에 있다. 이것은 수정한 파일이 Tracked 상태이지만 아직 Staged 상태는 아니라는 것이다. Staged 상태로 만들려면 &lt;code&gt;git add&lt;/code&gt; 명령을 실행해야 한다. &lt;code&gt;git add&lt;/code&gt;는 파일을 새로 추적할 때도 사용하고 수정한 파일을 Staged 상태로 만드는데에도 사용한다. &lt;code&gt;git add&lt;/code&gt;를 실행하여 benchmarks.rb 파일을 Staged 상태로 만들고 &lt;code&gt;git status&lt;/code&gt; 명령으로 결과를 확인해보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add benchmarks.rb
$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#	new file:   README
#	modified:   benchmarks.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;두 파일 모두 Staged 상태이므로 다음 커밋에 포함된다. 하지만, 아직 더 수정해야 한다는 것을 알게 되어 바로 커밋하지 못하는 상황이 되었다고 하자. 이 상황에서 benchmark.rb 파일을 열고 수정한다. 이제 아마 당신은 커밋할 준비가 다 됐다고 생각할 것이다. 하지만, Git에게는 그렇지 않다. &lt;code&gt;git status&lt;/code&gt; 명령으로 파일의 상태를 다시 확인해보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vim benchmarks.rb
$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#	new file:   README
#	modified:   benchmarks.rb
#
# Changed but not updated:
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
#
#	modified:   benchmarks.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;헉! benchmarks.rb가 Staged 상태이면서 동시에 Unstaged 상태로 나온다. 어떻게 이런 일이 가능할까? &lt;code&gt;git add&lt;/code&gt; 명령을 실행하면 Git은 파일을 바로 Staged 상태로 만든다. 지금 이 시점에서 커밋을 하면 &lt;code&gt;git commit&lt;/code&gt; 명령을 실행하는 시점의 버전이 커밋되는 것이 아니라 마지막으로 &lt;code&gt;git add&lt;/code&gt; 명령을 실행했을 때의 버전이 커밋된다. 그러니까 &lt;code&gt;git add&lt;/code&gt; 명령을 실행 후에 또 파일을 수정하면 &lt;code&gt;git add&lt;/code&gt; 명령을 다시 실행하여 최신 버전을 Staged 상태로 만들어야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add benchmarks.rb
$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#	new file:   README
#	modified:   benchmarks.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='_'&gt;파일 무시하기&lt;/h3&gt;

&lt;p&gt;어떤 파일들은 Git이 자동으로 추가하지도 Untracked 파일이라고 보여줄 필요가 없다. 보통 로그 파일이나 빌드 시스템이 자동으로 생성한 파일들이 그렇다. 그런 파일을 무시하려면 &lt;code&gt;.gitignore&lt;/code&gt; 파일을 만들고 그 안에 무시할 파일 패턴을 적는다. 다음은 &lt;code&gt;.gitignore&lt;/code&gt; 파일의 예이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat .gitignore
*.[oa]
*~&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;첫번째 줄은 확장자가 &lt;code&gt;.o&lt;/code&gt; 나 &lt;code&gt;.a&lt;/code&gt;인 파일을 Git이 무시하라는 것이고 둘째 줄은 &lt;code&gt;~&lt;/code&gt;로 끝나는 모든 파일을 무시하라는 것이다. &lt;code&gt;.o&lt;/code&gt;와 &lt;code&gt;.a&lt;/code&gt;는 각각 빌드 시스템이 만들어내는 오브젝트와 아카이브 파일이고 &lt;code&gt;~&lt;/code&gt;로 끝나는 파일은 Emacs나 VI 같은 텍스트 편집기들이 임시로 만들어내는 파일이다. 또 log, tmp, pid 같은 디렉토리나, 자동으로 생성하는 문서 같은 것들도 추가할 수 있다. &lt;code&gt;.gitingnore&lt;/code&gt; 파일은 보통 처음에 만들어 두는 것이 편리하다. 그래서 Git 저장소에 커밋하고 싶지 않은 파일을 실수로 커밋하는 일을 방지한다.&lt;/p&gt;

&lt;p&gt;.gitignore 파일에 입력하는 패턴은 다음의 규칙을 따른다:&lt;/p&gt;

&lt;p&gt;* 아무것도 없는 줄이나, &lt;code&gt;#&lt;/code&gt;로 시작하는 줄은 무시한다. * 표준 Glob 패턴을 사용한다. * 디렉토리는 슬래시(&lt;code&gt;/&lt;/code&gt;)를 끝에 사용하는 것으로 표현한다. * 느낌표(&lt;code&gt;!&lt;/code&gt;)로 시작하는 패턴은 해당 패턴의 파일을 무시하지 않는다.&lt;/p&gt;

&lt;p&gt;Glob 패턴은 정규표현식을 단순하게 만든 것으로 생각하면 되고 보통 쉘에서 많이 사용한다. 애스터리스크(&lt;code&gt;*&lt;/code&gt;)는 문자가 하나도 없거나 하나 이상을 의미하고, &lt;code&gt;[abc]&lt;/code&gt;는 중괄호 안에 있는 문자 중 하나를 의미한다(그러니까 이 경우에는 a, b, c). 물음표(&lt;code&gt;?&lt;/code&gt;)는 문자 하나를 말하고, &lt;code&gt;[0-9]&lt;/code&gt;처럼 중괄호 안의 캐릭터 사이에 하이픈(&lt;code&gt;-&lt;/code&gt;)을 사용하면 그 캐릭터 사이에 있는 문자 하나를 말한다.&lt;/p&gt;

&lt;p&gt;다음은 .gitignore 파일의 예이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# a comment - 이 줄은 무시한다.
*.a       # 확장자가 .a인 파일 무시
!lib.a    # 윗 줄에서 확장자가 .a인 파일은 무시하게 했지만 lib.a는 무시하지 않는다.
/TODO     # 루트 디렉토리에 있는 TODO파일은 무시하고 subdir/ROOT처럼 하위디렉토리에 있는 파일은 무시하지 않는다.
build/    # build/ 디렉토리에 있는 모든 파일은 무시한다.
doc/*.txt # `doc/notes.txt`같은 파일은 무시하고 doc/server/arch.txt같은 파일은 무시하지 않는다.&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='staged_unstaged____'&gt;Staged와 Unstaged 상태의 변경 내용을 보기&lt;/h3&gt;

&lt;p&gt;단순히 파일이 변경됐다는 사실이 아니라 어떤 내용이 변경됐는지 살펴보기엔 &lt;code&gt;git status&lt;/code&gt; 명령은 부족해서 &lt;code&gt;git diff&lt;/code&gt; 명령을 사용해야 한다. 일반적으로 우리는 &amp;#8216;수정했지만, 아직 Staged 파일이 아닌것?&amp;#8217;과 &amp;#8216;어떤 파일이 Staged 상태인지?&amp;#8217;가 궁금하기 때문에 &lt;code&gt;git status&lt;/code&gt; 명령으로도 충분하다. &lt;code&gt;git diff&lt;/code&gt;는 Patch처럼 어떤 라인을 추가했고 삭제했는지 알아야 할 때에 사용한다. &lt;code&gt;git diff&lt;/code&gt;는 나중에 더 자세히 다룬다.&lt;/p&gt;

&lt;p&gt;README 파일을 수정하고 Staged 상태로 만들어 보자. benchmarks.rb 파일은 그냥 수정만 해둔다. 이 상태에서 &lt;code&gt;git status&lt;/code&gt; 명령을 실행하면 다음과 같은 메시지를 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#	new file:   README
#
# Changed but not updated:
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
#
#	modified:   benchmarks.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git diff&lt;/code&gt; 명령을 실행하면 수정했지만 아직 staged 상태가 아닌 파일을 비교해 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff
diff --git a/benchmarks.rb b/benchmarks.rb
index 3cb747f..da65585 100644
--- a/benchmarks.rb
+++ b/benchmarks.rb
@@ -36,6 +36,10 @@ def main
           @commit.parents[0].parents[0].parents[0]
         end

+        run_code(x, &amp;#39;commits 1&amp;#39;) do
+          git.commits.size
+        end
+
         run_code(x, &amp;#39;commits 2&amp;#39;) do
           log = git.commits(&amp;#39;master&amp;#39;, 15)
           log.size&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 작업 디렉토리에 있는 것과 Staging Area에 있는 것을 비교한다. 그래서 수정하고 아직 Staged 상태가 아닌 것들을 보여준다.&lt;/p&gt;

&lt;p&gt;만약 커밋하려고 Staging Area에 넣은 파일의 변경 부분을 보고 싶으면 &lt;code&gt;git diff --cached&lt;/code&gt; 옵션을 사용한다(Git 버전 1.6.1부터는 좀 더 기억하기 쉽게 &lt;code&gt;git diff --staged&lt;/code&gt;로도 사용할 수 있다). 이 명령은 Staging Area와 저장소에 커밋한 것을 비교한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff --cached
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README2
@@ -0,0 +1,5 @@
+grit
+ by Tom Preston-Werner, Chris Wanstrath
+ http://github.com/mojombo/grit
+
+Grit is a Ruby library for extracting information from a Git repository&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;꼭 잊지 말아야 할 것이 있는데 &lt;code&gt;git diff&lt;/code&gt; 명령은 마지막으로 커밋한 후에 수정한 것을 보여주지 않는다. &lt;code&gt;git diff&lt;/code&gt;는 Unstaged 상태인 것들만 보여준다. 이 부분은 조금 헷갈릴 수도 있는데, 수정한 파일을 모두 Staging Area에 넣었다면 &lt;code&gt;git diff&lt;/code&gt; 명령은 아무것도 출력하지 않는다.&lt;/p&gt;

&lt;p&gt;benchmarks.rb 파일을 Stage한 후 다시 수정해도 &lt;code&gt;git diff&lt;/code&gt; 명령을 사용할 수 있다. 이 경우 Staged 상태인 것과 Unstaged 상태인 것을 비교한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add benchmarks.rb
$ echo &amp;#39;# test line&amp;#39; &amp;gt;&amp;gt; benchmarks.rb
$ git status
# On branch master
#
# Changes to be committed:
#
#	modified:   benchmarks.rb
#
# Changed but not updated:
#
#	modified:   benchmarks.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git diff&lt;/code&gt; 명령으로 Unstaged 상태인 변경 부분을 확인해 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff
diff --git a/benchmarks.rb b/benchmarks.rb
index e445e28..86b2f7c 100644
--- a/benchmarks.rb
+++ b/benchmarks.rb
@@ -127,3 +127,4 @@ end
 main()

 ##pp Grit::GitRuby.cache_client.stats
+# test line&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Staged 상태인 파일은 &lt;code&gt;git diff --cached&lt;/code&gt; 옵션으로 확인한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff --cached
diff --git a/benchmarks.rb b/benchmarks.rb
index 3cb747f..e445e28 100644
--- a/benchmarks.rb
+++ b/benchmarks.rb
@@ -36,6 +36,10 @@ def main
          @commit.parents[0].parents[0].parents[0]
        end

+        run_code(x, &amp;#39;commits 1&amp;#39;) do
+          git.commits.size
+        end
+
        run_code(x, &amp;#39;commits 2&amp;#39;) do
          log = git.commits(&amp;#39;master&amp;#39;, 15)
          log.size&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='_'&gt;변경사항 커밋하기&lt;/h3&gt;

&lt;p&gt;수정한 것을 커밋하기 위해 Staging Area에 파일을 정리했다. Unstaged 상태의 파일은 커밋되지 않는다는 것을 기억해야 한다. Git은 생성하거나 수정하고 나서 &lt;code&gt;git add&lt;/code&gt; 명령으로 추가하지 않은 파일은 커밋하지 않는다. 그 파일은 여전히 Modified 상태로 남아 있다.&lt;/p&gt;

&lt;p&gt;커밋하기 전에 &lt;code&gt;git status&lt;/code&gt; 명령으로 모든 것이 Staged 상태인지 확인할 수 있다. 그리고 &lt;code&gt;git commit&lt;/code&gt;을 실행하여 커밋한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git 설정에 지정된 편집기가 다음과 같이 실행되고, 다음과 같은 텍스트가 자동으로 포함된다(아래 예제는 Vim 편집기의 화면이다). 이 편집기는 쉘의 $EDITOR 환경 변수에 등록된 편집기이고 보통은 Vim이나 Emacs을 사용한다. 또 1장에서 설명했듯이 &lt;code&gt;git config --global core.editor&lt;/code&gt; 명령으로 어떤 편집기를 사용할지 설정할 수 있다:&lt;/p&gt;

&lt;p&gt;편집기는 아래와 같은 내용을 표시한다(아래 예제는 Vim 편집기의 경우):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Please enter the commit message for your changes. Lines starting
# with &amp;#39;#&amp;#39; will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#       new file:   README
#       modified:   benchmarks.rb
~
~
~
&amp;quot;.git/COMMIT_EDITMSG&amp;quot; 10L, 283C&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자동으로 생성되는 커밋 메시지는 첫 줄은 비어 있고 둘째 줄부터 &lt;code&gt;git status&lt;/code&gt; 명령의 결과가 채워진다. 커밋한 내용을 쉽게 기억할 수 있도록 이 메시지를 포함할 수도 있고 메시지를 전부 지우고 새로 작성할 수 있다(수정한 내용을 좀 더 구체적으로 남겨 둘 수 있다. &lt;code&gt;git commit&lt;/code&gt;에 -v 옵션을 추가하면 편집기에 diff 메시지도 추가된다).&lt;/p&gt;

&lt;p&gt;메시지를 인라인으로 첨부할 수도 있다. &lt;code&gt;commit&lt;/code&gt; 명령을 실행할 때 다음과 같이 &lt;code&gt;-m&lt;/code&gt; 옵션을 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit -m &amp;quot;Story 182: Fix benchmarks for speed&amp;quot;
[master]: created 463dc4f: &amp;quot;Fix benchmarks for speed&amp;quot;
 2 files changed, 3 insertions(+), 0 deletions(-)
 create mode 100644 README&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;commit&lt;/code&gt; 명령은 몇 가지 정보를 출력하는데 위 예제는 master 브랜치에 커밋했고 체크섬은 &lt;code&gt;463dc4f&lt;/code&gt;이라고 알려준다. 그리고 수정한 파일이 몇 개이고 삭제됐거나 추가된 줄이 몇 줄인지 알려준다.&lt;/p&gt;

&lt;p&gt;Git은 Staging Area에 속한 Snapshot을 커밋한다는 것을 기억해야 한다. 수정은 했지만, 아직 Staging Area에 넣지 않은 것들은 다음에 커밋할 수 있다. 커밋할 때마다 프로젝트의 Snapshot을 기록하기 때문에 나중에 Snapshot끼리 비교하거나 예전 Snapshot으로 되돌릴 수 있다.&lt;/p&gt;

&lt;h3 id='staging_area_'&gt;Staging Area 생략하기&lt;/h3&gt;

&lt;p&gt;Staging Area는 커밋할 파일들을 정리한다는 점에서 매우 유용하지만 복잡하기만 하고 필요하지 않은 때도 있다. 아주 쉽게 Staging Area를 생략할 수 있다. &lt;code&gt;git commit&lt;/code&gt; 명령을 실행할 때 &lt;code&gt;-a&lt;/code&gt; 옵션을 추가하면 Git은 Tracked 상태의 파일이라면 자동으로 Staging Area에 넣는다. 그래서 &lt;code&gt;git add&lt;/code&gt; 명령을 실행하는 수고를 덜 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git status
# On branch master
#
# Changed but not updated:
#
#	modified:   benchmarks.rb
#
$ git commit -a -m &amp;#39;added new benchmarks&amp;#39;
[master 83e38c7] added new benchmarks
 1 files changed, 5 insertions(+), 0 deletions(-)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 예제에서는 커밋하기 전에 &lt;code&gt;git add&lt;/code&gt; 명령으로 benchmarks.rb 파일을 추가하지 않았다는 점을 눈여겨보자.&lt;/p&gt;

&lt;h3 id='_'&gt;파일을 삭제하기&lt;/h3&gt;

&lt;p&gt;Git에서 파일을 제거하려면 &lt;code&gt;git rm&lt;/code&gt; 명령으로 Tracked 상태의 파일을 삭제한 후에(정확하게는 Staging Area에서 삭제하는 것) 커밋해야 한다. 이 명령은 작업 디렉토리에 있는 파일도 삭제하기 때문에 실제로 지워진다.&lt;/p&gt;

&lt;p&gt;만약 Git없이 그냥 파일을 삭제하고 &lt;code&gt;git status&lt;/code&gt; 명령으로 상태를 확인하면 &lt;code&gt;Changed but not updated&lt;/code&gt;(즉, Unstaged) 에 속해 있는 것을 확인할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm grit.gemspec
$ git status
# On branch master
#
# Changed but not updated:
#   (use &amp;quot;git add/rm &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
#
#       deleted:    grit.gemspec
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 &lt;code&gt;git rm&lt;/code&gt; 명령을 실행하면 삭제한 파일은 staged 상태가 된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rm grit.gemspec
rm &amp;#39;grit.gemspec&amp;#39;
$ git status
# On branch master
#
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#       deleted:    grit.gemspec
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;커밋하면 파일은 삭제되고 Git은 이 파일을 더는 추적하지 않는다. 이미 파일을 수정했거나 Index에(역주, Staging Area을 Git Index라고도 부른다) 추가했다면 &lt;code&gt;-f&lt;/code&gt;옵션을 주어 강제로 삭제해야 한다. 이 점은 실수로 데이터를 삭제하지 못하도록 하는 안전장치다. 한 번도 커밋한적 없는 데이터는 Git으로 복구할 수 없다.&lt;/p&gt;

&lt;p&gt;또 Staging Area에서만 제거하고 작업 디렉토리에 있는 파일은 지우지 않고 남겨둘 수 있다. 다시 말해서 하드디스크에 있는 파일은 그대로 두고 Git만 더는 추적하지 않게 한다. 이것은 &lt;code&gt;.gitingnore&lt;/code&gt; 파일에 추가하는 것을 빼먹었거나 대용량 로그 파일이나 컴파일된 파일인 &lt;code&gt;.a&lt;/code&gt; 파일 같은 것을 실수로 추가했을 때 쓴다. &lt;code&gt;--cached&lt;/code&gt; 옵션을 사용하여 명령을 실행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rm --cached readme.txt&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여러 개의 파일이나 디렉토리를 한꺼번에 삭제할 수도 있다. 다음과 같이 &lt;code&gt;git rm&lt;/code&gt; 명령에 file-glob 패턴을 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rm log/\*.log&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt;앞에 &lt;code&gt;\&lt;/code&gt;을 사용한 것을 기억하자. 쉘의 확장자도 그렇지만 Git의 파일 확장자에서도 &lt;code&gt;\&lt;/code&gt;는 필요하다. 이 명령은 &lt;code&gt;log/&lt;/code&gt; 디렉토리에 있는 &lt;code&gt;.log&lt;/code&gt; 파일을 모두 삭제한다. 다음의 예제처럼 할 수도 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rm \*~&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 &lt;code&gt;~&lt;/code&gt;로 끝나는 파일을 모두 삭제한다.&lt;/p&gt;

&lt;h3 id='__'&gt;파일 이름 변경하기&lt;/h3&gt;

&lt;p&gt;Git은 다른 VCS 시스템과는 달리 파일 이름의 변경이나 파일의 이동을 명시적으로 관리하지 않는다. 다시 말해서 파일 이름이 변경됐다는 별도의 정보를 저장하지 않는다. Git은 똑똑해서 굳이 파일 이름이 변경되었다는 것을 추적하지 않아도 아는 방법이 있다. 이제 Git이 파일의 이름이 변경된 것을 어떻게 알아내는지 살펴본다.&lt;/p&gt;

&lt;p&gt;이렇게 말해도 Git에 &lt;code&gt;mv&lt;/code&gt; 명령이 있는 게 좀 이상하겠지만, 다음과 같이 파일이름을 변경할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git mv file_from file_to&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;잘 동작한다. 이 명령을 실행하고 Git의 상태를 확인해보면 Git은 이름이 바뀐 사실을 알고 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git mv README.txt README
$ git status
# On branch master
# Your branch is ahead of &amp;#39;origin/master&amp;#39; by 1 commit.
#
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#       renamed:    README.txt -&amp;gt; README
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;사실 &lt;code&gt;git mv&lt;/code&gt; 명령은 다음의 명령어들을 수행한 것과 완전히 똑같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mv README.txt README
$ git rm README.txt
$ git add README&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git mv&lt;/code&gt;는 일종의 단축 명령어이다. 이 명령으로 파일이름을 바꿔도 되고 &lt;code&gt;mv&lt;/code&gt; 명령으로 파일이름을 직접 바꿔도 된다. 단지 Git의 &lt;code&gt;mv&lt;/code&gt;명령은 편리하게 명령을 세 번 실행해주는 것뿐이다. 어떤 도구로 이름을 바꿔도 상관없다. 중요한 것은 이름을 변경하고 나서 꼭 rm/add 명령을 실행해야 한다는 것뿐이다.&lt;/p&gt;

&lt;h2 id='__'&gt;커밋 히스토리 조회하기&lt;/h2&gt;

&lt;p&gt;새로 저장소를 만들어서 몇 번 커밋을 했을 수도 있고, 커밋 히스토리가 있는 저장소를 Clone했을 수도 있다. 어쨌든 가끔 저장소의 히스토리를 보고 싶을 때가 있다. Git에는 히스토리를 조회하는 명령어인 &lt;code&gt;git log&lt;/code&gt;가 있다.&lt;/p&gt;

&lt;p&gt;이 예제에서는 simplegit 이라는 매우 단순한 프로젝트를 사용한다. simplegit은 Git을 설명하는데 자주 사용하는 예제다. 다음과 같이 이 프로젝트를 Clone한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git://github.com/schacon/simplegit-progit.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 프로젝트 디렉토리에서 &lt;code&gt;git log&lt;/code&gt; 명령을 실행하면 다음과 같이 출력된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test code

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;특별한 인자 없이 &lt;code&gt;git log&lt;/code&gt; 명령을 실행하면 저장소의 커밋 히스토리를 시간순으로 보여준다. 즉, 가장 최근의 커밋이 가장 먼저 나온다. 그리고 이어서 각 커밋의 SHA-1 체크섬, 저자 이름, 저자 이메일, 커밋한 날짜, 커밋 메시지를 보여준다.&lt;/p&gt;

&lt;p&gt;원하는 히스토리를 검색할 수 있도록 &lt;code&gt;git log&lt;/code&gt; 명령은 매우 다양한 옵션을 지원한다. 여기에서는 자주 사용하는 옵션을 설명한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-p&lt;/code&gt;가 가장 유용한 옵션 중 하나다. &lt;code&gt;-p&lt;/code&gt;는 각 커밋의 diff 결과를 보여준다. 게다가 &lt;code&gt;-2&lt;/code&gt;는 최근 두 개의 결과만 보여주는 옵션이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log -p -2
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

diff --git a/Rakefile b/Rakefile
index a874b73..8f94139 100644
--- a/Rakefile
+++ b/Rakefile
@@ -5,7 +5,7 @@ require &amp;#39;rake/gempackagetask&amp;#39;
 spec = Gem::Specification.new do |s|
-    s.version   =   &amp;quot;0.1.0&amp;quot;
+    s.version   =   &amp;quot;0.1.1&amp;quot;
     s.author    =   &amp;quot;Scott Chacon&amp;quot;

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test code

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index a0a60ae..47c6340 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -18,8 +18,3 @@ class SimpleGit
     end

 end
-
-if $0 == __FILE__
-  git = SimpleGit.new
-  puts git.show
-end
\ No newline at end of file&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 옵션은 직접 diff를 실행한 것과 같은 결과를 출력하기 때문에 동료가 무엇을 커밋했는지 리뷰하고 빨리 조회하는데 유용하다.&lt;/p&gt;

&lt;p&gt;또 &lt;code&gt;git log&lt;/code&gt; 명령에는 히스토리의 통계를 보여주는 옵션도 있다. &lt;code&gt;--stat&lt;/code&gt; 옵션으로 각 커밋의 통계 정보를 조회할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --stat
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

 Rakefile |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test code

 lib/simplegit.rb |    5 -----
 1 files changed, 0 insertions(+), 5 deletions(-)

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit

 README           |    6 ++++++
 Rakefile         |   23 +++++++++++++++++++++++
 lib/simplegit.rb |   25 +++++++++++++++++++++++++
 3 files changed, 54 insertions(+), 0 deletions(-)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 결과에서 &lt;code&gt;--stat&lt;/code&gt; 옵션은 어떤 파일이 수정됐는지, 얼마나 많은 파일이 변경됐는지, 또 얼마나 많은 줄을 추가하거나 삭제했는지 보여준다. 요약정보는 가장 뒤쪽에 보여준다.&lt;/p&gt;

&lt;p&gt;다른 또 유용한 옵션은 &lt;code&gt;--pretty&lt;/code&gt; 옵션이다. 이 옵션을 통해 log의 내용을 보여줄 때 기본 형식 이외에 여러 가지 중에 하나를 선택할 수 있다. &lt;code&gt;oneline&lt;/code&gt; 옵션은 각 커밋을 한 줄로 보여준다. 이 옵션은 많은 커밋을 한 번에 조회할 때 유용하다. 추가로 &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;full&lt;/code&gt;, &lt;code&gt;fuller&lt;/code&gt; 옵션도 있는데 이것들은 정보를 조금씩 가감해서 보여준다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --pretty=oneline
ca82a6dff817ec66f44342007202690a93763949 changed the version number
085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test code
a11bef06a3f659402fe7563abf99ad00de2209e6 first commit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;가장 재밌는 옵션은 &lt;code&gt;format&lt;/code&gt; 옵션이다. 나만의 형식으로 결과를 출력하고 싶을 때 사용한다. 특히 결과를 다른 프로그램으로 파싱하고자 할 때 유용하다. 이 옵션을 사용하면 형식을 정확하게 일치시킬 수 있기 때문에 Git을 새 버전으로 바꿔도 결과의 형식이 바뀌지 않는다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --pretty=format:&amp;quot;%h - %an, %ar : %s&amp;quot;
ca82a6d - Scott Chacon, 11 months ago : changed the version number
085bb3b - Scott Chacon, 11 months ago : removed unnecessary test code
a11bef0 - Scott Chacon, 11 months ago : first commit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;표 2-1 형식에서 사용하는 유용한 옵션들.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Option	Description of Output
%H	Commit hash
%h	Abbreviated commit hash
%T	Tree hash
%t	Abbreviated tree hash
%P	Parent hashes
%p	Abbreviated parent hashes
%an	Author name
%ae	Author e-mail
%ad	Author date (format respects the –date= option)
%ar	Author date, relative
%cn	Committer name
%ce	Committer email
%cd	Committer date
%cr	Committer date, relative
%s	Subject&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;저자(Author)&lt;/em&gt; 와 &lt;em&gt;커미터(Committer)&lt;/em&gt; 를 구분하는 것이 조금 이상해 보일 수 있다. 저자는 원래 작업을 수행한 원작자이고 커밋터는 마지막으로 이 작업을 적용한 사람이다. 만약 당신이 어떤 프로젝트에 패치를 보냈고 그 프로젝트의 담당자가 패치를 적용했다면 두 명의 정보를 모두 알 필요가 있다. 그래서 이 경우 당신이 저자고 그 담당자가 커미터다. 5장에서 이 주제에 대해 자세히 다룰 것이다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;oneline&lt;/code&gt;과 &lt;code&gt;format&lt;/code&gt; 옵션은 &lt;code&gt;--graph&lt;/code&gt; 옵션과 함께 사용할 때 더 빛난다. 이 명령은 브랜치와 머지 히스토리를 보여주는 아스키 그래프를 출력한다. 이 명령을 Grit 프로젝트 저장소에서 사용해보면 다음과 같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --pretty=format:&amp;quot;%h %s&amp;quot; --graph
* 2d3acf9 ignore errors from SIGCHLD on trap
*  5e3ee11 Merge branch &amp;#39;master&amp;#39; of git://github.com/dustin/grit
|\
| * 420eac9 Added a method for getting the current branch.
* | 30e367c timeout code and tests
* | 5a09431 add timeout protection to grit
* | e1193f8 support for heads with slashes in them
|/
* d6016bc require time for xmlschema
*  11d191e Merge branch &amp;#39;defunkt&amp;#39; into local&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git log&lt;/code&gt; 명령의 기본적인 옵션과 출력물의 형식에 관련된 옵션을 살펴보았다. &lt;code&gt;git log&lt;/code&gt; 명령은 앞서 살펴본 것보다 더 많은 옵션을 지원한다. 표 2-2 는 지금 설명한 것과 함께 유용하게 사용할 수 있는 옵션들이다. 각 옵션으로 어떻게 &lt;code&gt;log&lt;/code&gt; 명령을 제어할 수 있는지 보여준다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;옵션  설명
-p	각 커밋에 적용된 패치를 보여준다.
--stat	각 커밋에서 수정된 파일의 통계정보를 보여준다.
--shortstat	 `--stat` 명령의 결과 중에서 수정한 파일, 추가된 줄, 삭제된 줄만 보여준다.
--name-only	 커밋 정보중에서 수정된 파일의 목록만 보여준다.
--name-status	 수정된 파일의 목록을 보여줄 뿐만 아니라 파일을 추가한 것인지, 수정한 것인지, 삭제한 것인지도 보여준다.
--abbrev-commit	 40자 짜리 SHA-1 체크섬을 전부 보여주는 것이 아니라 처음 몇 자만 보여준다.
--relative-date	 정확한 시간을 보여주는 것이 아니라 `2 주전`처럼 상대적인 형식으로 보여준다.
--graph	브랜치와 머지 히스토리 정보까지 아스키 그래프로 보여준다.
--pretty	지정한 형식으로 보여준다. 이 옵션에는 oneline, short, full, fuller, format이 있다. format은 원하는 형식으로 출력하고자 할 때 사용한다.&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='_'&gt;조회 제한조건&lt;/h3&gt;

&lt;p&gt;출력 형식과 관련된 옵션들을 살펴봤지만 &lt;code&gt;git log&lt;/code&gt; 명령은 조회 범위를 제한하는 옵션들도 있다. 히스토리 전부가 아니라 부분만 조회한다. 이미 최근 두 개만 조회하는 &lt;code&gt;-2&lt;/code&gt; 옵션은 살펴봤다. 실제 사용법은 &lt;code&gt;-&amp;lt;n&amp;gt;&lt;/code&gt;이고 n은 최근 n개의 커밋을 의미한다. 하지만, 현실에서는 종종 다른 조건으로 조회해야 한다. 그리고 Git은 모든 결과를 한 번에 한 페이지씩만 보여주기 때문에 더욱 필요하다.&lt;/p&gt;

&lt;p&gt;그래서 &lt;code&gt;--since&lt;/code&gt;나 &lt;code&gt;--until&lt;/code&gt;같은 시간을 기준으로 조회하는 옵션이 유용하다. 지난 2주 동안 만들어진 커밋들만 조회하는 명령은 다음과 같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --since=2.weeks&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 옵션은 다양한 형식을 지원한다. &lt;code&gt;2008-01-15&lt;/code&gt;같이 정확한 날짜도 사용할 수 있고 &lt;code&gt;2 years 1 day 3 minutes ago&lt;/code&gt;같이 상대적인 기간을 사용할 수도 있다.&lt;/p&gt;

&lt;p&gt;또 다른 기준도 있다. &lt;code&gt;--author&lt;/code&gt; 옵션으로 저자를 지정하여 검색할 수도 있고 &lt;code&gt;--grep&lt;/code&gt; 옵션으로 커밋 메시지에서 키워드를 검색할 수도 있다(author와 grep 옵션을 나눠서 지정하고 싶지 않으면 &lt;code&gt;--all-match&lt;/code&gt; 옵션으로 한 번에 검색할 수 있다).&lt;/p&gt;

&lt;p&gt;마지막으로 파일 경로로 검색하는 옵션이 있는데 이것도 정말 유용하다. 디렉토리나 파일 이름을 사용하여 그 파일이 변경된 log의 결과를 검색할 수 있다. 이 옵션은 &lt;code&gt;--&lt;/code&gt;와 함께 경로 이름들을 사용하는데 명령어 끝 부분에 쓴다(역주, &lt;code&gt;git log -- path1 path2&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;표 2-3은 조회 범위를 제한하는 옵션들이다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;옵션	설명
-(n)	최근 n 개의 커밋만 조회한다.
--since, --after	명시한 날짜 이후의 커밋만 검색한다.
--until, --before	명시한 날짜 이전의 커밋만 조회한다.
--author	입력한 저자의 커밋만 보여준다.
--committer	입력한 커미터의 커밋만 보여준다.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음의 예제는 2008년 10월에 Junio Hamano가 커밋한 히스토리를 조회하는 것이다. 그 중에서 테스트 파일을 수정한 커밋 중에서 머지 커밋이 아닌 것들만 조회한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --pretty=&amp;quot;%h - %s&amp;quot; --author=gitster --since=&amp;quot;2008-10-01&amp;quot; \
   --before=&amp;quot;2008-11-01&amp;quot; --no-merges -- t/
5610e3b - Fix testcase failure when extended attribute
acd3b9e - Enhance hold_lock_file_for_{update,append}()
f563754 - demonstrate breakage of detached checkout wi
d1a43f2 - reset --hard/read-tree --reset -u: remove un
51a94af - Fix &amp;quot;checkout --track -b newbranch&amp;quot; on detac
b0ad11e - pull: allow &amp;quot;git pull origin $something:$cur&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;총 2만여 개의 커밋 히스토리에서 이 명령의 검색 조건에 만족하는 것은 단 6개였다.&lt;/p&gt;

&lt;h3 id='gui____'&gt;GUI 도구를 사용하여 히스토리를 시각화하기&lt;/h3&gt;

&lt;p&gt;GUI 도구로 커밋 히스토리를 시각화하고 싶다면 gitk를 사용할 수 있다. gitk는 Tcl/Tk 프로그램이고 &lt;code&gt;git log&lt;/code&gt; 명령을 시각화해주는 도구다. gitk는 &lt;code&gt;git log&lt;/code&gt; 명령이 지원하는 필터링 옵션을 거의 모두 지원한다. 프로젝트 디렉토리에서 gitk를 실행하면 그림 2-2처럼 보일 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src='/images/progit/18333fig0202-tn.png' alt='' /&gt;&lt;/p&gt;

&lt;p&gt;그림 2-2. gitk의 히스토리&lt;/p&gt;

&lt;p&gt;위쪽 반을 차지하는 윈도우에서는 히스토리를 그래프로 예쁘게 보여준다. 아래쪽 반을 차지하는 윈도우는 diff 결과를 보여주는데 위쪽 윈도우에서 선택한 커밋에 대한 diff 결과를 보여준다.&lt;/p&gt;

&lt;h2 id='undo'&gt;되돌리기(Undo)&lt;/h2&gt;

&lt;p&gt;일을 하다보면 모든 단계에서 어떤 것은 되돌리고 싶을 때가 있다. 이번에는 우리가 한 일을 되돌리는 방법을 살펴볼 것이다. 한 번 되돌리면 복구할 수 없어서 주의해야 한다. Git을 사용하면 우리가 한 실수를 복구하지 못할 것은 거의 없지만 되돌리기는 복구할 수 없다.&lt;/p&gt;

&lt;h3 id='_'&gt;커밋 수정하기&lt;/h3&gt;

&lt;p&gt;종종 완료한 커밋을 수정해야 할 때가 있다. 너무 일찍 커밋했거나 어떤 파일을 빼먹었을 때 그리고 커밋 메시지를 잘못 적었을 때 하게 된다. 다시 커밋하고 싶으면 &lt;code&gt;--amend&lt;/code&gt; 옵션을 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit --amend&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 Staging Area를 사용하여 커밋한다. 만약 마지막으로 커밋하고 나서 수정한 것이 없다면(커밋하자마자 바로 이 명령을 실행하는 경우) 조금 전에 한 커밋과 모든 것이 같을 것이다. 커밋 메시지만 수정할 때 이렇다.&lt;/p&gt;

&lt;p&gt;편집기가 실행되면 이전 커밋 메시지가 이미 포함돼 있다. 메시지를 수정하지 않고 그대로 커밋해도 기존의 커밋을 덮어쓴다.&lt;/p&gt;

&lt;p&gt;예를 들어 커밋을 했는데 Stage하는 것을 깜빡하고 빠트린 파일이 있으면 다음과 같이 고칠 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit -m &amp;#39;initial commit&amp;#39;
$ git add forgotten_file
$ git commit --amend&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 실행한 명령어 3개는 모두 하나의 커밋으로 기록된다. 두 번째 커밋은 첫 번째 커밋을 덮어쓴다.&lt;/p&gt;

&lt;h3 id='__unstage_'&gt;파일 상태를 Unstage로 변경하기&lt;/h3&gt;

&lt;p&gt;다음은 Staging Area와 작업 디렉토리 사이를 넘나드는 방법을 설명한다. 파일의 상태를 변경하는 데 사용하는 명령으로 수정사항을 되돌리려면 상당히 중요한 부분이다. 예를 들어 파일을 두 개 수정했는데 따로따로 커밋하려고 했지만, 실수로 &lt;code&gt;git add *&lt;/code&gt; 라고 실행해 버렸다. 두 파일 모두 Staging Area에 들어 있다. 이제 둘 중 하나를 어떻게 꺼낼까? 우선 &lt;code&gt;git status&lt;/code&gt; 명령으로 확인해보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add .
$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#       modified:   README.txt
#       modified:   benchmarks.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Changes to be commited&lt;/code&gt; 밑에 &lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;...&lt;/code&gt;이라는 문장을 볼 수 있다. 이 명령으로 Unstage 상태로 변경할 수 있다. benchmarks.rb 파일을 Unstage 상태로 변경해보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git reset HEAD benchmarks.rb
benchmarks.rb: locally modified
$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#       modified:   README.txt
#
# Changed but not updated:
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
#   (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)
#
#       modified:   benchmarks.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령이 조금 어색하긴 하지만 일단 동작은 잘 수행되었다. benchmarks.rb 파일은 Unstage 상태가 됐다.&lt;/p&gt;

&lt;h3 id='modified__'&gt;Modified 파일 되돌리기&lt;/h3&gt;

&lt;p&gt;어떻게 해야 benchmarks.rb 파일을 수정하고 나서 다시 되돌릴 수 있을까? 그러니까 최근 커밋된 버전으로(아니면 처음 Clone했을 때처럼 작업 디렉토리에 처음 Checkout 한 그 내용으로) 되돌리는 방법이 무얼까? &lt;code&gt;git status&lt;/code&gt; 명령이 친절하게 알려준다. 바로 위에 있는 예제에서 Unstaged 부분을 보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Changed but not updated:
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
#   (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)
#
#       modified:   benchmarks.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 메시지는 수정한 파일을 되돌리는 방법을 꽤 정확하게 알려준다(적어도 Git 1.6.1이후 버전부터는 그렇다. 만약 예전 것을 아직 사용하고 있으면 업그레드하는 것이 좋다. 편의성이 많이 개선됐다). 알려주는 대로 한 번 해보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -- benchmarks.rb
$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#       modified:   README.txt
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;정상적으로 복원된 것을 알 수 있다. 하지만 명령은 꽤 위험한 명령이라는 것을 알아야 한다. 수정 이전의 파일로 덮어썼기 때문에 수정했던 내용은 전부 사라졌다. 수정한 내용이 진짜 마음에 들지 않을 때에만 사용하자. 정말 이렇게 삭제해야 한다면 Stashing과 Branch를 사용하자. 다음 장에서 다룰 것들이다. 이 방법이 훨씬 낫다.&lt;/p&gt;

&lt;p&gt;Git으로 커밋한 모든 것은 언제나 복구할 수 있다. 삭제한 브랜치에 있었던 것도 &lt;code&gt;--amend&lt;/code&gt; 옵션으로 다시 커밋한 것도 복구할 수 있다(자세한 것은 9장에서 다룬다). 하지만, 커밋하지 않고 잃어버린 것은 절대로 되돌릴 수 없다.&lt;/p&gt;

&lt;h2 id='_'&gt;원격 저장소&lt;/h2&gt;

&lt;p&gt;원격 저장소를 관리할 줄 알아야 다른 사람과 함께 일할 수 있다. 원격 저장소는 인터넷이나 네트워크 어딘가에 있는 저장소를 말한다. 저장소는 여러 개가 있을 수 있는데 어떤 저장소는 읽고 쓰기 모두 할 수 있고 어떤 저장소는 읽기 권한만 있을 수도 있다. 간단히 말해서 다른 사람들과 함께 일한다는 것은 원격 저장소를 관리하고 데이터를 Push하고 Pull하는 것이다.&lt;/p&gt;

&lt;p&gt;그리고 저장소를 추가, 삭제하는 것뿐만 아니라 브랜치들을 관리하고 추적할지 말지 등을 결정하는 일이 저장소를 관리하는 일이다. 이번에는 원격 저장소를 관리하는 방법에 대해 설명한다.&lt;/p&gt;

&lt;h3 id='__'&gt;원격 저장소 확인하기&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;git remote&lt;/code&gt; 명령으로 현재 프로젝트에 등록된 원격 저장소들을 확인할 수 있다. 이 명령은 원격 저장소의 단축 이름들을 보여준다. 저장소를 Clone한 경우는 origin이라는 원격 저장소가 자동으로 등록되기 때문에 origin이라는 이름을 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git://github.com/schacon/ticgit.git
Initialized empty Git repository in /private/tmp/ticgit/.git/
remote: Counting objects: 595, done.
remote: Compressing objects: 100% (269/269), done.
remote: Total 595 (delta 255), reused 589 (delta 253)
Receiving objects: 100% (595/595), 73.31 KiB | 1 KiB/s, done.
Resolving deltas: 100% (255/255), done.
$ cd ticgit
$ git remote
origin&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-v&lt;/code&gt;옵션을 주어 단축이름과 URL을 함께 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote -v
origin	git://github.com/schacon/ticgit.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;원격 저장소가 여러 개 있다면 이 명령은 전부 보여준다. 내 Grit 저장소에서 실행하면 다음과 같이 출력한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd grit
$ git remote -v
bakkdoor  git://github.com/bakkdoor/grit.git
cho45     git://github.com/cho45/grit.git
defunkt   git://github.com/defunkt/grit.git
koke      git://github.com/koke/grit.git
origin    git@github.com:mojombo/grit.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 원격 저장소가 여러 개가 등록되어 있으면 다른 사람이 기여한 내용(Contributions)을 쉽게 가져올 수 있다. 그리고 origin만 SSH URL이기 때문에 나는 origin에만 Push할 수 있다(4장에서 좀 더 자세히 다룰 것이다).&lt;/p&gt;

&lt;h3 id='__'&gt;원격 저장소 추가하기&lt;/h3&gt;

&lt;p&gt;이전 절에서도 원격 저장소를 추가하는 것에 대해 설명했었지만 수박 겉핧기식으로 살펴봤을 뿐이었다. 여기에서는 원격 저장소를 추가하는 방법을 자세하게 설명한다. 쉽게 새 원격 저장소를 추가할 수 있는데 &lt;code&gt;git remote add [단축이름] [url]&lt;/code&gt; 명령을 실행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote
origin
$ git remote add pb git://github.com/paulboone/ticgit.git
$ git remote -v
origin	git://github.com/schacon/ticgit.git
pb	git://github.com/paulboone/ticgit.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 URL 대신에 스트링 pb를 사용할 수 있다. 예를 들어 로컬 저장소에는 없지만 Paul의 저장소에 있는 것을 가져오려면 다음과 같이 실행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch pb
remote: Counting objects: 58, done.
remote: Compressing objects: 100% (41/41), done.
remote: Total 44 (delta 24), reused 1 (delta 0)
Unpacking objects: 100% (44/44), done.
From git://github.com/paulboone/ticgit
 * [new branch]      master     -&amp;gt; pb/master
 * [new branch]      ticgit     -&amp;gt; pb/ticgit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;로컬에서 &lt;code&gt;pb/master&lt;/code&gt;가 Paul의 master 브랜치이다. 이것을 로컬 브랜치중 하나에 머지시킬 수도 있고 체크아웃하여 자세한 브랜치 내용을 확인할 수 있다.&lt;/p&gt;

&lt;h3 id='__pull__fetch_'&gt;원격 저장소를 Pull 하거나 Fetch 하기&lt;/h3&gt;

&lt;p&gt;앞서 설명했듯이 원격 저장소에서 데이터를 가져오려면 간단히 다음과 같이 실행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch [remote-name]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 로컬에는 없지만, 원격 저장소에는 있는 데이터를 모두 가져온다. 그리고 나면 원격 저장소의 모든 브랜치를 로컬에서 접근할 수 있어서 언제든지 머지를 하거나 내용을 살펴볼 수 있다(우리는 3장에서 브랜치를 사용하는 방법에 대해 좀 더 자세히 설명할 것이다).&lt;/p&gt;

&lt;p&gt;저장소를 Clone하면 명령은 자동으로 원격 저장소를 origin이라는 이름으로 추가한다. 그래서 나중에 &lt;code&gt;git fetch origin&lt;/code&gt;을 실행하면 Clone한 이후에(혹은 마지막으로 가져온 이후에) 수정된 것들을 모두 가져온다. &lt;code&gt;fetch&lt;/code&gt; 명령은 원격 저장소의 데이터를 모두 로컬로 가져오지만, 자동으로 머지하지 않는다. 그래서 당신이 로컬에서 하던 작업을 정리하고 나서 수동으로 머지해야 한다.&lt;/p&gt;

&lt;p&gt;그냥 쉽게 &lt;code&gt;git pull&lt;/code&gt; 명령으로 원격 저장소 브랜치에서 데이터를 가져올 뿐만 아니라 자동으로 로컬 브랜치와 머지시킬 수 있다. 먼저 &lt;code&gt;git clone&lt;/code&gt; 명령은 자동으로 로컬의 master 브랜치가 원격 저장소의 master 브랜치를 추적하도록 한다(물론 원격 저장소에 master 브랜치가 있다고 가정에서). 그리고 &lt;code&gt;git pull&lt;/code&gt; 명령은 Clone한 서버에서 데이터를 가져오고 그 데이터를 자동으로 현재 작업하는 코드와 머지시킨다.&lt;/p&gt;

&lt;h3 id='__push'&gt;원격 저장소에 Push하기&lt;/h3&gt;

&lt;p&gt;프로젝트를 공유하고 싶을 때 원격 저장소에 Push할 수 있다. 이 명령은 &lt;code&gt;git push [원격 저장소 이름] [브랜치 이름]&lt;/code&gt;으로 단순하다. master 브랜치를 &lt;code&gt;origin&lt;/code&gt; 서버에 Push하려면(다시 말하지만 Clone하면 보통 자동으로 origin 이름이 생성된다) 다음과 같이 서버에 Push한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 Clone한 원격 저장소에 쓰기 권한이 있고, Clone하고 난 이후 아무도 원격 저장소에 Push하지 않았을 때만 사용할 수 있다. 다시 말해서 Clone한 사람이 여러 명 있을 때, 다른 사람이 Push한 후에 Push하려고 하면 Push할 수 없다. 먼저 다른 사람이 작업한 것을 가져와서 머지한 후에 Push할 수 있다. 3장에서 서버에 Push하는 방법에 대해 자세히 설명할 것이다.&lt;/p&gt;

&lt;h3 id='__'&gt;원격 저장소 살펴보기&lt;/h3&gt;

&lt;p&gt;(역주, 이 절은 최신 버전의 Git이 출력하는 메시지와 조금 다르다.)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git remote show [원격 저장소 이름]&lt;/code&gt; 명령으로 원격 저장소의 구체적인 정보를 확인할 수 있다. &lt;code&gt;origin&lt;/code&gt; 같은 단축이름으로 이 명령을 실행하면 다음과 같은 정보를 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote show origin
* remote origin
  URL: git://github.com/schacon/ticgit.git
  Remote branch merged with &amp;#39;git pull&amp;#39; while on branch master
    master
  Tracked remote branches
    master
    ticgit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;원격 저장소의 URL과 추적하는 브랜치를 출력한다. 이 명령은 &lt;code&gt;git pull&lt;/code&gt; 명령을 실행할 때 master 브랜치와 머지할 브랜치가 무엇인지 보여 준다. &lt;code&gt;git pull&lt;/code&gt; 명령은 원격 저장소 브랜치의 데이터를 모두 가져오고 나서 자동으로 머지할 것이다. 그리고 가져온 모든 원격 저장소 정보도 출력한다.&lt;/p&gt;

&lt;p&gt;좀 더 Git을 열심히 사용하게 되면 &lt;code&gt;git remote show&lt;/code&gt; 명령은 더 많은 정보를 보여줄 것이다. 여러분도 언젠가는 다음과 같은 메시지(역주, 다수의 브랜치를 사용하는 메시지)를 볼 날이 올 것이다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote show origin
* remote origin
  URL: git@github.com:defunkt/github.git
  Remote branch merged with &amp;#39;git pull&amp;#39; while on branch issues
    issues
  Remote branch merged with &amp;#39;git pull&amp;#39; while on branch master
    master
  New remote branches (next fetch will store in remotes/origin)
    caching
  Stale tracking branches (use &amp;#39;git remote prune&amp;#39;)
    libwalker
    walker2
  Tracked remote branches
    acl
    apiv2
    dashboard2
    issues
    master
    postgres
  Local branch pushed with &amp;#39;git push&amp;#39;
    master:master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;브랜치명을 생략하고 &lt;code&gt;git push&lt;/code&gt; 명령을 실행할 때 어떤 브랜치가 어떤 브랜치로 Push되는지 보여준다. 또 아직 로컬로 가져오지 않은 원격 저장소의 브랜치는 어떤 것들이 있는지, 서버에서는 삭제됐지만 아직 가지고 있는 브랜치는 어떤 것인지, &lt;code&gt;git pull&lt;/code&gt; 명령을 실행했을 때 자동으로 머지할 브랜치는 어떤 것이 있는지 보여준다.&lt;/p&gt;

&lt;h3 id='______'&gt;원격 저장소 이름을 바꾸거나 원격 저장소를 삭제하기&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;git remote rename&lt;/code&gt; 명령으로 원격 저장소의 이름을 변경할 수 있다. 예를 들어 &lt;code&gt;pb&lt;/code&gt;를 &lt;code&gt;paul&lt;/code&gt;로 변경하려면 &lt;code&gt;git remote rename&lt;/code&gt; 명령을 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote rename pb paul
$ git remote
origin
paul&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;원격 저장소의 브랜치 이름도 바뀐다. 여태까지 &lt;code&gt;pb/master&lt;/code&gt;로 원격 저장소 브랜치를 사용했으면 이제는 &lt;code&gt;paul/master&lt;/code&gt;라고 사용해야 한다.&lt;/p&gt;

&lt;p&gt;원격 저장소를 삭제해야 한다면 &lt;code&gt;git remote rm&lt;/code&gt; 명령을 사용한다. 서버 정보가 바뀌었을 때, 더는 특별한 미러가 필요하지 않을 때, 기여자가 더는 활동하지 않고 있을 때 필요하다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote rm paul
$ git remote
origin&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='tagtag'&gt;Tag(Tag)&lt;/h2&gt;

&lt;p&gt;다른 VCS처럼 Git도 Tag를 지원한다. 사람들은 보통 릴리즈할 때 사용한다(v1.0, 등등). 이번에는 Tag를 조회하고 생성하는 법과 Tag의 종류를 설명한다.&lt;/p&gt;

&lt;h3 id='tag_'&gt;Tag 조회하기&lt;/h3&gt;

&lt;p&gt;우선 &lt;code&gt;git tag&lt;/code&gt; 명령으로 이미 만들어져 있어 사용할 수 있는 Tag가 있는지 확인할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag
v0.1
v1.3&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 알파벳 순서로 Tag들을 보여준다. 사실 순서는 별로 중요한 게 아니다.&lt;/p&gt;

&lt;p&gt;검색 패턴을 사용하여 Tag를 검색할 수 있다. Git 소스 저장소는 240여 개의 Tag가 있다. 만약 1.4.2 버전의 Tag들만 검색하고 싶으면 다음과 같이 실행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag -l &amp;#39;v1.4.2.*&amp;#39;
v1.4.2.1
v1.4.2.2
v1.4.2.3
v1.4.2.4&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='tag_'&gt;Tag 붙이기&lt;/h3&gt;

&lt;p&gt;Git의 Tag는 Lightweight Tag와 Annotated Tag로 두 종류가 있다. Lightweight Tag는 브랜치와 비슷한데 브랜치처럼 가리키는 지점을 최신 커밋으로 이동시키지 않는다. 단순히 특정 커밋에 대한 포인터일 뿐이다. 한편, Annotated Tag는 Git 데이터베이스에 Tag를 만든 사람의 이름, 이메일과 Tag를 만든 날짜, 그리고 Tag 메시지도 저장한다. 또 GPG(GNU Privacy Guard)로 서명할 수도 있다. 이 모든 정보를 저장해둬야 할 때에만 Annotated Tag를 추천한다. 그냥 다른 정보를 저장하지 않는 단순한 Tag가 필요하다면 Lightweight Tag를 사용하는 것이 좋다.&lt;/p&gt;

&lt;h3 id='annotated_tag'&gt;Annotated Tag&lt;/h3&gt;

&lt;p&gt;Annotated Tag를 만드는 방법은 간단하다. &lt;code&gt;tag&lt;/code&gt; 명령을 실행할 때 &lt;code&gt;-a&lt;/code&gt; 옵션을 추가한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag -a v1.4 -m &amp;#39;my version 1.4&amp;#39;
$ git tag
v0.1
v1.3
v1.4&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-m&lt;/code&gt; 옵션으로 Tag를 저장할 때 메시지를 함께 저장할 수 있다. 명령을 실행할 때 메시지를 입력하지 않으면 Git은 편집기를 실행시킨다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git show&lt;/code&gt; 명령으로 Tag 정보와 커밋 정보를 모두 확인할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git show v1.4
tag v1.4
Tagger: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Mon Feb 9 14:45:11 2009 -0800

my version 1.4
commit 15027957951b64cf874c3557a0f3547bd83b3ff6
Merge: 4a447f7... a6b4c97...
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sun Feb 8 19:02:46 2009 -0800

    Merge branch &amp;#39;experiment&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;커밋 정보를 보여주기 전에 먼저 Tag를 만든 사람이 누구인지, 언제 Tag를 만들었는지, 그리고 Tag 메시지가 무엇인지 보여준다.&lt;/p&gt;

&lt;h3 id='tag_'&gt;Tag에 서명하기&lt;/h3&gt;

&lt;p&gt;GPG 개인키가 있으면 Tag에 서명할 수 있다. 이때에는 &lt;code&gt;-a&lt;/code&gt;옵션 대신 &lt;code&gt;-s&lt;/code&gt;를 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag -s v1.5 -m &amp;#39;my signed 1.5 tag&amp;#39;
You need a passphrase to unlock the secret key for
user: &amp;quot;Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;&amp;quot;
1024-bit DSA key, ID F721C45A, created 2009-02-09&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 Tag에 &lt;code&gt;git show&lt;/code&gt;를 실행하면 GPG 서명도 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git show v1.5
tag v1.5
Tagger: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Mon Feb 9 15:22:20 2009 -0800

my signed 1.5 tag
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.8 (Darwin)

iEYEABECAAYFAkmQurIACgkQON3DxfchxFr5cACeIMN+ZxLKggJQf0QYiQBwgySN
Ki0An2JeAVUCAiJ7Ox6ZEtK+NvZAj82/
=WryJ
-----END PGP SIGNATURE-----
commit 15027957951b64cf874c3557a0f3547bd83b3ff6
Merge: 4a447f7... a6b4c97...
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sun Feb 8 19:02:46 2009 -0800

    Merge branch &amp;#39;experiment&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;잠시 후 서명한 Tag를 검증하는 방법도 설명할 것이다.&lt;/p&gt;

&lt;h3 id='lightweight_tag'&gt;Lightweight Tag&lt;/h3&gt;

&lt;p&gt;Lightweight Tag는 기본적으로 파일에 커밋 체크섬을 저장하는 것뿐이다. 다른 정보는 저장하지 않는다. Lightweight Tag를 만들 때에는 &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, &lt;code&gt;-m&lt;/code&gt; 옵션을 사용하지 않는다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag v1.4-lw
$ git tag
v0.1
v1.3
v1.4
v1.4-lw
v1.5&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 Tag에 &lt;code&gt;git show&lt;/code&gt;를 실행하면 별도의 Tag 정보를 확인할 수 없다. 이 명령은 단순히 커밋 정보만을 보여준다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git show v1.4-lw
commit 15027957951b64cf874c3557a0f3547bd83b3ff6
Merge: 4a447f7... a6b4c97...
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sun Feb 8 19:02:46 2009 -0800

    Merge branch &amp;#39;experiment&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='tag_'&gt;Tag 검증하기&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;git tag -v [Tag 이름]&lt;/code&gt; 명령으로 서명한 Tag를 검증한다. 이 명령은 GPG를 사용하여 서명을 검증한다. 그래서 서명자의 GPG 공개키가 필요하다. 이 공개키가 Keyring에 있어야만 이 명령이 성공적으로 실행된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag -v v1.4.2.1
object 883653babd8ee7ea23e6a5c392bb739348b1eb61
type commit
tag v1.4.2.1
tagger Junio C Hamano &amp;lt;junkio@cox.net&amp;gt; 1158138501 -0700

GIT 1.4.2.1

Minor fixes since 1.4.2, including git-mv and git-http with alternates.
gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
gpg: Good signature from &amp;quot;Junio C Hamano &amp;lt;junkio@cox.net&amp;gt;&amp;quot;
gpg:                 aka &amp;quot;[jpeg image of size 1513]&amp;quot;
Primary key fingerprint: 3565 2A26 2040 E066 C9A7  4A7D C0C6 D9A4 F311 9B9A&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 서명자의 공개키가 없으면 다음과 같은 메시지를 출력한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
gpg: Can&amp;#39;t check signature: public key not found
error: could not verify the tag &amp;#39;v1.4.2.1&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='_tag'&gt;나중에 Tag하기&lt;/h3&gt;

&lt;p&gt;예전 커밋에 대해서도 Tag할 수 있다. 커밋 히스토리는 다음과 같고:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --pretty=oneline
15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &amp;#39;experiment&amp;#39;
a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support
0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &amp;#39;experiment&amp;#39;
0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function
4682c3261057305bdd616e23b64b0857d832627b added a todo file
166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo
8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;프로젝트에 &amp;#8220;updated rakefile&amp;#8221; 커밋을 v1.2로 Tag하지 못했다고 해도 지금 Tag를 붙일 수 있다. 특정 커밋에 Tag하기 위해서 명령의 끝에 커밋 체크섬을 명시한다(긴 체크섬을 전부 사용할 필요는 없다):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag -a v1.2 9fceb02&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 다음과 같이 만든 Tag를 확인한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag
v0.1
v1.2
v1.3
v1.4
v1.4-lw
v1.5

$ git show v1.2
tag v1.2
Tagger: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Mon Feb 9 15:32:16 2009 -0800

version 1.2
commit 9fceb02d0ae598e95dc970b74767f19372d61af8
Author: Magnus Chacon &amp;lt;mchacon@gee-mail.com&amp;gt;
Date:   Sun Apr 27 20:43:35 2008 -0700

    updated rakefile
...&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='tag_'&gt;Tag 공유하기&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;git push&lt;/code&gt; 명령은 자동으로 원격 서버에 Tag를 전송하지 않는다. Tag를 만들었으면 서버에 별도로 Push해야 한다. 브랜치를 공유하는 것과 같은 방법으로 할 수 있다. &lt;code&gt;git push origin [Tag 이름]&lt;/code&gt;을 실행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin v1.5
Counting objects: 50, done.
Compressing objects: 100% (38/38), done.
Writing objects: 100% (44/44), 4.56 KiB, done.
Total 44 (delta 18), reused 8 (delta 1)
To git@github.com:schacon/simplegit.git
* [new tag]         v1.5 -&amp;gt; v1.5&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 한 번에 Tag를 여러 개 Push하고 싶으면 &lt;code&gt;--tags&lt;/code&gt; 옵션을 추가하여 &lt;code&gt;git push&lt;/code&gt;명령을 실행한다. 이 명령으로 원격 서버에 없는 Tag를 모두 전송할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin --tags
Counting objects: 50, done.
Compressing objects: 100% (38/38), done.
Writing objects: 100% (44/44), 4.56 KiB, done.
Total 44 (delta 18), reused 8 (delta 1)
To git@github.com:schacon/simplegit.git
 * [new tag]         v0.1 -&amp;gt; v0.1
 * [new tag]         v1.2 -&amp;gt; v1.2
 * [new tag]         v1.4 -&amp;gt; v1.4
 * [new tag]         v1.4-lw -&amp;gt; v1.4-lw
 * [new tag]         v1.5 -&amp;gt; v1.5&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;누군가 저장소에서 Clone하거나 Pull을 하면 모든 Tag 정보도 함께 전송된다.&lt;/p&gt;

&lt;h2 id='_'&gt;팁과 트릭&lt;/h2&gt;

&lt;p&gt;Git의 기초를 마치기 전에 Git을 좀 더 쉽고 편안하게 쓸 수 있게 만들어 줄 몇 가지 팁과 트릭도 설명한다. 이런 팁 없이 Git을 사용하는 사람들도 많다. 우리는 이 책에서 더는 이런 팁을 거론하지 않을 것이고 당신이 이런 팁을 알고 있다고 가정할 것이다. 그래서 알고 있는 것이 좋다.&lt;/p&gt;

&lt;h3 id='id1049'&gt;자동완성&lt;/h3&gt;

&lt;p&gt;Bash 쉘을 쓰고 있다면 멋진 자동완성(Auto-completion) 기능을 사용할 수 있다. Git의 소스코드를 다운받아 &lt;code&gt;contrib/completion&lt;/code&gt; 디렉토리를 살펴보면 &lt;code&gt;git-completion.bash&lt;/code&gt;라는 파일이 있을 것이다. 그 파일을 홈 디렉토리에 카피하고 &lt;code&gt;.bashrc&lt;/code&gt; 파일에 다음과 같은 내용을 추가하자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source ~/.git-completion.bash&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;또 모든 사용자가 사용할 수 있게 설정할 수 있다. Mac 시스템이라면 이 스크립트를 &lt;code&gt;/opt/local/etc/bash_completion.d&lt;/code&gt; 디렉토리에 복사하고 리눅스라면 &lt;code&gt;/etc/bash_completion.d/&lt;/code&gt;에 복사한다. 이 디렉토리는 Bash가 자동완성을 지원하기 위해 사용하는 디렉토리다.&lt;/p&gt;

&lt;p&gt;윈도우에 msysGit을 설치해서 Git Bash를 사용하는 경우에는 자동완성이 미리 설정되어 있다.&lt;/p&gt;

&lt;p&gt;Git 명령을 입력할 때 &lt;code&gt;&amp;lt;Tab&amp;gt;&lt;/code&gt; 키를 누르면 Git이 제안하는 명령들이 출력된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git co&amp;lt;tab&amp;gt;&amp;lt;tab&amp;gt;
commit config&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 경우 &lt;code&gt;git co&lt;/code&gt;를 입력하고 Tab 키를 두번 누르면 commit과 config를 제안한다. 이 때 &lt;code&gt;m&amp;lt;tab&amp;gt;&lt;/code&gt;을 입력하면 자동으로 &lt;code&gt;git commit&lt;/code&gt;명령을 완성한다.&lt;/p&gt;

&lt;p&gt;옵션에도 이 기능이 되고 더 유용하다. 예를 들어 &lt;code&gt;git log&lt;/code&gt;명령을 실행하는데 옵션이 전혀 기억나지 않는다면 다음과 같이 입력하고 Tap 키를 누르면 다음과 같은 옵션을 제안한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --s&amp;lt;tab&amp;gt;
--shortstat  --since=  --src-prefix=  --stat   --summary&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이건 상당히 멋진 팁이다. 아마 문서를 찾아보는 등의 시간을 절약해 줄 것이다.&lt;/p&gt;

&lt;h3 id='git_alias'&gt;Git Alias&lt;/h3&gt;

&lt;p&gt;명령을 완벽하게 입력하지 않으면 Git은 알아듣지 못한다. Git의 명령을 전부 입력하는 것이 귀찮다면 &lt;code&gt;git config&lt;/code&gt;를 사용하여 각 명령의 Alias을 쉽게 만들 수 있다. 다음은 Alias을 만드는 예이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;git commit&lt;/code&gt; 대신 &lt;code&gt;git ci&lt;/code&gt;만으로도 커밋할 수 있다. Git을 계속 사용한다면 다른 명령어도 자주 사용하게 될 것이다. 자주 사용하는 명령은 Alias을 만들어 편하게 사용한다.&lt;/p&gt;

&lt;p&gt;이미 있는 명령을 편리하고 새로운 명령으로 만들어 사용할 수 있다. 예를 들어 파일을 Unstage 상태로 변경하는 명령을 만들어서 불편함을 덜 수 있다. 다음과 같이 &lt;code&gt;unstage&lt;/code&gt; 라는 Alias을 만든다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global alias.unstage &amp;#39;reset HEAD --&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음 두 명령은 동일하게 동작한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git unstage fileA
$ git reset HEAD fileA&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;한결 간결해졌다. 추가로 &lt;code&gt;last&lt;/code&gt; 명령을 만들어 보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global alias.last &amp;#39;log -1 HEAD&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 최근 커밋을 좀 더 쉽게 확인할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git last
commit 66938dae3329c7aebe598c2246a8e6af90d04646
Author: Josh Goebel &amp;lt;dreamer3@example.com&amp;gt;
Date:   Tue Aug 26 19:48:51 2008 +0800

    test for current head

    Signed-off-by: Scott Chacon &amp;lt;schacon@example.com&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이것으로 쉽게 새로운 명령을 만들 수 있다. 그리고 Git의 명령어뿐만 아니라 외부 명령어도 실행할 수 있다. &lt;code&gt;!&lt;/code&gt;를 제일 앞에 추가하면 외부 명령을 실행한다. 다음은 &lt;code&gt;git visual&lt;/code&gt;이라고 입력하면 &lt;code&gt;gitk&lt;/code&gt;가 실행된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global alias.visual &amp;quot;!gitk&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id1050'&gt;요약&lt;/h2&gt;

&lt;p&gt;이제 우리는 로컬에서 사용할 수 있는 Git 명령에 대한 기본 지식은 갖추었다. 저장소를 만들고 Clone하는 방법, 수정하고 나서 Stage하고 커밋하는 방법, 저장소의 히스토리를 조회하는 방법 등을 살펴보았다. 이어지는 장에서는 Git의 가장 강력한 기능인 브랜치 모델을 살펴볼 것이다.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Pro Git - 1. 소개</title>
   <link href="http://ygpark.github.com/Pro Git/2012/08/29/pro-git-1-introduction"/>
   <updated>2012-08-29T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Pro Git/2012/08/29/pro-git-1-introduction</id>
   <content type="html">&lt;h1 id='id1046'&gt;시작하기&lt;/h1&gt;

&lt;p&gt;이 장에서는 처음 접하는 사람들에게 Git을 설명한다. 먼저 버전 관리 도구에 대한 이해를, 그리고 Git을 설치하는 방법을, 마지막으로 Git 서버를 설정하고 사용하는 방법을 설명한다. 이 장을 다 읽고 나면 Git의 탄생 배경, Git을 사용하는 이유, Git을 설정하고 사용하는 방법을 터득할 것이다.&lt;/p&gt;

&lt;h2 id='_'&gt;버전 관리란?&lt;/h2&gt;

&lt;p&gt;버전 관리는 무엇이고, 우리는 왜 이것을 알아야 할까? 버전 관리는 파일들의 변화를 시간에 따라 기록하는 것이다. 이 책에 있는 모든 예제는 모두 버전 관리 시스템을 사용한다. 실제로 컴퓨터에서 사용하는 거의 모든 파일의 버전을 관리할 수 있다.&lt;/p&gt;

&lt;p&gt;그래픽 디자이너나 웹 디자이너도 이미지나 레이아웃의 모든 버전(변경 이력 혹은 수정 내용)을 관리하기 위해 버전 관리 시스템 (VCS - Version Control System)을 사용하는 것이 현명하다. VCS를 사용하면 각 파일을 이전 상태로 되돌릴 수 있고, 프로젝트를 통째로 이전 상태로 되돌릴 수 있고, 시간에 따라 수정 내용을 비교해 볼 수 있고, 누가 문제를 일으켰는지도 추적할 수 있고, 누가 언제 만들어낸 이슈인지도 알 수 있다. VCS를 사용하면 파일을 잃어버리거나 잘못 고쳤을 때도 쉽게 복구할 수 있다. 이런 모든 장점을 큰 노력 없이 이용할 수 있다.&lt;/p&gt;

&lt;h3 id='___'&gt;로컬 버전 관리 시스템&lt;/h3&gt;

&lt;p&gt;많은 사람은 버전을 관리하기 위해 Directory로 파일을 복사하는 방법을 쓴다(똑똑한 사람이라면 Directory 이름으로 시간을 쓸 거다). 이 방법은 간단하므로 자주 사용한다. 그렇지만, 정말 뭔가가 잘못되기 쉽다. 작업하는 Directory를 지워버리거나, 실수로 파일을 잘못 고칠 수도 있고, 잘못 복사할 수도 있다.&lt;/p&gt;

&lt;p&gt;이런 이유로 프로그래머들은 오래전에 로컬 VCS를 만들었다. 그 VCS는 관리 중인 파일의 변경 정보를 저장하려고 아주 간단한 데이터베이스를 사용했다.&lt;/p&gt;

&lt;p&gt;Insert 18333fig0101.png 그림 1-1. 로컬 버전 관리 다이어그램.&lt;/p&gt;

&lt;p&gt;많이 쓰는 VCS 도구 중에 rcs라고 부르는 것이 있는데 오늘날까지도 아직 많은 회사가 사용하고 있다. Mac OS X 운영체제에서도 개발 도구를 설치하면 RCS가 함께 설치된다. RCS는 기본적으로 Patch Set(파일에서 변경되는 부분)을 관리한다. 이 Patch Set은 특별한 형식의 파일로 저장한다. 그리고 일련의 Patch Set을 적용해서 모든 파일을 특정 시점으로 되돌릴 수 있다.&lt;/p&gt;

&lt;h3 id='____centralized_vcs'&gt;중앙집중식 버전 관리 시스템 (Centralized VCS)&lt;/h3&gt;

&lt;p&gt;프로젝트를 진행하다 보면 다른 개발자와 함께 작업해야 하는 경우가 많다. 이럴 때 생기는 문제를 해결하기 위해 CVCS(Centralized Version Control System)가 개발됐다. CVS, Subversion, Perforce 같은 시스템은 모든 파일을 관리하는 서버가 별도로 있고 많은 클라이언트가 중앙 서버에서 파일을 받아서 사용(Checkout)한다. 수년 동안 이러한 시스템들이 많은 사랑을 받았다.&lt;/p&gt;

&lt;p&gt;Insert 18333fig0102.png 그림 1-2. 중앙집중식 버전 관리 (CVCS) 다이어그램.&lt;/p&gt;

&lt;p&gt;CVCS 환경은 로컬 VCS비해 장점이 많다. 프로젝트에 참여한 사람이면 누가 무엇을 하고 있는지 알 수 있다. 관리자는 누가 무엇을 할 수 있는지 꼼꼼하게 관리할 수 있다. 모든 클라이언트의 로컬 데이터페이스를 관리하는 것보다 CVS 하나를 관리하기가 훨씬 쉽다.&lt;/p&gt;

&lt;p&gt;그러나 CVCS 환경은 몇 가지 치명적인 결점이 있다. 가장 대표적인 것이 중앙 서버에 발생한 문제다. 만약 서버가 한 시간 동안 다운되면 그동안 아무도 다른 사람과 협업할 수 없고 사람들이 하는 일을 백업할 방법도 없다. 그리고 중앙 데이터베이스가 있는 하드디스크에 문제가 생기면 프로젝트의 모든 히스토리를 잃는다. 물론 사람마다 하나씩 가진 Snapshot은 괜찮다. 로컬 VCS 시스템도 이와 비슷한 결점이 있고 이런 문제가 발생하면 모든 것을 잃는다.&lt;/p&gt;

&lt;h3 id='___distributed_vcs'&gt;분산형 버전 관리 시스템(Distributed VCS)&lt;/h3&gt;

&lt;p&gt;분산형 버전 관리 시스템(DVCS)을 설명할 차례다. Git, Mecurial, Bazaar, Dearcs 같은 DVCS에서는 클라이언트가 파일의 마지막 Snapshot을 Checkout 하지 않는다. 그냥 저장소를 전부 복제한다. 서버에 문제가 생기면 이 복제물로 다시 작업을 시작할 수 있다. 클라이언트 중에서 아무거나 골라도 서버를 복원할 수 있다. 모든 Checkout은 모든 데이터를 가진 진정한 백업이다.&lt;/p&gt;

&lt;p&gt;Insert 18333fig0103.png 그림 1-3. 분산형 버전 관리 시스템(DVCS) 다이어그램.&lt;/p&gt;

&lt;p&gt;게다가 대부분의 DVCS 환경에서는 원격 저장소가 존재할 수 있다. 원격 저장소가 많다고 해도 문제없다. 그래서 사람들은 동시에 다양한 그룹과 다양한 방법으로 협업할 수 있다. 계층 모델 같은 중앙집중식 시스템으로는 할 수 없는 몇 가지 워크플로우도 사용할 수 있다.&lt;/p&gt;

&lt;h2 id='__git_'&gt;짧게 보는 Git의 역사&lt;/h2&gt;

&lt;p&gt;인생을 살다 보면 여러 가지 일들이 벌어지듯이 Git의 삶 또한 창조적인 파괴와 모순 속에서 시작되었다. 리눅스 커널은 굉장히 규모가 큰 오픈소스 프로젝트다. 리눅스 커널의 일생에서 대부분 시절은 패치와 단순 파일(Archived file)로만 관리했다. 2002년에 드디어 리눅스 커널은 BitKeeper라고 불리는 상용 DVCS를 사용하기 시작했다.&lt;/p&gt;

&lt;p&gt;2005년에 커뮤니티가 만드는 리눅스 커널과 이익을 추구하는 회사가 개발한 BitKeeper의 관계는 틀어졌다. BitKeeper의 무료 사용이 제고된 것이다. 이 사건은 리눅스 개발 커뮤니티(특히 리눅스 창시자 리누스 토발즈)가 자체 도구를 만드는 계기가 됐다. Git은 BitKeeper를 사용하면서 배운 교훈을 기초로 다음과 같은 목표를 세웠다:&lt;/p&gt;

&lt;p&gt;* 빠른 속도 * 단순한 구조 * 비선형적인 개발(수천 개의 동시 다발적인 브랜치) * 완벽한 분산 * 리눅스 커널 같은 대형 프로젝트에도 유용할 것(속도나 데이터 크기 면에서)&lt;/p&gt;

&lt;p&gt;Git은 2005년 탄생하고 나서 아직도 초기 목표를 그대로 유지하고 있으면서도 사용하기 쉽게 진화하고 성숙했다. Git은 미친 듯이 빨라서 대형 프로젝트에 사용하기도 좋다. Git은 동시다발적인 브랜치에도 끄떡없는 슈퍼 울트라 브랜칭 시스템이다 (3장 참고).&lt;/p&gt;

&lt;h2 id='git_'&gt;Git 기초&lt;/h2&gt;

&lt;p&gt;Git의 핵심은 뭘까? 이 질문은 Git을 이해하는데 굉장히 중요하다. Git이 무엇이고 어떻게 동작하는지 이해한다면 쉽게 Git을 효과적으로 사용할 수 있다. Git을 배우려면 Subversion이나 Perforce 같은 다른 VCS를 사용하던 경험을 지워버려야 한다. Git은 미묘하게 달라서 다른 VCS에서 쓰던 개념으로는 헷갈릴 거다. 사용자 인터페이스는 매우 비슷하지만, 정보를 취급하는 방식이 다르다. 이런 차이점들을 이해하면 Git을 사용하는 것이 어렵지 않다.&lt;/p&gt;

&lt;h3 id='__snapshot'&gt;차이점이 아니라 Snapshot&lt;/h3&gt;

&lt;p&gt;Subversion과 Subversion 비슷한 놈들과 Git의 가장 큰 차이점은 데이터를 다루는 방법에 있다. 큰 틀에서 봤을 때 대부분의 VCS 시스템이 관리하는 정보는 파일들의 목록이다. CVS, Subversion, Perforce, Bazaar 등의 시스템은 파일의 집합으로 정보를 관리한다. 각 파일의 변화를 그림 1-4처럼 시간순으로 관리한다.&lt;/p&gt;

&lt;p&gt;Insert 18333fig0104.png 그림 1-4. 각 파일에 대한 변화(차이점)를 저장하는 시스템들.&lt;/p&gt;

&lt;p&gt;Git은 이런 식으로 데이터를 저장하지도 취급하지도 않는다. 대신 Git의 데이터는 파일 시스템의 Snapshot이라 할 수 있으며 크기가 아주 작다. Git은 Commit 하거나 프로젝트의 상태를 저장할 때마다 파일이 존재하는 그 순간을 중요하게 여긴다. 파일이 달라지지 않았으면 Git은 성능을 위해서 파일을 저장하지 않는다. 단지 이전 상태의 파일에 대한 링크만 저장한다. Git은 그림 1-5처럼 동작한다.&lt;/p&gt;

&lt;p&gt;Insert 18333fig0105.png 그림 1-5. Git은 시간순으로 프로젝트의 Snapshot을 저장한다.&lt;/p&gt;

&lt;p&gt;이것이 Git이 다른 VCS와 구분되는 점이다. Git은 이전 버전을 복사하는 다른 버전 관리 시스템들을 바보로 만들었다. Git은 강력한 도구를 지원하는 작은 파일시스템이다. Git은 단순한 VCS가 아니다. 이제 3장에서 설명할 Git 브랜치를 사용하면 얻게 되는 이득이 무엇인지 설명한다.&lt;/p&gt;

&lt;h3 id='____'&gt;거의 모든 명령을 로컬에서 실행&lt;/h3&gt;

&lt;p&gt;거의 모든 명령이 로컬 파일과 데이터만 사용하기 때문에 네트워크에 있는 다른 컴퓨터는 필요 없다. 대부분의 명령어가 네트워크의 속도에 영향을 받는 CVCS에 익숙하다면 Git이 매우 놀라울 것이다. Git의 이런 특징에서 나오는 미칠듯한 속도는 오직 Git느님만이 구사할 수 있는 초인적인 능력이다. 프로젝트의 모든 히스토리가 로컬 디스크에 있기 때문에 모든 명령을 순식간에 실행된다.&lt;/p&gt;

&lt;p&gt;예를 들어 프로젝트의 히스토리를 조회하려 할 때 Git은 서버가 필요 없다. 그냥 로컬 데이터베이스에서 히스토리를 읽어서 보여 준다. 그래서 눈 깜짝할 사이에 히스토리를 조회할 수 있다. 어떤 파일의 현재 버전과 한 달 전의 상태를 비교해보고 싶을 때도 Git은 그냥 한 달 전의 파일과 지금의 파일을 로컬에서 찾는다. 파일을 비교하기 위해 원격에 있는 서버에 접근하고 나서 예전 버전을 가져올 필요가 없다.&lt;/p&gt;

&lt;p&gt;즉 오프라인 상태에서도 비교할 수 있다. 비행기나 기차 등에서 작업하고 네트워크에 접속하고 있지 않아도 Commit 할 수 있다. 다른 VCS 시스템에서는 불가능한 일이다. Perforce는 서버에 연결할 수 없을 때 할 수 있는 일이 별로 없다. Subversion이나 CVS에서도 마찬가지다. 데이터베이스에 접근할 수 없어서 파일을 편집할 수는 있지만, Commit 할 수 없다. 매우 사소해 보이지만 실제로 이 상황에 부닥쳐보면 느껴지는 차이가 매우 크다.&lt;/p&gt;

&lt;h3 id='git_'&gt;Git의 무결성&lt;/h3&gt;

&lt;p&gt;Git은 모든 데이터를 저장하기 전에 체크섬(Checksum 또는 Hash)을 구하고 그 체크섬으로 데이터를 관리한다. 체크섬 없이 어떠한 파일이나 Directory도 변경할 수 없다. 체크섬은 Git에서 사용하는 가장 기본적인(Atomic) 데이터 단위이자 Git의 기본 철학이다. Git 없이는 체크섬을 다룰 수 없어서 파일의 상태도 알 수 없고 데이터를 잃어버릴 수도 없다.&lt;/p&gt;

&lt;p&gt;Git은 SHA-1 Hash를 사용하여 체크섬을 만든다. 만든 체크섬은 40자 길이의 16진수 문자열이다. 파일의 내용이나 Directory 구조를 이용하여 체크섬을 구한다. SHA-1은 아래처럼 생겼다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;24b9da6552252987aa493b52f8696cd6d3b00373&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git은 모든 것을 Hash로 식별하기 때문에 이런 값은 보일 것이다. 실제로 Git은 파일을 이름으로 저장하지 않고 해당 파일의 Hash로 저장한다.&lt;/p&gt;

&lt;h3 id='git___'&gt;Git은 데이터를 추가할 뿐&lt;/h3&gt;

&lt;p&gt;Git으로 무얼 하든 데이터가 추가된다. 되돌리거나 데이터를 삭제할 방법이 없다. 다른 VCS처럼 Git도 Commit 하지 않으면 변경사항을 잃어버릴 수 있다. 하지만, 일단 Snapshot을 Commit하고 나면 데이터를 잃어버리기 어렵다.&lt;/p&gt;

&lt;p&gt;Git을 사용하면 프로젝트가 심각하게 망가질 걱정 없이 매우 즐겁게 여러 가지 실험을 해 볼 수 있다. Git이 데이터를 어떻게 저장하고 손실을 복구할 수 있는지 좀 더 알아보려면 9장 &amp;#8216;Maintenance and Data Recovery&amp;#8217;를 살펴본다.&lt;/p&gt;

&lt;h3 id='__'&gt;세 가지 상태&lt;/h3&gt;

&lt;p&gt;이 부분은 중요하기에 집중해서 읽어야 한다. Git을 공부하기 위해 반드시 짚고 넘어가야 할 부분이다. Git은 파일을 Commited, Modified, Staged 이렇게 세 가지 상태로 관리한다. Commited란 데이터가 로컬 데이터베이스에 안전하게 저장됐다는 것을 의미한다. Modified는 수정한 파일을 아직 로컬 데이터베이스에 Commit 하지 않은 것을 말한다. Staged란 현재 수정한 파일을 곧 Commit 할 것이라고 표시한 상태를 의미한다.&lt;/p&gt;

&lt;p&gt;이 세 가지 상태는 Git 프로젝트의 세 가지 단계와 연결돼 있다. Git Directory, Working Directory, Staging Area 이 세 가지 단계를 이해하고 넘어가자.&lt;/p&gt;

&lt;p&gt;Insert 18333fig0106.png 그림 1-5. Working Directory, Staging Area, Git Directory&lt;/p&gt;

&lt;p&gt;Git Directory는 Git이 프로젝트의 메타데이터와 객체 데이터베이스를 저장하는 곳을 말한다. Git Directory가 Git의 핵심이다. 다른 컴퓨터에 있는 저장소를 Clone 할 때 Git Directory가 만들어진다.&lt;/p&gt;

&lt;p&gt;Working Directory는 프로젝트의 특정 버전을 Checkout 한 것이다. Git Directory는 지금 작업하는 디스크에 있고 그 Directory에 압축된 데이터베이스에서 파일을 가져와서 Working Directory를 만든다.&lt;/p&gt;

&lt;p&gt;Staging Area는 Git Directory에 있다. 단순한 파일이고 곧 Commit 할 파일에 대한 정보를 저장한다. 인덱스처럼 단순히 Staging Area는 파일을 가리키는 것에 불과하다.&lt;/p&gt;

&lt;p&gt;Git으로 하는 일은 기본적으로 다음과 같다:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Working Directory에서 파일을 수정한다.&lt;/li&gt;

&lt;li&gt;Staging Area에 파일을 Stage 해서 Commit 할 Snapshot을 만든다.&lt;/li&gt;

&lt;li&gt;Staging Area에 있는 파일들을 Commit 해서 Git Directory에 영구적인 Snapshot으로 저장한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;해당 작업이 독립적인 의미가 되면 Commit 한다. 파일을 수정하고 Staging Area에 추가했다면 단지 Staged 상태만 된 것이다. Checkout 한 후에 파일을 수정하고 Staged 상태로 만들지 않았다면 그냥 Modified 상태이다. 2장에서 이 상태들에 대해서 좀 더 배울 것이다. 2장에서는 이 상태들의 활용법과 Staged 단계를 사용하지 않는 방법도 배운다.&lt;/p&gt;

&lt;p&gt;Git directory에 있는 파일들은 Committed 상태이다. 파일을 수정하고 Staging Area에 추가했다면 Staged이다. 그리고 Checkout하고 나서 수정했지만, 아직 Staging Area에 추가하지 않았으면 Modified이다. 2장에서 이 상태에 대해 좀 더 자세히 배운다. 특히 Staging Area를 어떻게 이용하는지 혹은 아예 생략하는 방법도 설명한다.&lt;/p&gt;

&lt;h2 id='git_'&gt;Git 설치&lt;/h2&gt;

&lt;p&gt;Git을 사용해 보려면 우선 설치해야 한다. 다양한 방법으로 Git을 설치할 수 있지만 가장 일반적인 방법은 두 가지가 있다. 하나는 소스코드로 컴파일하여 설치하는 방법이고 다른 하나는 각 운영체제(혹은 Platform)의 패키지를 사용하여 설치하는 방법이다.&lt;/p&gt;

&lt;h3 id='_'&gt;소스코드로 설치하기&lt;/h3&gt;

&lt;p&gt;소스코드로 설치하면 Git의 가장 최신 버전을 설치할 수 있기 때문에 컴파일하여 설치할 시간이 있으면 소스코드로 Git을 설치하는 것이 좋다. Git은 계속 UI를 개선하고 있기 때문에 최신 버전을 사용하면 좋은 기능을 빨리 사용할 수 있다. 리눅스 패키지는 보통 최신 버전이 아니고 예전 버전이다. 그래서 Backport를 사용하거나 소스코드로 설치하는 것도 좋은 대안이다.&lt;/p&gt;

&lt;p&gt;Git을 설치하려면 다음과 같은 라이브러리들이 필요하다. Git은 curl, zlib, openssl, expat, libiconv를 필요로 한다. 예를 들어 Fedora처럼 yum을 가지는 시스템을 사용하고 있거나 apt-get이 있는 데비안류 시스템을 사용하면 다음의 명령어를 실행하여 의존 패키지를 설치할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yum install curl-devel expat-devel gettext-devel \
  openssl-devel zlib-devel

$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \
  libz-dev libssl-dev&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;필요한 라이브러리를 모두 설치하고 다음 단계를 진행한다. Git 웹 사이트에서 최신 Snapshot을 가져온다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://git-scm.com/download&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 컴파일하고 설치한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tar -zxf git-1.7.2.2.tar.gz
$ cd git-1.7.2.2
$ make prefix=/usr/local all
$ sudo make prefix=/usr/local install&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;설치한 다음부터는 Git을 사용하여 Git 소스코드를 갱신할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git://git.kernel.org/pub/scm/git/git.git&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='_'&gt;리눅스에 설치&lt;/h3&gt;

&lt;p&gt;리눅스에서 패키지로 Git을 설치할 때에는 보통 각 배포판에서 사용하는 패키지 관리도구를 사용하여 설치한다. Fedora에서는 다음과 같이 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yum install git-core&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ubuntu같은 데비안류 배포판에서는 apt-get을 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install git-core&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='mac_'&gt;Mac에 설치하기&lt;/h3&gt;

&lt;p&gt;Mac에 Git을 쉽게 설치하는 방법은 두 가지가 있다. GUI 인스톨러를 사용하기가 가장 쉽다. Google Code 페이지에서 내려받는다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://code.google.com/p/git-osx-installer&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Insert 18333fig0107.png 그림 1-7. OS X Git 인스톨러.&lt;/p&gt;

&lt;p&gt;MacPorts(&lt;code&gt;http://www.macports.org&lt;/code&gt;)를 사용하는 방법도 있다. MacPorts가 설치돼 있으면 다음과 같이 Git을 설치한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo port install git-core +svn +doc +bash_completion +gitweb&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 설치는 했다. 만약 Subversion 저장소를 Git과 함께 사용해야 하면 svn도 필요하다.&lt;/p&gt;

&lt;h3 id='_'&gt;윈도우에 설치&lt;/h3&gt;

&lt;p&gt;Git을 윈도우에 설치하기도 쉽다. 그저 구글 코드 페이지에서 msysGit 인스톨러를 내려받고 실행하면 된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://code.google.com/p/msysgit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;설치가 완료되면 CLI 프로그램과 GUI 프로그램을 둘 다 사용할 수 있다. CLI 프로그램에는 SSH 클라이언트가 포함돼 있기 때문에 유용하다.&lt;/p&gt;

&lt;h2 id='git__'&gt;Git 최초 설정&lt;/h2&gt;

&lt;p&gt;Git을 설치하고 나면 Git의 사용 환경을 적절히 설정해 주어야 한다. 한 번만 설정하면 된다. 설정한 내용은 Git을 업그레이드해도 유지된다. 또한, 명령어로 언제든지 다시 바꿀 수 있다.&lt;/p&gt;

&lt;p&gt;Git은 &amp;#8216;git config&amp;#8217;라는 도구로 설정 내용을 확인하고 변경할 수 있다. Git은 이 설정에 따라 동작한다. 이 설정 파일은 세 가지나 된다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/etc/gitconfig&lt;/code&gt; 파일: 시스템의 모든 사용자와 모든 저장소에 적용되는 설정이다. &lt;code&gt;git config --system&lt;/code&gt; 옵션으로 이 파일을 읽고 쓸 수 있다.&lt;/li&gt;

&lt;li&gt;&lt;code&gt;~/.gitconfig&lt;/code&gt; 파일: 특정 사용자에게만 적용되는 설정이다. &lt;code&gt;git config --global&lt;/code&gt; 옵션으로 이 파일을 읽고 쓸 수 있다.&lt;/li&gt;

&lt;li&gt;&lt;code&gt;.git/config&lt;/code&gt;: 이 파일은 Git Directory에 있고 특정 저장소(혹은 현재 작업 중인 프로젝트)에만 적용된다. 각 설정은 역순으로 우선시 된다. 그래서 &lt;code&gt;.git/config&lt;/code&gt;가 &lt;code&gt;/etc/gitconfig&lt;/code&gt;보다 우선한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;윈도우에서 Git은 &lt;code&gt;$HOME&lt;/code&gt; Directory(&lt;code&gt;C:\Documents and Settings\$USER&lt;/code&gt;)에 있는 &lt;code&gt;.gitconfig&lt;/code&gt; 파일을 찾는다. 그리고 msysGit도 /etc/gitconfig를 가지고 있다. 경로는 MSys 루트에 따른 상대 경로다. 인스톨러로 msysGit을 설치할 때 설치 경로를 선택할 수 있다.&lt;/p&gt;

&lt;h3 id='_'&gt;사용자 정보&lt;/h3&gt;

&lt;p&gt;Git을 설치하고 나서 가장 먼저 해야 하는 것은 사용자 이름과 이메일 주소를 설정하는 것이다. Git은 Commit 할 때마다 이 정보를 사용한다. 한 번 Commit 한 후에는 정보를 변경할 수 없다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global user.name &amp;quot;John Doe&amp;quot;
$ git config --global user.email johndoe@example.com&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다시 말하자면 &lt;code&gt;--global&lt;/code&gt; 옵션으로 설정한 것은 딱 한 번만 하면 된다. 해당 시스템에서 해당 사용자가 사용할 때에는 이 정보를 사용한다. 만약 프로젝트마다 다른 이름과 이메일 주소를 사용하고 싶으면 &lt;code&gt;--global&lt;/code&gt; 옵션을 빼고 명령을 실행한다.&lt;/p&gt;

&lt;h3 id='id1047'&gt;편집기&lt;/h3&gt;

&lt;p&gt;사용자 정보를 설정하고 나면 Git에서 사용할 텍스트 편집기를 고른다. 기본적으로 Git은 시스템의 기본 편집기를 사용하고 보통 이것은 Vi나 Vim이다. 하지만, Emacs 같은 다른 텍스트 편집기를 사용하고 싶다면 다음과 같이 실행한다.:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global core.editor emacs&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='diff_'&gt;Diff 도구&lt;/h3&gt;

&lt;p&gt;Merge 충돌을 해결하기 위해 사용하는 Diff 도구를 설정할 수 있다. vimdiff를 사용하고 싶으면 다음과 같이 실행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global merge.tool vimdiff&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 kdiff3, tkdiff, meld, xxdif, emerge, vimdiff, gvimdiff, ecmerge, opendiff를 사용할 수 있다. 물론 다른 도구도 사용할 수 있다. 자세한 내용은 7장에서 다룬다.&lt;/p&gt;

&lt;h3 id='_'&gt;설정 확인&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;git config --list&lt;/code&gt; 명령을 실행하면 모든 설정 내용을 확인할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --list
user.name=Scott Chacon
user.email=schacon@gmail.com
color.status=auto
color.branch=auto
color.interactive=auto
color.diff=auto
...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git은 같은 키를 여러 파일(&lt;code&gt;/etc/gitconfig&lt;/code&gt;와 &lt;code&gt;~/.gitconfig&lt;/code&gt;같은)에서 읽기 때문에 같은 키가 하나 이상 나올 수도 있다. 이 경우에 Git은 나중 값을 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git config {key}&lt;/code&gt; 명령으로 Git이 특정 Key에 대해 어떤 값을 사용하는지 확인할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config user.name
Scott Chacon&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='_'&gt;도움말 보기&lt;/h2&gt;

&lt;p&gt;명령어에 대한 도움말이 필요할 때 도움말을 보는 방법은 세 가지이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git help &amp;lt;verb&amp;gt;
$ git &amp;lt;verb&amp;gt; --help
$ man git-&amp;lt;verb&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예를 들어 다음과 같이 실행하면 config 명령에 대한 도움말을 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git help config&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;도움말은 언제 어디서나 볼 수 있다. 오프라인 상태에서도 가능하다. 도움말과 이 책으로 부족하면 다른 사람의 도움을 받는 것이 필요하다. Freenode IRC 서버(irc.freenode.net)에 있는 &lt;code&gt;#git&lt;/code&gt;이나 &lt;code&gt;#github&lt;/code&gt; 채널로 찾아가라. 이 채널은 보통 수백 명의 사람이 접속해 있다. 이 사람들은 모두 Git에 대해 잘 알고 있다. 기꺼이 도와줄 것이다.&lt;/p&gt;

&lt;h2 id='id1048'&gt;요약&lt;/h2&gt;

&lt;p&gt;우리는 Git이 무엇이고 지금까지 사용해 왔던 다른 CVCS와 어떻게 다른지 배웠다. 시스템에 Git을 설치하고 사용자 정보도 설정했다. 다음 장에서는 Git의 사용법을 배운다.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>gitweb for ubuntu</title>
   <link href="http://ygpark.github.com/2012/08/28/gitweb-for-ubuntu"/>
   <updated>2012-08-28T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/2012/08/28/gitweb-for-ubuntu</id>
   <content type="html">&lt;h3 id='gitweb_'&gt;gitweb 설치&lt;/h3&gt;

&lt;p&gt;이렇게 입력하면 웹으로 gitweb에 접근할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install apache2 git-core gitweb
$
$ cd /var/www/
$ mkdir gitweb
$ cd gitweb
$ ln -s /usr/share/gitweb/* .&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='_'&gt;프로젝트 설정&lt;/h3&gt;

&lt;p&gt;다음으로 gitweb에 프로젝트를 추가하는 방법이다.&lt;/p&gt;

&lt;p&gt;기본적인 사용법은 아래와 같고&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /var/cache/git
$ ln -s /path/to/repo1/.git repo1.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음과 같이 디렉토리를 만들어서 사용자/프로젝트별로 구분할 수도 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /var/cache/git
$ mkdir username
$ cd username
$
$ ln -s /path/to/repo2/.git repo2.git
$ ln -s /path/to/repo3/.git repo3.git&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='id1045'&gt;참조&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://wiki.kldp.org/wiki.php/gitweb'&gt;http://wiki.kldp.org/wiki.php/gitweb&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://kldp.org/node/100726'&gt;http://kldp.org/node/100726&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>Linux Kernel - 새 defconfig 만들기</title>
   <link href="http://ygpark.github.com/Linux Kernel/2012/08/28/creating-new-linux-kernel-defconfig"/>
   <updated>2012-08-28T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Linux Kernel/2012/08/28/creating-new-linux-kernel-defconfig</id>
   <content type="html">&lt;p&gt;초보 리눅스커널 개발자에게 유용한 팁입니다.&lt;/p&gt;

&lt;p&gt;우리는 커널 빌드할 때 &lt;strong&gt;make xxx_defconfig&lt;/strong&gt; 같은 명령을 입력합니다. 이 명령의 의미는 &amp;#8216;미리 만들어 놓은 &lt;strong&gt;.config&lt;/strong&gt; 파일을 사용하라&amp;#8217; 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make xxx_defconfig
$ make&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;내 커널소스도 이렇게 만들고 싶은데 어떻게 해야할까요? 먼저 커널소스의 루트디렉토리에서 지금 쓰고있는 &lt;strong&gt;.config&lt;/strong&gt;를 찾습니다. 그리고 그것을 &lt;strong&gt;arch/arm/configs/&lt;/strong&gt; 디렉토리에 복사합니다. 이게 다에요. 다음엔 그냥 &lt;strong&gt;make xxx_defconfig&lt;/strong&gt; 명령을 사용하기만 하면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cp .config arch/arm/configs/xxx_defconfig
$ make xxx_defconfig&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 마음놓고 옵션들을 바꿀 수 있고 되돌릴 수도 있습니다. make distclean 같은 명령도 내릴 수 있죠. :D&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>gdb 매뉴얼 - core dump 사용하기</title>
   <link href="http://ygpark.github.com/Linux/2012/08/27/gdb-manual"/>
   <updated>2012-08-27T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Linux/2012/08/27/gdb-manual</id>
   <content type="html">&lt;p&gt;core dump란 충돌이 발생했던 순간의 memory를 저장한 파일을 말한다. gdb는 core dump 파일을 불러와서 디버깅을 하는 기능을 제공한다. 하지만 그전에 core dump가 저장될 수 있도록 하는 설정이 필요하다.&lt;/p&gt;

&lt;h2 id='id1043'&gt;준비작업&lt;/h2&gt;

&lt;p&gt;core dump가 저장될 수 있도록 하는 설정은 &lt;code&gt;ulimit&lt;/code&gt; 명령을 사용한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 20
file size               (blocks, -f) unlimited
pending signals                 (-i) 16382
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) unlimited
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ulimit -a&lt;/code&gt;의 출력을 보면, 기본적으로 core file size가 0으로 잡혀있는 것을 확인할 수 있다. 이 상태에서는 core dump 파일이 생성되지 않는다. 따라서 core file size를 설정해 주어야 한다. 여기서는 unlimited로 설정한다.&lt;/p&gt;

&lt;p&gt;설정은 &lt;code&gt;ulimit -c unlimited&lt;/code&gt; 명령으로 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ulimit -c unlimited

$ ulimit -a
core file size          (blocks, -c) unlimited
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 20
file size               (blocks, -f) unlimited
pending signals                 (-i) 16382
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) unlimited
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같이 설정이 되었다면, 프로그램이 죽을 때 현재 디렉토리($PWD)에 core dump 파일이 생긴다.&lt;/p&gt;

&lt;h2 id='id1044'&gt;사용법&lt;/h2&gt;

&lt;p&gt;core dump를 이용한 디버깅 방법은 다음과 같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gdb [프로그램명] [덤프파일명]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gdb는 실행직후 core dump 파일을 로드하여 종료 직전의 메모리 상태를 만든다. 이 때 bt(backtrace)같은 gdb의 명령어셋을 사용하여 디버깅을 시작한다.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Makefile 예제</title>
   <link href="http://ygpark.github.com/Linux/2012/08/24/makefile-example"/>
   <updated>2012-08-24T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Linux/2012/08/24/makefile-example</id>
   <content type="html">&lt;h2 id='1_application'&gt;예제1. Application&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;CXX=g++
CFLAGS=-c -Wall
LDFLAGS=
SOURCES=main.cpp
OBJECTS=$(SOURCES:.cpp=.o)
EXECUTABLE=a.out

all: $(SOURCES) $(EXECUTABLE)

$(EXECUTABLE): $(OBJECTS)
	$(CXX) $(LDFLAGS) $(OBJECTS) -o $@

.cpp.o:
	$(CXX) $(CFLAGS) $&amp;lt; -o $@

clean:
	rm -f $(OBJECTS)&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='2_application__c_cpp_'&gt;예제2. Application - C와 CPP 복합&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;CC=gcc
CXX=g++

CFLAGS=-c -Wall
LDFLAGS=-lpthread

SOURCES=main.cpp VoiceSound2.cpp
OBJECTS=$(SOURCES:.cpp=.o)

SOURCES_C=sound/mixer.c sound/player.c
OBJECTS_C=$(SOURCES_C:.c=.o)

EXECUTABLE=test

all: $(SOURCES) $(EXECUTABLE)

$(EXECUTABLE): $(OBJECTS) $(OBJECTS_C)
	$(CXX) $(LDFLAGS) $(OBJECTS) $(OBJECTS_C) -o $@

.cpp.o:
	$(CXX) $(CFLAGS) $&amp;lt; -o $@
	
.c.o:
	$(CC) $(CFLAGS) $&amp;lt; -o $@

clean:
	rm -f $(OBJECTS) $(OBJECTS_C)&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='3_static_library'&gt;예제3. static library&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;CC=g++
CFLAGS=-c -Wall
SOURCES=GPSReader.cpp
OBJECTS=$(SOURCES:.cpp=.o)
TARGET=libnd100s

all: $(SOURCES) $(TARGET)

$(TARGET): $(OBJECTS)
	ar cr $(TARGET).a $(OBJECTS)

.cpp.o:
	$(CC) $(CFLAGS) $&amp;lt; -o $@

clean:
	rm -f $(OBJECTS) $(TARGET).a&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>Linux: CPU scaling governor</title>
   <link href="http://ygpark.github.com/Linux/2012/08/24/linux-cpu-scaling-governor"/>
   <updated>2012-08-24T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Linux/2012/08/24/linux-cpu-scaling-governor</id>
   <content type="html">&lt;h3 id='cpu_'&gt;CPU 정보&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cat /proc/cpuinfo&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='2__'&gt;2번째 코어 살리기&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;echo 1 &amp;gt; /sys/devices/system/cpu/cpu1/online 
grep &amp;quot;processor&amp;quot; /proc/cpuinfo&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>bash에서 검색하기</title>
   <link href="http://ygpark.github.com/Linux/2012/08/24/bash-find-xargs-grep"/>
   <updated>2012-08-24T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Linux/2012/08/24/bash-find-xargs-grep</id>
   <content type="html">&lt;p&gt;리눅스에서 일반적으로 파일을 찾을 때에는 find명령을, 텍스트를 걸러낼 때에는 grep명령을 사용합니다. 이 두 명령어는 없어서는 안될 중요한 명령입니다. 하지만 이 두 명령을 조합해서 쓴다면 더 막강한 힘을 발휘합니다. 바로 xargs으로 명령어들을 연결해주면 됩니다.&lt;/p&gt;

&lt;h3 id='find_xargs_grep_'&gt;find, xargs, grep의 조합&lt;/h3&gt;

&lt;p&gt;find, xargs, grep명령을 조합하여 사용방법입니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -name &amp;lt;파일명&amp;gt; | xargs grep --color -n &amp;lt;검색어&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이것이 가능한 이유는 find의 결과로 나오는 목록을 xargs가 grep의 마지막 인자로 넣어주기 때문입니다.&lt;/p&gt;

&lt;p&gt;리눅스 커널을 개발하는 경우는 아래와 같은 스크립트로 소스코드를 검색하곤 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh
# grep-kernel.sh

find . -name &amp;quot;*.[chSs]&amp;quot; -o -name &amp;quot;*.cpp&amp;quot; -o -name &amp;quot;Makefile&amp;quot; -o -name &amp;quot;.config&amp;quot; | xargs grep --color -n $1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;혹은 이렇게 Kconfig를 검색하기도 하죠.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh
# grep-kconfig.sh

find . -name Kconfig | xargs grep --color -n $1&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>alsa-lib-1.0.16 cross compile for arm</title>
   <link href="http://ygpark.github.com/Linux/2012/08/24/alsa-lib-1016-cross-compile-for-arm"/>
   <updated>2012-08-24T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Linux/2012/08/24/alsa-lib-1016-cross-compile-for-arm</id>
   <content type="html">&lt;h3 id='id1040'&gt;요약&lt;/h3&gt;

&lt;p&gt;기본적인 크로스컴파일 방법과 configure시 libpython이 없다는 에러가 발생했을 때 대처법입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ CC=arm-linux-gcc ./configure --target=arm-linux --host=i686-linux
$ make&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;libpython이 없다는 에러가 나면 이렇게 하세요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ CC=arm-linux-gcc ./configure --target=arm-linux --host=i686-linux --disable-python
$ make&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='id1041'&gt;경험담&lt;/h3&gt;

&lt;p&gt;alsa-lib를 컴파일할 일이 생겼습니다. 그런데 configure 에서 에러가 발생합니다.&lt;code&gt;cannot find -lpython2.6&lt;/code&gt; 뭐라는걸로 보아서 python 라이브러리가 필요한듯 하네요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ CC=arm-linux-gcc ./configure --target=arm-linux --host=i686-linux
...
...
...
/opt/arm/4.3.1-eabi-armv6/usr/bin-ccache/.........: cannot find -lpython2.6
collect2: ld returned 1 exit status
make[3]: *** [smixer-python.la] 오류 1
make[3]: Leaving directory `/home/ygpark/download/sound/alsa-lib-1.0.16/modules/mixer/simple&amp;#39;
make[2]: *** [all-recursive] 오류 1
make[2]: Leaving directory `/home/ygpark/download/sound/alsa-lib-1.0.16/modules/mixer&amp;#39;
make[1]: *** [all-recursive] 오류 1
make[1]: Leaving directory `/home/ygpark/download/sound/alsa-lib-1.0.16/modules&amp;#39;
make: *** [all-recursive] 오류 1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;어떻게 해야 할까요? configure 실행중 외부 라이브러리 의존성에 관한 에러가 발생할 경우 &lt;code&gt;configure --help&lt;/code&gt; 명령으로 옵션을 찾아보면 해답을 찾을 수 있습니다. 여기서는 &amp;#8217;&amp;#8211;disable-python&amp;#8217;이란 옵션이 있네요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./configure --help | grep python
  --disable-python        disable the python components
  --with-pythonlibs=ldflags
                          specify python libraries (-lpthread -lm -ldl
                          -lpython2.4)
  --with-pythonincludes=Cflags
                          specify python C header files
                          (-I/usr/include/python)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;configure에 &amp;#8217;&amp;#8211;disable-python&amp;#8217;옵션을 적용해서 다시 시도해 봅니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ CC=arm-linux-gcc ./configure --target=arm-linux --host=i686-linux --disable-python
$ make&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;configure가 완료되었고, 컴파일도 성공했군요. 컴파일된 결과물은 &lt;code&gt;./src/.libs/&lt;/code&gt; 에 있습니다.&lt;/p&gt;

&lt;h3 id='id1042'&gt;참고&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://omappedia.org/wiki/ALSA_Setup#ALSA_library'&gt;http://omappedia.org/wiki/ALSA_Setup#ALSA_library&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 
</feed>