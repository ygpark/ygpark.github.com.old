<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>박영기 BLOG</title>
 <link href="http://ygpark.github.com/atom.xml" rel="self"/>
 <link href="http://ygpark.github.com"/>
 <updated>2012-08-30T10:32:41+09:00</updated>
 <id>http://ygpark.github.com</id>
 <author>
   <name>Young-Gi Park</name>
   <email>ghostyak@gmail.com</email>
 </author>

 
 <entry>
   <title>Pro Git - 6. Git 도구</title>
   <link href="http://ygpark.github.com/Pro Git/2012/08/29/pro-git-6-git-tools"/>
   <updated>2012-08-29T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Pro Git/2012/08/29/pro-git-6-git-tools</id>
   <content type="html">&lt;h1 id='git_'&gt;Git 도구&lt;/h1&gt;

&lt;p&gt;지금까지 일상적으로 자주 사용하는 명령어들과 명 가지 Workflow를 배웠다. 파일을 추적하고 커밋하는 등의 기본적인 명령어뿐만 아니라 Staging Area가 왜 좋은지도 배웠고 가볍게 토픽 브랜치를 만들고 Merge하는 방법도 다뤘다. 이제는 Git 저장소를 사용하여 소스코드 관리를 충분히 해낼 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;이 장에서는 일상적으로 사용하지는 않지만 위급한 상황에서 반드시 필요한 Git 도구들을 살펴본다.&lt;/p&gt;

&lt;h2 id='_'&gt;리비전 조회하기&lt;/h2&gt;

&lt;p&gt;리비전 하나를 조회할 수도 있고 범위를 주고 여러 개를 조회할 수도 있다. 거의 필요하진 않지만 알아두면 좋다.&lt;/p&gt;

&lt;h3 id='__'&gt;리비전 하나 가리키기&lt;/h3&gt;

&lt;p&gt;사람은 커밋을 나타내는 SHA-1 해시 값을 쉽게 기억할 수 없다. 이 절에서는 커밋을 표현하는 방법을 몇 가지 설명하며 사람이 알기 쉬운 방법도 포함하고 있다.&lt;/p&gt;

&lt;h3 id='sha1__'&gt;SHA-1 줄여 쓰기&lt;/h3&gt;

&lt;p&gt;Git은 해시 값의 앞 몇 글자만으로도 어떤 커밋인지 충분히 식별할 수 있다. 중복되지 않으면 해시 값의 앞 4자만으로도 나타낼 수 있다. 즉 짧은 SHA-1 값이라고 해도 유일해야 한다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;code&gt;git log&lt;/code&gt; 명령으로 어떤 커밋이 있는지 조회해본다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log
commit 734713bc047d87bf7eac9674765ae793478c50d3
Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit &amp;#39;phedders/rdocs&amp;#39;

commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git show&lt;/code&gt; 명령으로 &lt;code&gt;1c002dd....&lt;/code&gt;로 시작하는 커밋을 조회할 수 있다. 다음 명령어들은 모두 같다(단 짧은 해시 값이 다른 커밋과 중복되지 않다고 가정):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
$ git show 1c002dd4b536e7479f
$ git show 1c002d&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git log&lt;/code&gt; 명령어에 &lt;code&gt;--abbrev-commit&lt;/code&gt;라는 옵션을 추가하면 짧고 중복되지 않는 해시 값을 보여준다. 기본으로 7자를 보여주고 해시 값이 중복되는 경우 더 긴 해시 값을 보여준다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --abbrev-commit --pretty=oneline
ca82a6d changed the version number
085bb3b removed unnecessary test code
a11bef0 first commit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;보통은 8자에서 10자 내외로도 충분히 유일하게 커밋을 나타낼 수 있다. 대규모 프로젝트인 리눅스 커널도 해시 값 40자 중에서 12자만으로 특정 커밋을 가리킬 수 있다.&lt;/p&gt;

&lt;h3 id='sha1____'&gt;SHA-1 해시 값에 대한 단상&lt;/h3&gt;

&lt;p&gt;Git을 쓰는 사람들은 가능성이 작긴 하지만 언젠가 SHA-1 값이 중복될까 봐 걱정한다. 정말 그렇게 되면 어떤 일이 벌어질까?&lt;/p&gt;

&lt;p&gt;이미 있는 SHA-1 값이 Git 데이터베이스에 커밋되면 새로운 개체라고 해도 이미 커밋된 것으로 생각한다. 그래서 해당 SHA-1 값의 커밋을 Checkout하면 항상 처음 저장한 커밋만 Checkout 된다.&lt;/p&gt;

&lt;p&gt;그러나 해시 값이 중복되는 일은 일어나기 어렵다. SHA-1 값의 크기는 20 바이트(160비트)이다. 해시 값이 중복될 확률이 50%가 되는 데 필요한 개체의 수는 &lt;code&gt;2^80&lt;/code&gt;이다. 이 수는 1.2 자(? - &lt;code&gt;10^24&lt;/code&gt;)이다(충돌 확률을 구하는 공식은 &lt;code&gt;p=(n(n-1)/2) * (1/2^160)&lt;/code&gt;이다). 즉, 지구에 존재하는 모래알의 수에 1200을 곱한 수와 맞먹는다.&lt;/p&gt;

&lt;p&gt;아직도 SHA-1 해시 값이 중복될까 봐 걱정하는 사람들을 위해 좀 더 덧붙이겠다. 지구에서 약 6.5억 명의 인구가 개발하고 각자 매초 리눅스 커널 히스토리 전체와(100만 개) 맞먹는 개체를 쏟아 내고 바로 Push한다고 가정하자. 이런 상황에서 해시 값의 충돌 날 확률이 50%가 되기까지는 5년이 걸린다. 그냥 어느 날 동료가 한순간에 모두 늑대에게 물려 죽을 확률이 훨씬 더 높다.&lt;/p&gt;

&lt;h3 id='_'&gt;브랜치로 가리키기&lt;/h3&gt;

&lt;p&gt;브랜치를 사용하는 것이 커밋을 나타내는 가장 쉬운 방법이다. 커밋 개체나 SHA-1 값이 필요한 곳이면 브랜치 이름을 사용할 수 있다. 만약 &lt;code&gt;topic1&lt;/code&gt; 브랜치의 최근 커밋을 보고 싶으면 다음과 같이 실행한다. &lt;code&gt;topic1&lt;/code&gt; 브랜치가 &lt;code&gt;ca82a6d&lt;/code&gt;를 가리키고 있기 때문에 두 명령의 결과는 같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git show ca82a6dff817ec66f44342007202690a93763949
$ git show topic1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;브랜치가 가리키는 개체의 SHA-1 값에 대한 궁금증은 &lt;code&gt;rev-parse&lt;/code&gt;이라는 도구가 시원하게 뚫어준다. 9장에서 이 뚫어뻥에 대해 좀 더 자세히 설명한다. 기본적으로 &lt;code&gt;rev-parse&lt;/code&gt;은 저수준 명령어이기 때문에 평소에는 전혀 필요하지 않지만 그래도 한번 사용해보고 어떤 결과가 나오는지 알아 두자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rev-parse topic1
ca82a6dff817ec66f44342007202690a93763949&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='reflog_'&gt;RefLog로 가리키기&lt;/h3&gt;

&lt;p&gt;Git은 자동으로 브랜치와 HEAD가 지난 몇 달 동안에 가리켰었던 커밋을 모두 기록하는데 이 로그를 Reflog라고 부른다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git reflog&lt;/code&gt;를 실행하면 Reflog를 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git reflog
734713b... HEAD@{0}: commit: fixed refs handling, added gc auto, updated
d921970... HEAD@{1}: merge phedders/rdocs: Merge made by recursive.
1c002dd... HEAD@{2}: commit: added some blame and merge stuff
1c36188... HEAD@{3}: rebase -i (squash): updating HEAD
95df984... HEAD@{4}: commit: # This is a combination of two commits.
1c36188... HEAD@{5}: rebase -i (squash): updating HEAD
7e05da5... HEAD@{6}: rebase -i (pick): updating HEAD&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git은 브랜치가 가리키는 것이 달라질 때마다 그 정보를 임시 영역에 저장한다. 그래서 예전에 가리키던 것이 무엇인지 확인해 볼 수 있다. &lt;code&gt;@{n}&lt;/code&gt; 규칙을 사용하면 다음과 같이 HEAD가 5번 전에 가리켰던 것을 알 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git show HEAD@{5}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;순서뿐 아니라 시간도 사용할 수 있다. 어제 날짜의 &lt;code&gt;master&lt;/code&gt; 브랜치를 보고 싶으면 다음과 같이 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git show master@{yesterday}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 어제 master 브랜치가 가리키고 있던 것이 무엇인지 보여준다. Reflog에 남아있을 때에만 조회할 수 있기 때문에 너무 오래된 커밋은 조회할 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git log -g&lt;/code&gt; 명령을 사용하면 &lt;code&gt;git reflog&lt;/code&gt; 결과를 &lt;code&gt;git log&lt;/code&gt; 명령과 같은 형태로 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log -g master
commit 734713bc047d87bf7eac9674765ae793478c50d3
Reflog: master@{0} (Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;)
Reflog message: commit: fixed refs handling, added gc auto, updated 
Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Reflog: master@{1} (Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;)
Reflog message: merge phedders/rdocs: Merge made by recursive.
Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit &amp;#39;phedders/rdocs&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;reflog의 일은 모두 로컬의 일이기 때문에 내 reflog가 동료의 저장소에는 있을 수 없다. 이제 막 Clone한 저장소는 아무것도 한 것이 없어서 reflog가 하나도 없다. &lt;code&gt;git show HEAD@{2.months.ago}&lt;/code&gt; 같은 명령은 적어도 두 달 전에 Clone한 저장소에서나 사용할 수 있다. 그러니까 이 명령을 5분 전에 Clone한 저장소에 사용하면 아무 결과도 나오지 않는다.&lt;/p&gt;

&lt;h3 id='__'&gt;계통 관계로 가리키기&lt;/h3&gt;

&lt;p&gt;계통 관계로도 커밋을 표현할 수 있다. 이름 끝에 &lt;code&gt;^&lt;/code&gt;를 붙이면 Git은 해당 커밋의 부모를 찾는다. 프로젝트 히스토리가 다음과 같을 때:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --pretty=format:&amp;#39;%h %s&amp;#39; --graph
* 734713b fixed refs handling, added gc auto, updated tests
*   d921970 Merge commit &amp;#39;phedders/rdocs&amp;#39;
|\  
| * 35cfb2b Some rdoc changes
* | 1c002dd added some blame and merge stuff
|/  
* 1c36188 ignore *.gem
* 9b29157 add open3_detach to gemspec file list&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;HEAD^&lt;/code&gt;는 바로 &amp;#8220;HEAD의 부모&amp;#8221;를 의미하므로 바로 이전 커밋을 보여준다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git show HEAD^
commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit &amp;#39;phedders/rdocs&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;^&lt;/code&gt;뒤에 숫자도 사용할 수 있다. 예를 들어 &lt;code&gt;d921970^2&lt;/code&gt;는 &amp;#8220;d921970의 두 번째 부모&amp;#8221;를 의미하기에 두 번째 부모가 있는 Merge 커밋에만 사용할 수 있다. 첫 번째 부모는 Merge할 때 Checkout했던 브랜치를 말하고 두 번째 부모는 Merge한 대상 브랜치를 의미한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git show d921970^
commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff

$ git show d921970^2
commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
Author: Paul Hedderly &amp;lt;paul+git@mjr.org&amp;gt;
Date:   Wed Dec 10 22:22:03 2008 +0000

    Some rdoc changes&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;계통을 표현하는 방법으로 &lt;code&gt;~&lt;/code&gt;라는 것도 있다. &lt;code&gt;HEAD~&lt;/code&gt;와 &lt;code&gt;HEAD^&lt;/code&gt;는 똑같이 첫 번째 부모를 가리킨다. 하지만 그 뒤에 숫자를 사용하면 달라진다. &lt;code&gt;HEAD~2&lt;/code&gt;는 명령을 실행할 시점의 &amp;#8220;첫 번째 부모의 첫 번째 부모&amp;#8221;, 즉 &amp;#8220;조부모&amp;#8221;를 가리킨다. 위의 예제에서 &lt;code&gt;HEAD~3&lt;/code&gt;은 다음과 같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git show HEAD~3
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner &amp;lt;tom@mojombo.com&amp;gt;
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 것은 &lt;code&gt;HEAD^^^&lt;/code&gt;와 같은 표현이다. 다시 말해서 첫 번째 부모의 첫 번째 부모의 첫 번째 부모를 말한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git show HEAD^^^
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner &amp;lt;tom@mojombo.com&amp;gt;
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 두 표현을 같이 사용할 수도 있다. 위의 예제에서 &lt;code&gt;HEAD~3^2&lt;/code&gt;를 사용하면 증조부모의 Merge 커밋의 두 번째 부모를 조회한다.&lt;/p&gt;

&lt;h3 id='__'&gt;범위로 커밋 가리키기&lt;/h3&gt;

&lt;p&gt;커밋을 하나씩 조회할 수도 있지만, 범위를 주고 여러 커밋을 한꺼번에 조회할 수도 있다. 범위를 사용하여 조회할 수 있으면 브랜치를 관리할 때 유용하다. 상당히 많은 브랜치를 가지고 있고 &amp;#8220;왜 이 브랜치들은 아직도 주 브랜치에 Merge도 안 되고 뭥미?&amp;#8221;라는 의문이 들면 범위를 주고 어떤 브랜치인지 쉽게 찾을 수 있다.&lt;/p&gt;

&lt;h4 id='double_dot'&gt;Double Dot&lt;/h4&gt;

&lt;p&gt;범위를 표현하는 문법으로 Double Dot(..)을 많이 쓴다. Double Dot은 어떤 커밋들이 한쪽에는 관련됐고 다른 쪽에는 관련되지 않았는지 Git에게 물어보는 것이다. 예들 들어 그림 6-1과 같은 커밋 히스토리가 있다고 가정하자.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0601-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 6-1. 범위를 설명하는 데 사용할 예제&lt;/p&gt;

&lt;p&gt;experiment 브랜치의 커밋들 중에서 아직 master 브랜치에 Merge하지 않은 것들만 보고 싶으면 &lt;code&gt;master..experiment&lt;/code&gt;라고 사용한다. 이 표현은 &amp;#8220;master에는 있지만, experiment에는 없는 커밋&amp;#8221;을 의미한다. 여기에서는 설명을 쉽게 하려고 실제 조회 결과가 아니라 그림 6-1의 문자를 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log master..experiment
D
C&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;반대로 &lt;code&gt;experiment&lt;/code&gt;에는 없고 &lt;code&gt;master&lt;/code&gt;에만 있는 커밋이 궁금하면 브랜치 순서를 거꾸로 사용한다. &lt;code&gt;experiment..master&lt;/code&gt;는 &lt;code&gt;experiment&lt;/code&gt;에는 없고 &lt;code&gt;master&lt;/code&gt;에만 있는 것을 알려준다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log experiment..master
F
E&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;experiment&lt;/code&gt; 브랜치를 Merge할 때마다 Merge하기 전에 무엇이 변경됐는지 확인해보고 싶을 것이다. 그리고 원격 저장소에 Push할 때에도 마찬가지로 차이점을 확인해보고 싶을 것이다. 이럴 때 굉장히 유용하다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log origin/master..HEAD&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 &lt;code&gt;origin&lt;/code&gt; 저장소의 &lt;code&gt;master&lt;/code&gt; 브랜치에는 없고 현재 Checkout중인 브랜치에만 있는 커밋을 보여준다. Checkout한 브랜치가 &lt;code&gt;origin/master&lt;/code&gt;라면 &lt;code&gt;git log origin/master..HEAD&lt;/code&gt;가 보여주는 커밋이 Push하면 서버에 전송될 커밋들이다. 그리고 한쪽의 참조를 생략하면 Git은 HEAD라고 가정하기 때문에 &lt;code&gt;git log origin/master..&lt;/code&gt;는 &lt;code&gt;git log origin/master..HEAD&lt;/code&gt;과 같다.&lt;/p&gt;

&lt;h4 id='___'&gt;세 개 이상의 참조&lt;/h4&gt;

&lt;p&gt;Double Dot은 간단하고 유용하지만 두 개 이상의 브랜치에는 사용할 수 없다. 그러니까 현재 작업 중인 브랜치에는 있지만 다른 여러 브랜치에는 없는 커밋을 보고 싶으면 &lt;code&gt;..&lt;/code&gt;으로는 확인할 수 없다. &lt;code&gt;^&lt;/code&gt;과 &lt;code&gt;--not&lt;/code&gt; 옵션 뒤에 브랜치 이름을 넣으면 그 브랜치에 없는 커밋을 찾아준다. 다음 명령어 세 가지는 모두 같은 명령이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log refA..refB
$ git log ^refA refB
$ git log refB --not refA&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 옵션들은 Double Dot으로는 할 수 없는, 세 개 이상의 참조에 사용할 수 있는 장점이 있다. 예를 들어 &lt;code&gt;refA&lt;/code&gt;나 &lt;code&gt;refB&lt;/code&gt;에는 있지만 &lt;code&gt;refC&lt;/code&gt;에는 없는 커밋을 보려면 다음 중 하나의 명령어를 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log refA refB ^refC
$ git log refA refB --not refC&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 조건을 잘 응용하면 작업 중인 브랜치와 다른 브랜치을 매우 상세하게 비교해볼 수 있다.&lt;/p&gt;

&lt;h4 id='triple_dot'&gt;Triple Dot&lt;/h4&gt;

&lt;p&gt;Triple Dot은 양쪽에 있는 두 참조 사이에서 공통으로 가지는 것을 제외하고 서로 다른 커밋만 보여준다. 그림 6-1의 커밋 히스토리를 다시 보자. 만약 &lt;code&gt;master&lt;/code&gt;와 &lt;code&gt;experiment&lt;/code&gt;의 공통부분은 빼고 다른 커밋만 보고 싶으면 다음과 같이 하면 된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log master...experiment
F
E
D
C&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;우리가 아는 &lt;code&gt;log&lt;/code&gt; 명령의 결과를 최근 날짜순으로 보여준다. 이 예제에서는 커밋을 네 개 보여준다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;code&gt;log&lt;/code&gt; 명령에 &lt;code&gt;--left-right&lt;/code&gt; 옵션을 추가하면 각 커밋이 어느 브랜치에 속하는지도 보여주기 때문에 좀 더 이해하기 쉽다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --left-right master...experiment
&amp;lt; F
&amp;lt; E
&amp;gt; D
&amp;gt; C&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같은 명령들을 사용하면 원하는 커밋을 좀 더 꼼꼼하게 살펴볼 수 있다.&lt;/p&gt;

&lt;h2 id='_'&gt;대화형 명령어&lt;/h2&gt;

&lt;p&gt;Git은 대화형 스크립트도 제공해서 명령어를 좀 더 쉽게 사용할 수 있다. 여기서 소개하는 몇 가지 대화형 명령어를 이용하면 바로 전문가처럼 능숙하게 커밋할 수 있다. 스크립트를 통해 커밋할 파일을 고르고 수정된 파일의 일부분만 커밋할 수도 있다. 스크립트는 수정하는 파일이 매우 많아서 통째로 커밋하기 어려울 때 이슈별로 나눠서 커밋하기에 좋다. 이슈별로 나눠서 커밋하면 함께 일하는 동료가 검토하기 쉬워진다. &lt;code&gt;git add&lt;/code&gt; 명령에 &lt;code&gt;-i&lt;/code&gt;나 &lt;code&gt;--interactive&lt;/code&gt; 옵션을 주고 실행하면 Git은 다음과 같은 대화형 모드로 들어간다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add -i
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&amp;gt; &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령어는 Staging Area의 현재 상태가 어떻고 할 수 있는 일이 무엇인지 보여준다. 기본적으로 &lt;code&gt;git status&lt;/code&gt; 명령이 보여주는 것과 같지만 좀 더 간결하고 정돈돼 있다. 왼쪽에는 staged 상태인 파일들을 보여주고 오른쪽에는 unstaged인 파일들을 보여준다.&lt;/p&gt;

&lt;p&gt;그리고 마지막 &lt;code&gt;Commands&lt;/code&gt; 부분에서는 할 수 일이 무엇인지 보여준다. 파일들을 stage하고 unstage하는 것, untracked 상태의 파일들을 추가하는 것, stage한 파일을 diff해보는 것들을 할 수 있다. 게다가 수정한 파일의 일부분만 Staging Area에 추가할 수도 있다.&lt;/p&gt;

&lt;h3 id='staging_area____'&gt;Staging Area에 파일 추가하고 추가 취소하기&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;What now&amp;gt;&lt;/code&gt; 프롬프트에서 &lt;code&gt;2&lt;/code&gt;나 &lt;code&gt;u&lt;/code&gt;를(update) 입력하면 Staging Area에 추가할 수 있는 파일을 전부 보여준다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;What now&amp;gt; 2
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Update&amp;gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TODO와 index.html 파일을 stage하려면 다음과 같이 입력한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Update&amp;gt;&amp;gt; 1,2
           staged     unstaged path
* 1:    unchanged        +0/-1 TODO
* 2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Update&amp;gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt; 표시가 붙은 파일은 stage하도록 선택한 것이다. 선택하고 &lt;code&gt;Update&amp;gt;&amp;gt;&lt;/code&gt; 프롬프트에 아무것도 입력하지 않고 엔터를 치면 Git은 선택한 파일을 Staging Area로 추가한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Update&amp;gt;&amp;gt; 
updated 2 paths

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&amp;gt; 1
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 TODO와 index.html 파일은 stage했고 simplegit.rb 파일만 아직 unstaged 상태로 남아 있다. 이제 TODO 파일을 다시 unstage하고 싶으면 &lt;code&gt;3&lt;/code&gt;이나 &lt;code&gt;r&lt;/code&gt;을(revert) 입력한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&amp;gt; 3
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert&amp;gt;&amp;gt; 1
           staged     unstaged path
* 1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert&amp;gt;&amp;gt; [enter]
reverted one path&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다시 status를 선택하면 TODO 파일이 unstaged 상태인 것을 알 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&amp;gt; 1
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;staged 파일들의 변경내용을 보려면 &lt;code&gt;6&lt;/code&gt;이나 &lt;code&gt;d&lt;/code&gt;를(diff) 입력한다. 그러면 먼저 staged 상태인 파일들을 보여준다. 그리고 그중에서 파일 하나를 선택한다. 그 결과는 명령 줄에서 &lt;code&gt;git diff --cached&lt;/code&gt;라고 실행한 결과와 같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&amp;gt; 6
           staged     unstaged path
  1:        +1/-1      nothing index.html
Review diff&amp;gt;&amp;gt; 1
diff --git a/index.html b/index.html
index 4d07108..4335f49 100644
--- a/index.html
+++ b/index.html
@@ -16,7 +16,7 @@ Date Finder

 &amp;lt;p id=&amp;quot;out&amp;quot;&amp;gt;...&amp;lt;/p&amp;gt;

-&amp;lt;div id=&amp;quot;footer&amp;quot;&amp;gt;contact : support@github.com&amp;lt;/div&amp;gt;
+&amp;lt;div id=&amp;quot;footer&amp;quot;&amp;gt;contact : email.support@github.com&amp;lt;/div&amp;gt;

 &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같이 대화형 추가 모드를 사용하면 Staging Area에 파일들을 좀 더 쉽게 추가할 수 있다.&lt;/p&gt;

&lt;h3 id='__staging_area_'&gt;파일의 일부분만 Staging Area에 추가하기&lt;/h3&gt;

&lt;p&gt;파일의 일부분만 Staging Area에 추가하는 것도 가능하다. 예를 들어 simplegit.rb 파일은 고친 부분이 두 군데이다. 그 중 하나를 추가하고 나머지는 그대로 두고 싶다. Git에서는 이런 작업도 매우 쉽게 할 수 있다. 대화형 프롬프트에서 &lt;code&gt;5&lt;/code&gt;, &lt;code&gt;p&lt;/code&gt;를(patch) 입력한다. 그러면 Git은 부분적으로 Staging Area에 추가할 파일이 있는지 묻는다. 파일을 선택하면 파일의 특정 부분을 Staging Area에 추가할 것인지 부분별로 구분하여 묻는다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index dd5ecc4..57399e0 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -22,7 +22,7 @@ class SimpleGit
   end

   def log(treeish = &amp;#39;master&amp;#39;)
-    command(&amp;quot;git log -n 25 #{treeish}&amp;quot;)
+    command(&amp;quot;git log -n 30 #{treeish}&amp;quot;)
   end

   def blame(path)
Stage this hunk [y,n,a,d,/,j,J,g,e,?]? &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기에서 &lt;code&gt;?&lt;/code&gt;를 입력하면 선택할 수 있는 명령어를 설명해준다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?
y - stage this hunk
n - do not stage this hunk
a - stage this and all the remaining hunks in the file
d - do not stage this hunk nor any of the remaining hunks in the file
g - select a hunk to go to
/ - search for a hunk matching the given regex
j - leave this hunk undecided, see next undecided hunk
J - leave this hunk undecided, see next hunk
k - leave this hunk undecided, see previous undecided hunk
K - leave this hunk undecided, see previous hunk
s - split the current hunk into smaller hunks
e - manually edit the current hunk
? - print help&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;y&lt;/code&gt;나 &lt;code&gt;n&lt;/code&gt;을 입력하면 각 부분을 Stage할지 말지 결정할 수 있다. 하지만, 파일을 통째로 stage하거나 필요할 때까지 아예 그대로 남겨 두는 것이 다음부터 더 유용할지도 모른다. 어쨌든 파일의 어떤 부분은 Stage하고 다른 부분은 unstaged 상태로 남겨놓고 status 명령으로 확인해보면 결과는 다음과 같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;What now&amp;gt; 1
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:        +1/-1      nothing index.html
  3:        +1/-1        +4/-0 lib/simplegit.rb&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;simplegit.rb 파일의 상태를 보자. 어떤 줄은 staged 상태이고 어떤 줄은 unstaged라고 알려줄 것이다. 이 파일은 부분적으로 stage하였다. 이제 대화형 모드를 종료하고 일부분만 Stage한 파일을 커밋할 수 있다.&lt;/p&gt;

&lt;p&gt;끝으로 대화형 스크립트로만 파일 일부분을 Stage할 수 있는 것은 아니다. &lt;code&gt;git add -p&lt;/code&gt;나 &lt;code&gt;git add --patch&lt;/code&gt;로도 같은 일을 할 수 있다.&lt;/p&gt;

&lt;h2 id='stashing'&gt;Stashing&lt;/h2&gt;

&lt;p&gt;당신이 어떤 프로젝트에서 한 부분을 담당하고 있다고 하자. 그리고 여기에서 뭔가 작업하던 일이 있고 다른 요청이 들어와서 잠시 브랜치를 변경해야 할 일이 생겼다고 치자. 그런데 이런 상황에서 아직 완료하지 않은 일을 커밋하는 것이 껄끄럽다는 것이 문제다. 커밋하지 않고 나중에 다시 돌아와서 작업을 다시 하고 싶을 것이다. 이 문제는 &lt;code&gt;git stash&lt;/code&gt;라는 명령으로 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;Stash 명령을 사용하면 작업 디렉토리에서 수정한 파일들만 저장한다. Stash는 modified이면서 tracked 상태인 파일과 Staging Area에 있는 파일들을 보관해두는 장소다. 아직 끝내지 않은 수정사항을 스택에 잠시 저장했다가 나중에 다시 적용할 수 있다.&lt;/p&gt;

&lt;h3 id='__stash'&gt;하던 일을 Stash하기&lt;/h3&gt;

&lt;p&gt;예제 프로젝트를 하나 살펴보자. 파일을 두 개 수정하고 그 중 하나는 Staging Area에 추가한다. 그리고 &lt;code&gt;git status&lt;/code&gt; 명령을 실행하면 다음과 같은 결과를 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#      modified:   index.html
#
# Changed but not updated:
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
#
#      modified:   lib/simplegit.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 브랜치를 변경해 보자. 아직 작업 중인 파일은 커밋할 게 아니라서 모두 Stash한다. &lt;code&gt;git stash&lt;/code&gt;를 실행하면 스택에 새로운 Stash가 만들어진다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git stash
Saved working directory and index state \
  &amp;quot;WIP on master: 049d078 added the index file&amp;quot;
HEAD is now at 049d078 added the index file
(To restore them type &amp;quot;git stash apply&amp;quot;)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;대신 작업 디렉토리는 깨끗해졌다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git status
# On branch master
nothing to commit (working directory clean)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 아무 브랜치나 골라서 쉽게 바꿀 수 있다. 수정하던 것을 스택에 저장했다. 다음과 같이 &lt;code&gt;git stash list&lt;/code&gt;를 사용하여 저장한 Stash를 확인한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051... Revert &amp;quot;added file_size&amp;quot;
stash@{2}: WIP on master: 21d80a5... added number to log&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Stash 두 개는 원래 있었던 것이다. 그래서 현재 총 세 개의 Stash를 사용할 수 있다. 이제 &lt;code&gt;git stash apply&lt;/code&gt;를 사용하여 Stash를 적용할 수 있고 이 명령은 &lt;code&gt;git stash&lt;/code&gt; 명령이 출력하는 도움말에 포함돼 있어서 편리하다. 다른 Stash를 고르고 싶으면 Stash 이름을 입력해야 한다. 이름이 없으면 Git은 가장 최근의 Stash를 적용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git stash apply
# On branch master
# Changed but not updated:
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
#
#      modified:   index.html
#      modified:   lib/simplegit.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git은 Stash에 저장할 때 수정했던 파일들을 복원해준다. 복원할 때의 작업 디렉토리는 Stash할 때의 그 브랜치이고 작업 디렉토리도 깨끗한 상태였다. 하지만, 꼭 깨끗한 Working Directory나 Stash할 때와 같은 브랜치에 적용해야 하는 것은 아니다. 어떤 브랜치에서 Stash하고 다른 브랜치로 옮기고서 거기에 Stash를 복원할 수 있다. 그리고 꼭 작업 디렉토리가 깨끗한 상태일 필요도 없다. 작업 디렉토리에 수정하고 커밋하지 않은 파일들이 있을 때에도 Stash를 적용할 수 있다. 만약 충돌이 있으면 알려준다.&lt;/p&gt;

&lt;p&gt;Git은 Stash를 적용할 때 staged 상태였던 파일을 자동으로 다시 staged 상태로 만들어 주지 않는다. 그래서 &lt;code&gt;git stash apply&lt;/code&gt; 명령을 실행할 때 &lt;code&gt;--index&lt;/code&gt; 옵션을 주어 staged 상태까지 적용한다. 그래야 원래 작업하던 상태로 돌아올 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git stash apply --index
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#      modified:   index.html
#
# Changed but not updated:
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
#
#      modified:   lib/simplegit.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;apply&lt;/code&gt; 옵션은 단순히 Stash를 적용하는 것뿐이다. Stash는 여전히 스택에 남아 있다. &lt;code&gt;git stash drop&lt;/code&gt; 명령을 사용하여 해당 Stash를 제거한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051... Revert &amp;quot;added file_size&amp;quot;
stash@{2}: WIP on master: 21d80a5... added number to log
$ git stash drop stash@{0}
Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 &lt;code&gt;git stash pop&lt;/code&gt;이라는 명령도 있는데 이 명령은 Stash를 적용하고 나서 바로 스택에서 제거해준다.&lt;/p&gt;

&lt;h3 id='stash_'&gt;Stash 되돌리기&lt;/h3&gt;

&lt;p&gt;Stash를 적용하고 나서 아차 싶을 때에는 다시 되돌려놓아야 한다. 이런 경우를 위해 Git은 &lt;code&gt;stash unapply&lt;/code&gt; 같은 명령을 제공하지는 않는다. 하지만, Stash를 이용해서 패치를 만들고 그것을 거꾸로 적용할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git stash show -p stash@{0} | git apply -R&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Stash를 명시하지 않으면 Git은 가장 최근의 Stash를 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git stash show -p | git apply -R&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;stash-unapply&lt;/code&gt;라는 alias를 만들어 편리하게 할 수도 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global alias.stash-unapply &amp;#39;!git stash show -p | git apply -R&amp;#39;
$ git stash
$ #... work work work
$ git stash-unapply&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='stash___'&gt;Stash를 적용한 브랜치 만들기&lt;/h3&gt;

&lt;p&gt;보통 Stash에 저장하면 한동안 그대로 유지하고 그 브랜치에서는 계속 새로운 일을 한다. 그러면 이제 저장한 Stash를 적용하는 것이 문제가 된다. 수정한 파일에 Stash를 적용하면 충돌이 일어날 수도 있고 그러면 또 충돌을 해결해야 한다. 필요한 것은 Stash한 것을 쉽게 다시 테스트하는 것이다. &lt;code&gt;git stash branch&lt;/code&gt; 명령을 실행하면 Stash할 당시의 커밋을 Checkout 한 후 새로운 브랜치를 만들고 여기에 적용한다. 이 모든 것이 성공하면 Stash를 삭제한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git stash branch testchanges
Switched to a new branch &amp;quot;testchanges&amp;quot;
# On branch testchanges
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#      modified:   index.html
#
# Changed but not updated:
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
#
#      modified:   lib/simplegit.rb
#
Dropped refs/stash@{0} (f0dfc4d5dc332d1cee34a634182e168c4efc3359)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 브랜치를 새로 만들고 Stash를 복원해주는 매우 편리한 도구다.&lt;/p&gt;

&lt;h2 id='_'&gt;히스토리 단장하기&lt;/h2&gt;

&lt;p&gt;Git으로 일하다 보면 어떤 이유로든 커밋 히스토리를 수정해야 할 때가 있다. 결정을 나중으로 미룰 수 있던 것은 Git의 장점이다. Staging Area로 커밋할 파일을 고르는 일을 커밋하는 순간으로 미룰 수 있고 Stash 명령으로 하던 일을 미룰 수 있다. 게다가 이미 커밋해서 결정한 내용을 수정할 수 있다. 그리고 수정할 수 있는 것도 매우 다양하다. 커밋들의 순서도 변경할 수 있고 커밋 메시지와 커밋한 파일도 변경할 수 있다. 여러 개의 커밋을 하나로 합치거나 반대로 하나의 커밋을 여러 개로 분리할 수도 있다. 아니면 커밋 전체를 삭제할 수도 있다. 하지만, 이 모든 것은 다른 사람과 코드를 공유하기 전에 해야 한다.&lt;/p&gt;

&lt;p&gt;이 절에서는 사람들과 코드를 공유하기 전에 커밋 히스토리를 예쁘게 단장하는 방법에 대해서 설명한다.&lt;/p&gt;

&lt;h3 id='__'&gt;마지막 커밋을 수정하기&lt;/h3&gt;

&lt;p&gt;히스토리를 단장하는 일 중에서는 마지막 커밋을 수정하는 것이 가장 자주 하는 일이다. 기본적으로 두 가지로 나눌 수 있는데 하나는 커밋 메시지를 수정하는 것이고 다른 하나는 파일 목록을 수정하는 것이다.&lt;/p&gt;

&lt;p&gt;커밋 메시지를 수정하는 방법은 매우 간단하다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit --amend&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 자동으로 텍스트 편집기를 실행시켜서 마지막 커밋 메시지를 열어준다. 여기에 메시지를 수정하고 편집기를 닫으면 편집기는 수정한 메시지로 마지막 커밋을 수정한다.&lt;/p&gt;

&lt;p&gt;커밋하고 나서 새로 만들었거나 다시 수정한 파일들을 마지막 커밋에 포함할 수 있다. 기본적으로 방법은 같다. 파일을 수정하고 &lt;code&gt;git add&lt;/code&gt; 명령으로 Staging Area에 넣거나 &lt;code&gt;git rm&lt;/code&gt; 명령으로 추적하는 파일 삭제한다. 그리고 &lt;code&gt;git commit --amend&lt;/code&gt; 명령으로 커밋하면 된다. 이 명령은 현 Staging Area의 내용을 이용해서 수정한다.&lt;/p&gt;

&lt;p&gt;이때 SHA-1 값이 바뀌기 때문에 과거의 커밋을 변경할 때 주의해야 한다. rebase처럼 이미 Push한 커밋은 수정하면 안 된다.&lt;/p&gt;

&lt;h3 id='____'&gt;커밋 메시지를 여러 개 수정하기&lt;/h3&gt;

&lt;p&gt;최근 커밋이 아니라 예전 커밋을 수정하려면 다른 도구가 필요하다. 히스토리 수정하기 위해 만들어진 도구는 없지만 &lt;code&gt;rebase&lt;/code&gt; 명령을 이용하여 수정할 수 있다. 현재 작업하는 브랜치에서 각 커밋을 하나하나 수정하는 것이 아니라 어느 시점부터 HEAD까지의 커밋을 한 번에 Rebase한다. 대화형 Rebase 도구를 사용하면 커밋을 처리할 때마다 잠시 멈춘다. 그러면 각 커밋의 메시지를 수정하거나 파일을 추가하고 변경하는 등의 일을 진행할 수 있다. &lt;code&gt;git rebase&lt;/code&gt; 명령에 &lt;code&gt;-i&lt;/code&gt; 옵션을 추가하면 대화형 모드로 Rebase할 수 있다. 어떤 시점부터 HEAD까지 Rebase할 것인지 인자로 넘기면 된다.&lt;/p&gt;

&lt;p&gt;마지막 커밋 메시지 세 개를 모두 수정하거나 그 중 몇 개를 수정하는 시나리오를 살펴보자. &lt;code&gt;git rebase -i&lt;/code&gt;의 인자로 편집하려는 마지막 커밋의 부모를 &lt;code&gt;HEAD~2^&lt;/code&gt;나 &lt;code&gt;HEAD~3&lt;/code&gt;로 해서 넘긴다. 마지막 세 개의 커밋을 수정하는 것이기 때문에 &lt;code&gt;~3&lt;/code&gt;이 좀 더 기억하기 쉽다. 그렇지만, 실질적으로 가리키게 되는 것은 수정하려는 커밋의 부모인 네 번째 이전 커밋이다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase -i HEAD~3&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 rebase하는 것이기 때문에 메시지의 수정 여부에 관계없이 &lt;code&gt;HEAD~3..HEAD&lt;/code&gt; 범위에 있는 모든 커밋을 수정한다. 다시 강조하지만 이미 중앙서버에 Push한 커밋은 절대 고치지 말아야 한다. Push한 커밋을 Rebase하면 결국 같은 내용을 두 번 Push하는 것이기 때문에 다른 개발자들이 혼란스러워 할 것이다.&lt;/p&gt;

&lt;p&gt;실행하면 수정하려는 커밋 목록이 첨부된 스크립트를 텍스트 편집기로 열어준다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
#  p, pick = use commit
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#
# If you remove a line here THAT COMMIT WILL BE LOST.
# However, if you remove everything, the rebase will be aborted.
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 커밋은 모두 &lt;code&gt;log&lt;/code&gt; 명령과는 정반대의 순서로 나열된다. &lt;code&gt;log&lt;/code&gt; 명령을 실행하면 다음과 같은 결과를 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --pretty=format:&amp;quot;%h %s&amp;quot; HEAD~3..HEAD
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 결과의 역순임을 기억하자. 대화형 rebase는 스크립트에 적혀 있는 순서대로 &lt;code&gt;HEAD~3&lt;/code&gt;부터 적용하기 시작하고 위에서 아래로 각각의 커밋을 순서대로 수정한다. 순서대로 적용하는 것이기 때문에 제일 위에 있는 것이 최신이 아니라 가장 오래된 것이어야 한다.&lt;/p&gt;

&lt;p&gt;특정 커밋에서 실행을 멈추게 하려면 스크립트를 수정해야 한다. &lt;code&gt;pick&lt;/code&gt;이라는 단어를 &lt;code&gt;edit&lt;/code&gt;로 수정하면 그 커밋에서 멈춘다. 가장 오래된 커밋 메시지를 수정하려면 다음과 같이 편집한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;저장하고 편집기를 종료하면 Git은 목록에 있는 커밋 중에서 가장 오래된 커밋으로 이동하고, 다음과 같은 메시지를 보여주고, 명령 프롬프트를 보여준다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase -i HEAD~3
Stopped at 7482e0d... updated the gemspec to hopefully work better
You can amend the commit now, with

       git commit --amend

Once you’re satisfied with your changes, run

       git rebase --continue&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;정확히 뭘 해야 하는지 알려준다. 다음과 같은 명령을 실행하고:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit --amend&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;커밋 메시지를 수정하고 텍스트 편집기를 종료한 후 다음 명령어를 실행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase --continue&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 나머지 두 개의 커밋에 적용하면 끝이다. 다른 것도 &lt;code&gt;pick&lt;/code&gt;을 &lt;code&gt;edit&lt;/code&gt;로 수정해서 이 작업을 몇 번이든 반복할 수 있다. 매번 Git이 멈출 때마다 커밋을 정정할 수 있고 완료할 때까지 계속 할 수 있다.&lt;/p&gt;

&lt;h3 id='__'&gt;커밋 순서 바꾸기&lt;/h3&gt;

&lt;p&gt;대화형 rebase 도구로 커밋 전체를 삭제하거나 순서를 조정할 수 있다. &amp;#8220;added cat-file&amp;#8221; 커밋을 삭제하고 다른 두 커밋의 순서를 변경하려면 이 rebase 스크립트를:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음과 같이 수정한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;수정한 내용을 저장하고 편집기를 종료하면 Git은 브랜치를 이 커밋의 부모로 이동시키고서 &lt;code&gt;310154e&lt;/code&gt;와 &lt;code&gt;f7f3f6d&lt;/code&gt;를 순서대로 적용한다. 그러면 커밋 순서가 변경됐고 &amp;#8220;added cat-file&amp;#8221; 커밋이 제거된 것을 확인할 수 있다.&lt;/p&gt;

&lt;h3 id='_'&gt;커밋 합치기&lt;/h3&gt;

&lt;p&gt;대화형 rebase 명령을 이용하여 여러 개의 커밋을 꾹꾹 눌러서 하나의 커밋으로 만들어 버릴 수 있다. rebase 스크립트에 자동으로 포함된 도움말에 설명돼 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#
# Commands:
#  p, pick = use commit
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#
# If you remove a line here THAT COMMIT WILL BE LOST.
# However, if you remove everything, the rebase will be aborted.
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#8220;pick&amp;#8221;이나 &amp;#8220;edit&amp;#8221;말고 &amp;#8220;squash&amp;#8221;를 입력하면 Git은 해당 커밋과 바로 이전 커밋을 합칠 것이고 커밋 메시지도 Merge한다. 그래서 3개의 커밋을 모두 합치려면 스크립트를 다음과 같이 수정한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;저장하고 나서 편집기를 종료하면 Git은 3개의 커밋 메시지를 Merge할 수 있도록 에디터를 바로 실행해준다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# This is a combination of 3 commits.
# The first commit&amp;#39;s message is:
changed my name a bit

# This is the 2nd commit message:

updated README formatting and added blame

# This is the 3rd commit message:

added cat-file&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 메시지를 저장하면 3개의 커밋이 모두 합쳐진 하나의 커밋만 남는다.&lt;/p&gt;

&lt;h3 id='_'&gt;커밋 분리하기&lt;/h3&gt;

&lt;p&gt;커밋을 분리한다는 것은 기존의 커밋을 해제하고(혹은 되돌려 놓고) Stage를 여러 개로 분리하고 나서 그것을 원하는 횟수만큼 다시 커밋하는 것이다. 예로 들었던 커밋 세 개 중에서 가운데 것을 분리해보자. 이 커밋의 &amp;#8220;updated README formatting and added blame&amp;#8221;을 &amp;#8220;updated README formatting&amp;#8221;과 &amp;#8220;added blame&amp;#8221;으로 분리하는 것이다. &lt;code&gt;rebase -i&lt;/code&gt; 스크립트에서 해당 커밋을 &amp;#8220;edit&amp;#8221;로 변경한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;저장하고 나서 명령 프롬프트로 넘어가면 그 커밋을 해제하고 그 내용을 다시 두 개로 나눠서 커밋하면 된다. 저장하고 편집기를 종료하면 Git은 제일 오래된 커밋의 부모로 이동하고서 &lt;code&gt;f7f3f6d&lt;/code&gt;과 &lt;code&gt;310154e&lt;/code&gt;을 처리하고 콘솔 프롬프트를 보여준다. 여기서 커밋을 해제하는 &lt;code&gt;git reset HEAD^&lt;/code&gt;라는 명령으로 커밋을 해제한다. 그러면 수정했던 파일은 unstaged 상태가 된다. 그다음에 파일들을 stage한 후 커밋하는 일을 원하는 만큼 반복하고 나서 &lt;code&gt;git rebase --continue&lt;/code&gt;라는 명령을 실행하면 남은 rebase작업이 끝난다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git reset HEAD^
$ git add README
$ git commit -m &amp;#39;updated README formatting&amp;#39;
$ git add lib/simplegit.rb
$ git commit -m &amp;#39;added blame&amp;#39;
$ git rebase --continue&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;나머지 &lt;code&gt;a5f4a0d&lt;/code&gt; 커밋도 처리되면 히스토리는 다음과 같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log -4 --pretty=format:&amp;quot;%h %s&amp;quot;
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다시 강조하지만, 목록에 있는 모든 커밋의 SHA-1 값은 변경된다. 그래서 이미 서버에 Push한 커밋을 수정하면 안된다.&lt;/p&gt;

&lt;h3 id='filterbranch_'&gt;filter-branch는 포크레인&lt;/h3&gt;

&lt;p&gt;수정해야 하는 커밋이 너무 많아서 rebase 스크립트로 수정하기 어려울 것 같으면 다른 방법을 사용하는 것이 좋다. 모든 커밋의 이메일 주소를 변경하거나 어떤 파일을 삭제하는 경우를 살펴보자. &lt;code&gt;filter-branch&lt;/code&gt;라는 명령으로 수정할 수 있는데 rebase가 삽이라면 이 명령은 포크레인이라고 할 수 있다. &lt;code&gt;filter-branch&lt;/code&gt;도 역시 수정하려는 커밋이 이미 공개돼서 다른 사람과 함께 공유하는 중이라면 사용하지 말아야 한다. 하지만, 잘 쓰면 꽤 유용하다. &lt;code&gt;filter-branch&lt;/code&gt;가 유용한 경우를 예로 들어 설명하기 때문에 여기에서 대충 어떤 경우에 유용할지 배울 수 있다.&lt;/p&gt;

&lt;h4 id='___'&gt;모든 커밋에서 파일을 제거하기&lt;/h4&gt;

&lt;p&gt;갑자기 누군가 생각 없이 &lt;code&gt;git add.&lt;/code&gt; 같은 명령어를 실행해 버려서 공룡 똥 덩어리가 커밋됐거나 실수로 암호가 포함된 파일을 커밋해서 이런 파일들을 다시 삭제해야 하는 상황을 살펴보자. 이런 상황은 생각보다 자주 발생한다. &lt;code&gt;filter-branch&lt;/code&gt;는 히스토리 전체에서 필요한 것만 골라내는 데 사용하는 도구다. &lt;code&gt;filter-branch&lt;/code&gt;의 &lt;code&gt;--tree-filter&lt;/code&gt;라는 옵션을 사용하면 히스토리에서 passwords.txt라는 파일을 아예 제거할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git filter-branch --tree-filter &amp;#39;rm -f passwords.txt&amp;#39; HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref &amp;#39;refs/heads/master&amp;#39; was rewritten&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--tree-filter&lt;/code&gt; 옵션은 프로젝트를 Checkout한 후에 각 커밋에 명시한 명령어를 실행시키고 그 결과를 다시 커밋한다. 이 경우에는 각 스냅샷에 passwords.txt라는 파일이 있으면 그 파일을 삭제한다. 실수로 편집기의 백업파일을 커밋했으면 &lt;code&gt;git filter-branch --tree-filter &amp;#39;rm -f *~&amp;#39; HEAD&lt;/code&gt;라고 실행해서 삭제할 수 있다.&lt;/p&gt;

&lt;p&gt;이 명령은 모든 파일과 커밋을 정리하고 브랜치 포인터를 다시 복원해준다. 테스팅 브랜치에서 사용할 명령을 점검하고 나서 master 브랜치를 정리한다. 그리고 &lt;code&gt;filter-branch&lt;/code&gt; 명령에 &lt;code&gt;--all&lt;/code&gt; 옵션을 추가하면 모든 브랜치에 적용할 수 있다.&lt;/p&gt;

&lt;h4 id='____'&gt;하위 디렉토리를 루트 디렉토리로 만들기&lt;/h4&gt;

&lt;p&gt;다른 VCS에서 코드를 임포트하면 그 VCS만을 위한 디렉토리가 있을 수 있다. SVN에서 코드를 임포트하면 trunk, tags, branch 디렉토리가 포함된다. 모든 커밋에 대해 &lt;code&gt;trunk&lt;/code&gt; 디렉토리를 프로젝트 루트 디렉토리로 만들 때에도 &lt;code&gt;filter-branch&lt;/code&gt; 명령이 유용하다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref &amp;#39;refs/heads/master&amp;#39; was rewritten&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;trunk&lt;/code&gt; 디렉토리를 루트 디렉토리로 만들었다. Git은 입력한 디렉토리와 관련이 없는 커밋을 자동으로 삭제한다.&lt;/p&gt;

&lt;h4 id='____'&gt;모든 커밋의 이메일 주소를 수정하기&lt;/h4&gt;

&lt;p&gt;프로젝트를 오픈소스로 공개할 때 아마도 회사 이메일 주소로 커밋된 것을 개인 이메일 주소로 변경해야 한다. 아니면 아예 &lt;code&gt;git config&lt;/code&gt;로 이름과 이메일 주소를 설정하는 것을 잊었을 수도 있다. 어쨌든 &lt;code&gt;filter-branch&lt;/code&gt; 명령의 &lt;code&gt;--commit-filter&lt;/code&gt; 옵션을 사용하여 각 커밋에 등록된 이메일 주소를 수정할 수 있다. 이메일 주소를 변경할 때는 조심해야 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git filter-branch --commit-filter &amp;#39;
        if [ &amp;quot;$GIT_AUTHOR_EMAIL&amp;quot; = &amp;quot;schacon@localhost&amp;quot; ];
        then
                GIT_AUTHOR_NAME=&amp;quot;Scott Chacon&amp;quot;;
                GIT_AUTHOR_EMAIL=&amp;quot;schacon@example.com&amp;quot;;
                git commit-tree &amp;quot;$@&amp;quot;;
        else
                git commit-tree &amp;quot;$@&amp;quot;;
        fi&amp;#39; HEAD&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이메일 주소를 새 주소로 변경했다. 모든 커밋은 부모의 SHA-1 값을 가지고 있기 때문에 조건에 만족하는 커밋의 SHA-1값만 바뀌는 것이 아니라 모든 커밋의 SHA-1 값이 바뀐다.&lt;/p&gt;

&lt;h2 id='git__'&gt;Git으로 버그 찾기&lt;/h2&gt;

&lt;p&gt;Git은 굉장히 유연해서 어떤 프로젝트에나 사용할 수 있지만, 심지어 문제를 일으킨 범인이나 버그도 쉽게 찾을 수 있도록 도와준다.&lt;/p&gt;

&lt;h3 id='_'&gt;파일 어노테이션&lt;/h3&gt;

&lt;p&gt;버그를 찾을 때 먼저 그 코드가 왜, 언제 추가했는지 알고 싶을 것이다. 이때는 파일 어노테이션을 활용한다. 한줄한줄 마지막으로 커밋한 사람이 누구인지, 언제 마지막으로 커밋했는지 볼 수 있다. 어떤 메소드에 버그가 있으면 &lt;code&gt;git blame&lt;/code&gt; 명령으로 그 메소드의 각 줄을 누가 언제 마지막으로 고쳤는지 찾아낼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git blame -L 12,22 simplegit.rb 
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 12)  def show(tree = &amp;#39;master&amp;#39;)
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 13)   command(&amp;quot;git show #{tree}&amp;quot;)
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 14)  end
^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 15)
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 16)  def log(tree = &amp;#39;master&amp;#39;)
79eaf55d (Scott Chacon  2008-04-06 10:15:08 -0700 17)   command(&amp;quot;git log #{tree}&amp;quot;)
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 18)  end
9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 19)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 20)  def blame(path)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 21)   command(&amp;quot;git blame #{path}&amp;quot;)
42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 22)  end&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;첫 항목은 그 줄을 마지막에 수정한 커밋의 SHA-1 값이다. 그다음 두 항목은 누가, 언제 그 줄을 커밋했는지 보여준다. 그래서 누가, 언제 커밋했는지 쉽게 찾을 수 있다. 그 뒤에 파일의 줄 번호와 내용을 보여준다. 그리고 &lt;code&gt;^4832fe2&lt;/code&gt; 커밋이 궁금할 텐데 이 표시가 붙어 있으면 그 커밋에서 해당 줄이 처음 커밋됐다는 것을 의미한다. 그러니까 해당 줄들은 &lt;code&gt;4832fe2&lt;/code&gt;에서 커밋된 후 변경된 적이 없다. 지금까지 커밋을 수정하는 것을 배우면서 &lt;code&gt;^&lt;/code&gt;을 적어도 세 곳에서 사용한다고 배웠기 때문에 약간 헷갈릴 수 있으니 혼동하지 말자.&lt;/p&gt;

&lt;p&gt;Git은 파일 이름을 변경한 이력을 별도로 기록해두지 않는다. 하지만, 원래 이 정보들은 각 스냅샷에 저장되고 이 정보를 이용하여 변경 이력을 만들어 낼 수 있다. 그러니까 파일에 생긴 변화는 무엇이든지 알아낼 수 있다. Git은 파일 어노테이션을 분석하여 코드들이 원래 어떤 파일에서 커밋된 것인지 찾아준다. 예를 들어보자. &lt;code&gt;GITServerHandler.m&lt;/code&gt;을 여러 개의 파일로 리팩토링했는데 그 중 한 파일이 &lt;code&gt;GITPackUpload.m&lt;/code&gt;이라는 파일이라고 하자. &lt;code&gt;-C&lt;/code&gt; 옵션으로 &lt;code&gt;GITPackUpload.m&lt;/code&gt; 파일을 추적해보면 각 코드가 원래 어떤 파일로 커밋된 것인지 알 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git blame -C -L 141,153 GITPackUpload.m 
f344f58d GITServerHandler.m (Scott 2009-01-04 141) 
f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) gatherObjectShasFromC
f344f58d GITServerHandler.m (Scott 2009-01-04 143) {
70befddd GITServerHandler.m (Scott 2009-03-22 144)         //NSLog(@&amp;quot;GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 145)
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 146)         NSString *parentSha;
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 147)         GITCommit *commit = [g
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 148)
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 149)         //NSLog(@&amp;quot;GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 150)
56ef2caf GITServerHandler.m (Scott 2009-01-05 151)         if(commit) {
56ef2caf GITServerHandler.m (Scott 2009-01-05 152)                 [refDict setOb
56ef2caf GITServerHandler.m (Scott 2009-01-05 153)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;언제나 코드가 커밋될 당시의 파일이름을 알 수 있기 때문에 코드를 어떻게 리팩토링해도 추적할 수 있다. 그리고 어떤 파일에 적용해봐도 각 줄을 커밋할 당시의 파일이름을 알 수 있다. 버그를 찾을 때 정말 유용하다.&lt;/p&gt;

&lt;h3 id='_'&gt;이진 탐색&lt;/h3&gt;

&lt;p&gt;파일 어노테이션은 특정 이슈와 관련된 커밋을 찾는 데에도 좋다. 문제가 생겼을 때 의심스러운 커밋이 수십, 수백 개에 이르는 경우 도대체 어디서부터 시작해야 할지 모를 수 있다. 이때는 &lt;code&gt;git bisect&lt;/code&gt; 명령이 유용하다. &lt;code&gt;bisect&lt;/code&gt; 명령은 커밋 히스토리를 이진 탐색 방법으로 좁혀 주기 때문에 이슈와 관련된 커밋을 최대한 빠르게 찾아낼 수 있도록 도와준다.&lt;/p&gt;

&lt;p&gt;코드를 운용 환경에 배포하고 난 후에 개발할 때 발견하지 못한 버그가 있다고 보고받았다. 그런데 왜 그런 현상이 발생하는지 아직 이해하지 못하는 상황을 가정해보자. 해당 이슈를 다시 만들고 작업하기 시작했는데 뭐가 잘못됐는지 알아낼 수 없다. 이럴 때 bisect를 사용하여 코드를 뒤져 보는 게 좋다. 먼저 &lt;code&gt;git bisect start&lt;/code&gt; 명령으로 이진 탐색을 시작하고 &lt;code&gt;git bisect bad&lt;/code&gt;를 실행하여 현재 커밋에 문제가 있다고 표시를 남기고 나서 문제가 없는 마지막 커밋을 &lt;code&gt;git bisect good [good_commit]&lt;/code&gt; 명령으로 표시한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git bisect start
$ git bisect bad
$ git bisect good v1.0
Bisecting: 6 revisions left to test after this
[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 예제에서 마지막으로 괜찮았던 커밋(v1.0)과 현재 문제가 있는 커밋 사이에 있는 커밋은 전부 12개이고 Git은 그 중간에 있는 커밋을 Checkout해준다. 여기에서 해당 이슈가 구현됐는지 테스트해보고 만약 이슈가 있으면 그 중간 커밋 이전으로 범위를 좁히고 이슈가 없으면 그 중간 커밋 이후로 범위를 좁힌다. 이슈를 발견하지 못하면 &lt;code&gt;git bisect good&lt;/code&gt;으로 이슈가 아직 없음을 알리고 계속 진행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git bisect good
Bisecting: 3 revisions left to test after this
[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;현재 문제가 있는 커밋과 지금 테스트한 커밋 사이에서 중간에 있는 커밋이 Checkout됐다. 다시 테스트해보고 이슈가 있으면 &lt;code&gt;git bisect bad&lt;/code&gt;로 이슈가 있다고 알린다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git bisect bad
Bisecting: 1 revisions left to test after this
[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] drop exceptions table&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 이슈를 처음 구현한 커밋을 찾았다. 이 SHA-1 값을 포함한 이 커밋의 정보를 확인하고 수정된 파일이 무엇인지 확인할 수 있다. 이 문제가 발생한 시점에 도대체 무슨 일이 있었는지 다음과 같이 살펴본다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git bisect good
b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit
commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04
Author: PJ Hyett &amp;lt;pjhyett@example.com&amp;gt;
Date:   Tue Jan 27 14:48:32 2009 -0800

    secure this thing

:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730
f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 찾았으니까 &lt;code&gt;git bisect reset&lt;/code&gt; 명령을 실행시켜서 이진 탐색을 시작하기 전으로 HEAD를 돌려놓는다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git bisect reset&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;수백 개의 커밋들 중에서 버그가 만들어진 커밋을 찾는 데 몇 분밖에 걸리지 않는다. 실제 업무에서 사용할 때에는 자동화 스크립트가 필요하다. 자동화 스크립트는 이슈를 못 찾으면 0을 반환하고(&lt;code&gt;exit 0&lt;/code&gt;) 찾으면 0이 아닌 값을 반환하는 스크립트이다. 먼저 &lt;code&gt;bisect start&lt;/code&gt;명령으로 bisect를 사용할 범위를 알려준다. 위에서 한 것처럼 문제가 있다고 아는 커밋과 문제가 없다고 아는 커밋을 넘기면 된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git bisect start HEAD v1.0
$ git bisect run test-error.sh&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;문제가 생긴 첫 커밋을 찾을 때까지 Checkout할 때마다 &lt;code&gt;test-error.sh&lt;/code&gt;를 실행한다. &lt;code&gt;make&lt;/code&gt;가 됐든지 &lt;code&gt;make tests&lt;/code&gt;가 됐든지 어쨌든 이슈를 찾는 테스트를 실행하여 찾는다.&lt;/p&gt;

&lt;h2 id='id60'&gt;서브모듈&lt;/h2&gt;

&lt;p&gt;프로젝트를 수행하다 보면 다른 프로젝트를 사용해야 하는 경우가 종종 있다. 보통 사용할 프로젝트들은 독립적으로 개발된 라이브러리들이다. 다시 말해서 별도의 프로젝트로 관리하면서 하나의 프로젝트처럼 취급할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;Atom 피드를 제공하는 웹사이트를 만든다고 가장하자. Atom 피드를 생성하는 코드는 직접 작성하지 않고 라이브러리를 가져다 쓰기로 했다. 그러면 CPAN이나 Ruby gem 같은 라이브러리 관리 도구를 사용하거나 해당 소스코드를 프로젝트로 복사해야 한다. 사실 라이브러리를 조금 수정하는 것, 설치하기 모두 어렵지만, 사용자들은 모두 이용할 수 있어야 한다. 그래서 프로젝트에 코드를 포함하고 코드를 수정하면 원래 라이브러리 프로젝트의 코드와 Merge하기 어렵게 된다.&lt;/p&gt;

&lt;p&gt;Git의 서브모듈은 이런 문제를 해결해준다. 서브모듈은 Git 저장소 안에 다른 Git 저장소를 둘 수 있게 해준다. 이렇게 해도 두 Git 저장소 모두 여전히 독립적으로 관리할 수 있다.&lt;/p&gt;

&lt;h3 id='_'&gt;서브모듈 시작하기&lt;/h3&gt;

&lt;p&gt;Ruby 웹서버 게이트웨이 인터페이스인 Rack 라이브러리를 한 번 프로젝트에 추가해보자. 추가하고 나서도 앞으로 여전히 해당 저장소에서 관리할 수 있기 때문에 마음 놓고 코드를 수정할 수 있다. 먼저 &lt;code&gt;git submodule add&lt;/code&gt; 명령으로 프로젝트를 서브모듈로 추가한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git submodule add git://github.com/chneukirchen/rack.git rack
Initialized empty Git repository in /opt/subtest/rack/.git/
remote: Counting objects: 3181, done.
remote: Compressing objects: 100% (1534/1534), done.
remote: Total 3181 (delta 1951), reused 2623 (delta 1603)
Receiving objects: 100% (3181/3181), 675.42 KiB | 422 KiB/s, done.
Resolving deltas: 100% (1951/1951), done.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 프로젝트 디렉토리를 보면 &lt;code&gt;rack&lt;/code&gt;이라는 디렉토리가 생겼을 것이다. 그 디렉토리가 Rack 프로젝트이다. &lt;code&gt;rack&lt;/code&gt; 디렉토리 안에서 수정하고 Push할 권한이 있는 저장소를 하나 추가하고 나서 그 저장소에 Push한다. 물론 원래 프로젝트 저장소에서도 Fetch하고 Merge할 수 있다. 서브모듈을 추가한 직후 바로 &lt;code&gt;git status&lt;/code&gt;라는 명령을 실행하면 다음과 같이 두 파일이 생긴 것을 알 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#      new file:   .gitmodules
#      new file:   rack
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.gitmodules&lt;/code&gt; 파일을 살펴보자. 이 것은 로컬 디렉토리와 프로젝트 URL의 매핑 정보가 저장된 설정파일이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat .gitmodules 
[submodule &amp;quot;rack&amp;quot;]
      path = rack
      url = git://github.com/chneukirchen/rack.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;서브모듈 개수만큼 이 항목이 있어야 한다. 이 파일도 &lt;code&gt;.gitignore&lt;/code&gt; 파일처럼 버전이 관리된다. 다른 파일들처럼 Push하고 풀할 수 있다. 이 프로젝트를 Clone하는 사람들은 &lt;code&gt;.gitmodules&lt;/code&gt; 파일을 참고하여 서브모듈 프로젝트가 어떤 것인지 판단한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.gitmodules&lt;/code&gt;은 살펴봤고 이제 &lt;code&gt;rack&lt;/code&gt; 항목에 대해 살펴보자. &lt;code&gt;git diff&lt;/code&gt; 명령을 실행시키면 흥미로운 점을 발견할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff --cached rack
diff --git a/rack b/rack
new file mode 160000
index 0000000..08d709f
--- /dev/null
+++ b/rack
@@ -0,0 +1 @@
+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git은 &lt;code&gt;rack&lt;/code&gt; 디렉토리를 서브모듈로 취급하기 때문에 파일들을 직접 추적하지 않고 커밋 하나만 저장한다. &lt;code&gt;rack&lt;/code&gt; 디렉토리에서 수정을 하고 커밋하면 다른 사람이 같은 환경을 만들 수 있도록 HEAD가 가리키는 커밋이 슈퍼프로젝트에 저장된다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;master&lt;/code&gt;처럼 브랜치 이름 같은 참조가 저장되는 것이 아니라 커밋의 SHA-1 값이 저장된다.&lt;/p&gt;

&lt;p&gt;슈퍼프로젝트도 커밋해야 된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit -m &amp;#39;first commit with submodule rack&amp;#39;
[master 0550271] first commit with submodule rack
 2 files changed, 4 insertions(+), 0 deletions(-)
 create mode 100644 .gitmodules
 create mode 160000 rack&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rack 디렉토리의 모드는 160000이다. 160000 모드는 일반적인 파일이나 디렉토리가 아니라 특별하다는 의미다.&lt;/p&gt;

&lt;p&gt;하위 프로젝트의 마지막 커밋이 바뀔 때마다 자동으로 슈퍼프로젝트도 바뀐다. &lt;code&gt;rack&lt;/code&gt; 디렉토리를 별도의 프로젝트로 취급하기 때문에 모든 Git 명령은 독립적으로 동작한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log -1
commit 0550271328a0038865aad6331e620cd7238601bb
Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
Date:   Thu Apr 9 09:03:56 2009 -0700

    first commit with submodule rack
$ cd rack/
$ git log -1
commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433
Author: Christian Neukirchen &amp;lt;chneukirchen@gmail.com&amp;gt;
Date:   Wed Mar 25 14:49:04 2009 +0100

    Document version change&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='___clone'&gt;서브모듈이 있는 프로젝트 Clone하기&lt;/h3&gt;

&lt;p&gt;서브모듈을 사용하는 프로젝트를 Clone하면 해당 서브모듈 디렉토리는 빈 디렉터리다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git://github.com/schacon/myproject.git
Initialized empty Git repository in /opt/myproject/.git/
remote: Counting objects: 6, done.
remote: Compressing objects: 100% (4/4), done.
remote: Total 6 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (6/6), done.
$ cd myproject
$ ls -l
total 8
-rw-r--r--  1 schacon  admin   3 Apr  9 09:11 README
drwxr-xr-x  2 schacon  admin  68 Apr  9 09:11 rack
$ ls rack/
$&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;분명히 &lt;code&gt;rack&lt;/code&gt; 디렉토리는 있지만 비워져 있다. 먼저 &lt;code&gt;git submodule init&lt;/code&gt; 명령으로 서브모듈을 초기화하고 &lt;code&gt;git submodule update&lt;/code&gt; 명령으로 서버에서 데이터를 가져와야 한다. 데이터를 전부 가져오면 슈퍼프로젝트에 저장된 커밋으로 Checkout된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git submodule init
Submodule &amp;#39;rack&amp;#39; (git://github.com/chneukirchen/rack.git) registered for path &amp;#39;rack&amp;#39;
$ git submodule update
Initialized empty Git repository in /opt/myproject/rack/.git/
remote: Counting objects: 3181, done.
remote: Compressing objects: 100% (1534/1534), done.
remote: Total 3181 (delta 1951), reused 2623 (delta 1603)
Receiving objects: 100% (3181/3181), 675.42 KiB | 173 KiB/s, done.
Resolving deltas: 100% (1951/1951), done.
Submodule path &amp;#39;rack&amp;#39;: checked out &amp;#39;08d709f78b8c5b0fbeb7821e37fa53e69afcf433&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;rack&lt;/code&gt; 디렉토리는 이제 복원했다. 그리고 누군가 rack을 수정하면 그 코드를 가져다 Merge해야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git merge origin/master
Updating 0550271..85a3eee
Fast forward
 rack |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)
[master*]$ git status
# On branch master
# Changed but not updated:
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
#   (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)
#
#      modified:   rack
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Merge해서 서브모듈의 HEAD 값이 변경됐다. 슈퍼프로젝트가 아는 커밋과 서브모듈의 HEAD가 달라서 아직 작업 디렉토리의 상태는 깨끗하지 못하다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff
diff --git a/rack b/rack
index 6c5e70b..08d709f 160000
--- a/rack
+++ b/rack
@@ -1 +1 @@
-Subproject commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이럴 때 &lt;code&gt;git submodule update&lt;/code&gt; 명령을 실행해서 해결할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git submodule update
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 1), reused 2 (delta 0)
Unpacking objects: 100% (3/3), done.
From git@github.com:schacon/rack
   08d709f..6c5e70b  master     -&amp;gt; origin/master
Submodule path &amp;#39;rack&amp;#39;: checked out &amp;#39;6c5e70b984a60b3cecd395edd5b48a7575bf58e0&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;서브모듈 프로젝트를 풀할 때마다 &lt;code&gt;git submodule update&lt;/code&gt; 명령을 실행해야 한다. 뭔가 속는 것 같지만 잘 된다.&lt;/p&gt;

&lt;p&gt;개발자들이 흔히 저지르는 실수로 서브모듈의 코드를 수정하고 나서 서버에 Push하지 않는 경우가 있다. 슈퍼프로젝트는 Push했지만 프로젝트가 아는 커밋은 아직 Push하지 않아서 개발자 PC에만 있다. 만약 다른 개발자가 &lt;code&gt;git submodule update&lt;/code&gt;를 실행하면 슈퍼프로젝트에 저장된 커밋을 서브모듈 프로젝트에서 찾을 수 없어서 에러가 발생한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git submodule update
fatal: reference isn’t a tree: 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Unable to checkout &amp;#39;6c5e70b984a60b3cecd395edd5ba7575bf58e0&amp;#39; in submodule path &amp;#39;rack&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;누가 마지막으로 서브모듈을 수정했는지 확인하고:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log -1 rack
commit 85a3eee996800fcfa91e2119372dd4172bf76678
Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
Date:   Thu Apr 9 09:19:14 2009 -0700

    added a submodule reference I will never make public. hahahahaha!&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그 개발자에게 이메일을 보내거나 전화를 건다.&lt;/p&gt;

&lt;h3 id='id61'&gt;슈퍼프로젝트&lt;/h3&gt;

&lt;p&gt;프로젝트 규모가 크면 CVS나 Subversion에서는 모듈 프로젝트을 간단히 하위 디렉토리로 만들었다. 가끔 Git에서도 이런 Workflow을 사용하려는 개발자들이 있다.&lt;/p&gt;

&lt;p&gt;Git에서는 각 하위 디렉토리를 별도의 Git 저장소로 만들어야 한다. 그리고 그 저장소들을 포함하는 상위 저장소를 만든다. 슈퍼프로젝트의 태그와 브랜치를 이용해서 각 프로젝트의 관계를 구체적으로 정의할 수 있다는 것이 바로 Git의 장점이다.&lt;/p&gt;

&lt;h3 id='____'&gt;서브모듈 사용할 때 주의할 점들&lt;/h3&gt;

&lt;p&gt;전체적으로 서브모듈은 어렵지 않게 사용할 수 있지만, 서브모듈의 코드를 수정하는 경우에는 주의할 필요가 있다. &lt;code&gt;git submodule update&lt;/code&gt; 명령을 실행시키면 특정 브랜치가 아니라 슈퍼프로젝트에 저장된 커밋을 Checkout해 버린다(역주 - 슈퍼프로젝트에 서브 모듈의 브랜치가 저장하는 것이 아니라 특정 커밋이 저장된다). 그러면 &lt;code&gt;detached HEAD&lt;/code&gt;라고 부르는 상태가 된다. &lt;code&gt;detached HEAD&lt;/code&gt;는 HEAD가 브랜치나 태그 같은 간접 참조가 가리키지 않는 커밋을 가리키는 것을 말한다. 데이터를 잃을 수도 있기 때문에 일반적으로 &lt;code&gt;detached HEAD&lt;/code&gt; 상태는 피해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;submodule update&lt;/code&gt;를 실행하고 나서 별도의 작업용 브랜치를 만들지 않고 서브모듈 코드를 수정하고 커밋한다. 그리고 나중에 커밋한 것을 잊은 채로 슈퍼프로젝트에서 다시 &lt;code&gt;git submodule update&lt;/code&gt;를 실행시키면 Git은 아무 말 없이 Checkout한다. 엄밀히 말해서 커밋을 잃어버리는 것이 아니지만 브랜치에 속하지 않는 커밋을 찾아내기란 정말 어렵다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git checkout -b work&lt;/code&gt; 같은 명령으로 작업할 때마다 work 브랜치를 만들면 이 문제를 피할 수 있다. 실수로 &lt;code&gt;submodule update&lt;/code&gt; 명령을 실행해 버려서 하던 일을 놓쳐버려도 언제든지 되찾을 포인터가 있다.&lt;/p&gt;

&lt;p&gt;그리고 서브모듈이 있는 슈퍼프로젝트의 브랜치를 오갈 때는 약간의 추가작업이 필요하다. 브랜치를 만들고 서브모듈을 추가한다. 그 다음에 서브모듈이 없는 브랜치로 돌아간다. 그렇지만, 이미 추가한 서브모듈 디렉토리가 아직도 untracked 상태로 보일 것이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -b rack
Switched to a new branch &amp;quot;rack&amp;quot;
$ git submodule add git@github.com:schacon/rack.git rack
Initialized empty Git repository in /opt/myproj/rack/.git/
...
Receiving objects: 100% (3184/3184), 677.42 KiB | 34 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
$ git commit -am &amp;#39;added rack submodule&amp;#39;
[rack cc49a69] added rack submodule
 2 files changed, 4 insertions(+), 0 deletions(-)
 create mode 100644 .gitmodules
 create mode 160000 rack
$ git checkout master
Switched to branch &amp;quot;master&amp;quot;
$ git status
# On branch master
# Untracked files:
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to include in what will be committed)
#
#      rack/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;서브모듈 디렉토리를 다른 곳에 옮겨두거나 삭제해야 한다. 그리고 나중에 서브모듈이 있는 브랜치로 돌아가서 복원한다. 만약 다시 Clone하면 아직 Push하지 않은 내용이나 브랜치를 잃게 되니 조심해야 한다.&lt;/p&gt;

&lt;p&gt;rack이라는 디렉토리가 있고 이것을 서브모듈로 바꾸려고 한다고 가정하자. 먼저 rack 디렉토리를 삭제하고 &lt;code&gt;submodule add&lt;/code&gt;를 실행하면 Git은 다음과 같은 에러를 뱉는다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm -Rf rack/
$ git submodule add git@github.com:schacon/rack.git rack
&amp;#39;rack&amp;#39; already exists in the index&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;rack&lt;/code&gt; 디렉토리를 Staging Area에서 제거하면 서브모듈을 추가할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rm -r rack
$ git submodule add git@github.com:schacon/rack.git rack
Initialized empty Git repository in /opt/testsub/rack/.git/
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 88 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;브랜치 하나에서는 해결했다. 이제 그 디렉토리가 아직 서브모듈이 아닌 브랜치로 가려고 하면 다음과 같은 에러가 난다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master
error: Untracked working tree file &amp;#39;rack/AUTHORS&amp;#39; would be overwritten by merge.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다른 브랜치로 바꾸기 전에 &lt;code&gt;rack&lt;/code&gt; 서브모듈 디렉토리를 다른 곳으로 옮겨 둔다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mv rack /tmp/
$ git checkout master
Switched to branch &amp;quot;master&amp;quot;
$ ls
README	rack&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 나서 다시 서브모듈이 있는 브랜치로 돌아가면 rack 디렉토리는 비어 있다. 그래서 &lt;code&gt;git submodule update&lt;/code&gt; 명령으로 다시 Clone하거나 &lt;code&gt;/tmp/rack/&lt;/code&gt;에 복사해둔 파일을 다시 복사한다.&lt;/p&gt;

&lt;h2 id='subtree_merge'&gt;Subtree Merge&lt;/h2&gt;

&lt;p&gt;서브모듈 시스템이 무엇이고 어디에 쓰는지 배웠다. 그런데 같은 문제를 해결하는 방법이 또 하나 있다. Git은 Merge하는 시점에 무엇을 Merge할지, 어떤 전략을 사용할지 결정해야 한다. Git은 브랜치 두 개를 Merge할 때에는 &lt;em&gt;Recursive&lt;/em&gt; 전략을 사용하고 세 개 이상의 브랜치를 Merge할 때에는 &lt;em&gt;Octopus&lt;/em&gt; 전략을 사용한다. 이 전략들은 자동으로 선택된다. Recursive 전략은 Merge하려는 두 커밋과 공통 조상 커밋을 이용하는 &lt;code&gt;three-way merge&lt;/code&gt;를 사용하기 때문에 단 두 개의 브랜치에만 적용할 수 있다. Octopus 전략은 브랜치가 여러 개라도 Merge할 수 있지만 비교적 충돌이 쉽게 일어난다. 그래서 Merge할 브랜치가 두 개면 recursive 전략이 선택된다.&lt;/p&gt;

&lt;p&gt;다른 전략들도 있는데 그중 하나가 &lt;em&gt;Subtree&lt;/em&gt; Merge다. 이 Merge는 하위 프로젝트 문제를 해결하는 데에도 사용한다. 위에서 사용했던 Rack 예제를 적용해 보자.&lt;/p&gt;

&lt;p&gt;Subtree Merge는 마치 하위 프로젝트가 아예 합쳐진 것처럼 보일 정도로 한 프로젝트를 다른 프로젝트의 하위 디렉토리에 연결해준다. 정말 놀라운 기능이다.&lt;/p&gt;

&lt;p&gt;Rack 프로젝트를 원격 저장소로 추가시키고 브랜치를 Checkout한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote add rack_remote git@github.com:schacon/rack.git
$ git fetch rack_remote
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From git@github.com:schacon/rack
 * [new branch]      build      -&amp;gt; rack_remote/build
 * [new branch]      master     -&amp;gt; rack_remote/master
 * [new branch]      rack-0.4   -&amp;gt; rack_remote/rack-0.4
 * [new branch]      rack-0.9   -&amp;gt; rack_remote/rack-0.9
$ git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch &amp;quot;rack_branch&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Checkout한 &lt;code&gt;rack_branch&lt;/code&gt;의 루트 디렉토리와 origin 프로젝트의 &lt;code&gt;master&lt;/code&gt; 브랜치의 루트 디렉토리는 다르다. 브랜치를 바꿔가며 어떻게 다른지 확인한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls
AUTHORS	       KNOWN-ISSUES   Rakefile      contrib	       lib
COPYING	       README         bin           example	       test
$ git checkout master
Switched to branch &amp;quot;master&amp;quot;
$ ls
README&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기에서 Rack 프로젝트를 &lt;code&gt;master&lt;/code&gt; 브랜치의 하위 디렉토리에 넣으려면 &lt;code&gt;git read-tree&lt;/code&gt; 명령어를 사용한다. 9장에서 &lt;code&gt;read-read&lt;/code&gt; 류의 명령어들을 좀 더 자세히 다룬다. 여기에서는 작업 디렉토리와 Staging Area로 어떤 브랜치를 통째로 넣을 수 있다는 것만 알면 된다. &lt;code&gt;master&lt;/code&gt; 브랜치로 되돌아가서 &lt;code&gt;rack_branch&lt;/code&gt;를 &lt;code&gt;rack&lt;/code&gt; 디렉토리에 넣는다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git read-tree --prefix=rack/ -u rack_branch&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 나서 커밋을 하면 rack 디렉토리는 rack 프로젝트의 파일들을 직접 복사해 넣은 것과 똑같다. 복사한 것과 다른 점은 브랜치를 자유롭게 바꿀 수 있고 최신 버전의 Rack 프로젝트의 코드를 쉽게 끌어 올 수 있다는 점이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout rack_branch
$ git pull&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 &lt;code&gt;git merge -s subtree&lt;/code&gt;라는 명령어를 사용하여 &lt;code&gt;master&lt;/code&gt; 브랜치와 Merge할 수 있고 원하든 원하지 않든 간에 히스토리도 함께 Merge된다. 수정 내용만 Merge하거나 커밋 메시지를 다시 작성하려면 &lt;code&gt;-s subtree&lt;/code&gt; 옵션에다가 &lt;code&gt;--squash&lt;/code&gt;, &lt;code&gt;--no-commit&lt;/code&gt;를 함께 사용해야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master
$ git merge --squash -s subtree --no-commit rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rack 프로젝트의 최신 코드를 가져다가 Merge했고 이제 커밋하면 된다. 물론 반대로 하는 것도 가능하다. &lt;code&gt;rack&lt;/code&gt; 디렉토리로 이동해서 코드를 수정하고 &lt;code&gt;rack_branch&lt;/code&gt; 브랜치로 Merge한다. 그리고 Rack 프로젝트 저장소에 Push할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;rack&lt;/code&gt; 디렉토리와 &lt;code&gt;rack_branch&lt;/code&gt; 브랜치와의 차이점도 비교해볼 수 있다. 일반적인 &lt;code&gt;diff&lt;/code&gt; 명령은 사용할 수 없고 &lt;code&gt;git diff-tree&lt;/code&gt; 명령을 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff-tree -p rack_branch&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;또 &lt;code&gt;rack&lt;/code&gt; 디렉토리와 저장소의 &lt;code&gt;master&lt;/code&gt; 브랜치와 비교할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff-tree -p rack_remote/master&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id62'&gt;요약&lt;/h2&gt;

&lt;p&gt;커밋과 저장소를 꼼꼼하게 관리할 수 있는 도구들을 살펴보았다. 문제가 생기면 바로 누가, 언제, 무엇을 했는지 찾아낼 수 있어야 한다. 그리고 프로젝트를 쪼개고 싶을 때 사용하는 방법들도 배웠다. 이제 Git 명령어들은 거의 모두 배운 것이다. 나는 하루빨리 독자들이 익숙해져서 자유롭게 사용할 수 있길 바란다.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Pro Git - 5. 분산 환경에서의 Git</title>
   <link href="http://ygpark.github.com/Pro Git/2012/08/29/pro-git-5-distributed-git"/>
   <updated>2012-08-29T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Pro Git/2012/08/29/pro-git-5-distributed-git</id>
   <content type="html">&lt;h1 id='__git'&gt;분산 환경에서의 Git&lt;/h1&gt;

&lt;p&gt;앞 장에서 다른 개발자와 코드를 공유할 수 있는 원격 저장소를 만드는 법을 배웠고 로컬에서 작업하는 데 필요한 기본적인 명령어에는 어느 정도 익숙해졌다. 이제는 분산 환경에서 Git이 제공하는 기능을 어떻게 효율적으로 사용할지를 배운다.&lt;/p&gt;

&lt;p&gt;이번 장에서는 여러분이 프로젝트 기여자가, 여러 수정사항을 취합하는 관리자가 되면 분산 환경에서 Git을 어떻게 사용할 수 있을지 살펴본다. 즉, 프로젝트 기여자 또는 관리자로서 작업물을 프로젝트에 어떻게 포함시킬지와 수많은 개발자가 수행한 일을 취합하고 프로젝트를 운영하는 방법을 배운다.&lt;/p&gt;

&lt;h2 id='__workflow'&gt;분산 환경에서의 Workflow&lt;/h2&gt;

&lt;p&gt;중앙집중형 버전 관리 시스템과는 달리 Git은 분산형이다. Git의 구조가 훨씬 더 유연하기 때문에 여러 개발자가 함께 작업하는 방식을 더 다양하게 구성할 수 있다. 중앙집중형 버전 관리 시스템에서 각 개발자는 중앙 저장소를 중심으로 하는 하나의 노드일 뿐이다. 하지만, Git에서는 각 개발자의 저장소가 하나의 노드이기도 하고 중앙 저장소 같은 역할도 할 수 있다. 즉, 모든 개발자는 다른 개발자의 저장소에 일한 내용을 전송하거나, 다른 개발자들이 참여할 수 있도록 자신이 운영하는 저장소 위치를 공개할 수도 있다. 이런 특징은 프로젝트나 팀이 코드를 운영할 때 다양한 Workflow을 만들 수 있도록 해준다. 이런 유연성을 살려 저장소를 운영하는 몇 가지 방식을 소개한다. 각 방식의 장단점을 살펴보고 그 방식 중 하나를 고르거나 여러 가지를 적절히 섞어 쓰면 된다.&lt;/p&gt;

&lt;h3 id='_workflow'&gt;중앙집중식 Workflow&lt;/h3&gt;

&lt;p&gt;중앙집중식 시스템에서는 보통 중앙집중식 협업 모델이라는 한 가지 방식밖에 없다. 하나의 중앙 저장소가 존재하고 모든 변경 사항은 이 중앙 저장소로 집중된다. 모든 개발자는 이 중앙 저장소를 기준으로 한다. 즉, 개발자 다수는 이 하나의 중앙 저장소를 중심으로 작업을 한다(그림 5-1)&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0501-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-1. 중앙집중식 Workflow.&lt;/p&gt;

&lt;p&gt;중앙집중식에서 개발자 두 명이 중앙저장소를 Clone하고 각자 수정하는 상황을 생각해보자. 한 개발자가 한 일을 커밋하고 나서 아무 문제 없이 서버에 Push한다. 그러면 다른 개발자는 한 일을 커밋하고 Push하기 전에 첫 번째 개발자가 한 일을 먼저 Merge해야 한다. Merge를 해야 첫 번째 개발자가 작업한 내용을 덮어쓰지 않는다. 이런 개념은 Subversion과 같은 중앙집중식 버전 관리 시스템에서 사용하는 방식이고 Git에서도 당연히 이런 Workflow를 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;팀이 작거나 이미 중앙집중식에 적응한 상황이라면 이 Workflow에 따라 Git을 도입하여 사용할 수 있다. 중앙 저장소를 하나 만들고 개발자 모두에게 Push 권한을 부여한다. 모두에게 Push 권한을 부여해도 Git은 한 개발자가 다른 개발자의 작업 내용을 덮어쓰도록 허용하지 않는다. 한 개발자가 Clone하고 나서 수정하는 사이에 이미 다른 개발자가 중앙 저장소에 무언가 Push했다면 이 개발자는 Push할 수 없다. Git은 개발자에게 지금 Push하려는 커밋으로 Fast-forward할 수 없으며 Fetch하고 Merge를 하지 않으면 서버로 Push할 수 없다고 알려준다. 이런 개념은 이미 많은 개발자에게 익숙하므로 거부감 없이 도입할 수 있다.&lt;/p&gt;

&lt;h3 id='integrationmanager_workflow'&gt;Integration-Manager Workflow&lt;/h3&gt;

&lt;p&gt;Git을 사용하면 원격 저장소를 여러 개 운영할 수 있기 때문에 개발자 자신은 읽고 쓸 수 있고, 다른 개발자는 읽을 수만 있는 공개 저장소를 사용하는 Workflow도 있다. 이 Worlflow에는 보통 프로젝트를 대표하는 하나의 공식 저장소가 있다. 그리고 프로젝트에 기여하려면 우선 공식 저장소를 하나 Clone하고 수정하고 나서 자신의 저장소에 Push한다. 그다음에 프로젝트 Integration-Manager에게 새 저장소에서 Pull하라고 요청한다. 그러면 그 Integration-Manager는 기여자의 저장소를 원격 저장소로 등록하고, 로컬에서 기여물을 테스트하고, 프로젝트의 메인 브랜치에 Merge를 하고, 그 내용을 다시 프로젝트 메인 저장소에 Push한다. 이런 과정은 다음과 같다(그림 5-2).&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;프로젝트 Integration-Manager는 프로젝트 메인 저장소에 Push를 한다.&lt;/li&gt;

&lt;li&gt;프로젝트 기여자는 메인 저장소를 Clone하고 수정한다.&lt;/li&gt;

&lt;li&gt;기여자는 자신의 저장소에 Push하고 Integration-Manager가 접근할 수 있도록 공개해 놓는다.&lt;/li&gt;

&lt;li&gt;기여자는 Integration-Manager에게 변경사항을 적용해 줄 것을 E-mail 같은 것으로 요청한다.&lt;/li&gt;

&lt;li&gt;Integration-Manager는 기여자의 저장소를 원격 저장소로 등록하고 수정사항을 Merge하여 테스트한다.&lt;/li&gt;

&lt;li&gt;Integration-Manager는 Merge한 사항을 메인 저장소에 Push한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0502-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-2. Integration-Manager Workflow&lt;/p&gt;

&lt;p&gt;이런 방식은 GitHub 같은 사이트에서 일반적으로 사용하는 방식이다. GitHub는 프로젝트를 Fork하고 수정사항을 반영하여 다시 모두에게 공개하기 좋은 구조로 되어 있다. 이 방식의 장점은 기여자와 Integration-Manager가 각자의 사정에 맞춰 프로젝트를 유지할 수 있다는 점이다. 기여자는 자신의 저장소와 브랜치에서 수정 작업을 계속해 나갈 수 있고 수정사항이 프로젝트에 반영되도록 기다릴 필요가 없다. 그냥 커밋을 Push해 놓으면 관리자는 여유를 가지고 적절한 시점에 Merge한다.&lt;/p&gt;

&lt;h3 id='dictator_and_lieutenants_workflow'&gt;Dictator and Lieutenants Workflow&lt;/h3&gt;

&lt;p&gt;이 방식은 여러 저장소를 운영하는 방식을 변형한 구조이다. 보통 수백 명의 개발자가 기여하는 아주 큰 프로젝트를 운영할 때 이 방식을 사용한다. 리눅스 커널 프로젝트가 대표적이다. 여러 명의 Integration-Manager들이 저장소에서 자신이 맡은 부분만을 담당하는데 이들을 Lieutenants라고 부른다. 모든 Lieutenant는 최종 관리자 아래에 있으며 이 최종 관리자를 Dictator라고 부른다(그림 5-3).&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;개발자는 코드를 수정하고 master 브랜치를 기준으로 자신의 토픽 브랜치를 Rebase한다. 여기서 master 브랜치란 Dictator의 브랜치를 말한다.&lt;/li&gt;

&lt;li&gt;Lieutenant들은 개발자들의 수정사항을 자신이 관리하는 master 브랜치에 Merge한다.&lt;/li&gt;

&lt;li&gt;Dictator는 Lieutenant의 master 브랜치를 자신의 master 브랜치로 Merge한다.&lt;/li&gt;

&lt;li&gt;Dictator는 Merge한 자신의 master 브랜치를 Push하여 다른 모든 개발자가 Rebase할 수 있는 기준으로 만든다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0503-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-3. Benevolent dictator Workflow&lt;/p&gt;

&lt;p&gt;이 방식이 일반적이지 않지만 깊은 계층 구조를 가지는 환경이나 규모가 큰 프로젝트에서는 매우 쓸모 있다. 프로젝트 리더가 모든 코드를 통합하기 전에 코드를 부분부분 통합하도록 여러 명의 Lieutenant에게 위임할 수 있다.&lt;/p&gt;

&lt;p&gt;이 세 가지 Workflow가 Git 같은 분산 버전 관리 시스템에서 주로 사용하는 것들이다. 사실 실제로 사용하는 것은 이런 Workflow뿐만 아니라 다양한 변종 Workflow를 사용한다. 어떤 방식을 선택하고 혹은 조합해야 하는 지 살짝 감이 잡힐 것이다. 이 장에서는 몇 가지 구체적 사례를 들고 우리가 다양한 환경에서 각 역할을 어떻게 수행할 수 있는지 살펴볼 것이다.&lt;/p&gt;

&lt;h2 id='_'&gt;프로젝트에 기여하기&lt;/h2&gt;

&lt;p&gt;이미 다른 장에서 기본적인 Git 사용법에 대해서 배웠고 몇 가지 Workflow도 살펴보았다. 이제 이 절에서는 Git으로 프로젝트에 어떻게 기여하는 지에 대해 배운다.&lt;/p&gt;

&lt;p&gt;매우 다양한 방식으로 프로젝트에 기여할 수 있다는 것은 정말 설명하기 어렵다. Git이 워낙 유연하게 설계됐기 때문에 사람들은 여러 가지 방식으로 사용할 수 있다. 게다가 프로젝트마다 환경이 달라서 프로젝트에 기여하는 방식을 쉽게 설명하기란 정말 어렵다. 기여하는 방식에 영향을 끼치는 몇 가지 변수가 있다. 활발히 기여하는 개발자의 수가 얼마인지, 선택한 Workflow가 무엇인지, 각 개발자에게 접근 권한을 어떻게 부여했는지, 외부에서도 기여할 수 있는지 등이 변수다.&lt;/p&gt;

&lt;p&gt;첫 번째로 살펴볼 변수는 활발히 활동하는 개발자의 수이다. 얼마나 많은 개발자가 얼마나 자주 코드를 쏟아 내는가 하는 점이 활발한 개발자의 기준이다. 대부분 둘, 셋 정도의 개발자가 하루에 몇 번 커밋을 하고 활발하지 않은 프로젝트는 더 띄엄띄엄할 것이다. 하지만, 아주 큰 프로젝트는 수백, 수천 명의 개발자가 하루에도 수십, 수백 개의 커밋을 만들어 낸다. 개발자가 많으면 많을수록 코드를 깔끔하게 적용하거나 Merge하기 어려워진다. 어떤 것은 다른 개발자가 기여한 것으로 불필요해지기도 하고 때론 서로 충돌이 일어난다. 어떻게 해야 코드를 최신으로 유지하면서 원하는 대로 수정할 수 있을까?&lt;/p&gt;

&lt;p&gt;두 번째 변수는 프로젝트에서 선택한 저장소 운영 방식이다. 메인 저장소에 개발자 모두가 쓰기 권한을 가지는 중앙집중형 방식인가? 프로젝트에 모든 Patch를 검사하고 통합하는 관리자가 따로 있는가? 모든 수정사항을 개발자끼리 검토하고 승인하는가? 자신도 기여 이상의 역할을 하고 있는지? 중간 관리자가 있어서 그들에게 먼저 알려야 하는가?&lt;/p&gt;

&lt;p&gt;세 번째 변수는 접근 권한이다. &amp;#8216;프로젝트에 쓰기 권한이 있어서 직접 쓸 수 있는가? 아니면 읽기만 가능한 권한인가?&amp;#8217;에 따라서 프로젝트에 기여하는 방식이 매우 달라진다. 쓰기 권한이 없다면 어떻게 수정 사항을 프로젝트에 반영할 수 있을까? 수정사항을 적용하는 정책이 프로젝트에 있는가? 얼마나 많은 시간을 프로젝트에 기여하는가? 얼마나 자주 기여하는가?&lt;/p&gt;

&lt;p&gt;이런 모든 질문은 프로젝트에 기여하는 방법과 Workflow 등이 달라진다. 간단한 것부터 복잡한 것까지 각 상황을 살펴보고 나면 실제 프로젝트에 필요한 방식을 선택할 수 있을 것이다.&lt;/p&gt;

&lt;h3 id='_'&gt;커밋 가이드라인&lt;/h3&gt;

&lt;p&gt;다른 것보다 먼저 커밋 메시지에 대한 주의사항을 알아보자. 좋은 커밋 메시지에 대한 가이드라인을 잘 알아두면 다른 개발자와 함께 일하는 데 도움이 많이 된다. Git 프로젝트에 보면 커밋 메시지를 작성하는데 참고할 만한 좋은 팁이 많다. Git 프로젝트의 &amp;#8216;Documentation/SubmittingPatches&amp;#8217; 문서를 참고하자(역주: http://git.kernel.org/?p=git/git.git;a=blob;f=Documentation/SubmittingPatches;hb=HEAD).&lt;/p&gt;

&lt;p&gt;그리고 공백문자들을 깨끗하게 정리하고 커밋해야 한다. Git은 공백문자를 검사해볼 수 있는 간단한 명령을 제공한다. 커밋을 하기 전에 &lt;code&gt;git diff --check&lt;/code&gt; 명령으로 공백문자에 대한 오류를 확인할 수 있다. 아래 예제를 보면 잘 못 사용한 공백을 &amp;#8216;X&amp;#8217; 문자로 바꾸어 표시해준다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff --check
lib/simplegit.rb:5: trailing whitespace.
+    @git_dir = File.expand_path(git_dir)XX
lib/simplegit.rb:7: trailing whitespace.
+ XXXXXXXXXXX
lib/simplegit.rb:26: trailing whitespace.
+    def command(git_cmd)XXXX&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;커밋을 하기 전에 공백문자에 대해 검사를 하면 공백으로 불필요하게 커밋되는 것을 막고 이런 커밋으로 인해 불필요하게 다른 개발자들이 신경 쓰는 일을 방지할 수 있다.&lt;/p&gt;

&lt;p&gt;그리고 각 커밋은 논리적으로 구분되는 Changeset이다. 최대한 수정사항을 하나의 주제로 요약할 수 있어야 하고 여러 가지 이슈에 대한 수정사항을 전부 하나의 커밋에 담지 않아야 한다. 여러 가지 이슈를 한꺼번에 수정했다고 하더라도 Stage 영역으로 하나의 이슈를 하나의 커밋으로 나누어 커밋을 의미 있게 만들 수 있다. 같은 파일의 다른 부분을 수정하는 경우에는 &lt;code&gt;git add -patch&lt;/code&gt; 명령을 써서 한 부분씩 나누어 Stage 영역에 저장해야 한다(관련 내용은 6장에서 다룰 것이다). 결과적으로 최종 프로젝트의 모습은 한 번에 커 믿을 하든 다섯 번에 나누어 커밋을 하든 똑같다. 하지만, 여러 번에 나누어 커밋하는 것이 다른 동료가 수정한 부분을 확인할 때나 각 커밋의 시점으로 복원해서 검토할 때에 이해하기 훨씬 쉽다. 6장에서는 이미 저장된 커밋을 다시 수정하거나 파일들을 단계적으로 Stage영역에 저장하는 방법을 살펴볼 것이다. 여러 가지 도구를 이용해서 간단하고 이해하기 쉬운 커밋을 쌓아가야 한다.&lt;/p&gt;

&lt;p&gt;마지막으로 명심해야 할 점은 커밋 메시지 자체다. 좋은 커밋 메시지를 작성하는 습관은 Git을 사용하는 데 도움이 많이 된다. 커밋 메시지 작성하는 보편적인 규칙이 있다. 메시지의 첫 줄에 50자가 넘지 않는 아주 간략한 메시지를 적어 해당 커밋을 요약한다. 다음 한 줄은 비우고 그다음 줄부터 커밋을 자세히 설명한다. 예를 들어 Git 개발 프로젝트에서는 개발 동기와 구현 상황의 제약조건이나 상황 등을 자세하게 요구한다. 이런 점은 따를 만한 좋은 가이드라인이다. 그리고 현재형 표현을 사용하는 것이 좋다. 예를 들어 &amp;#8220;I added tests for (테스트를 추가함)&amp;#8221; 보다는 &amp;#8220;Add tests for (테스트 추가)&amp;#8221; 와 같은 메시지를 작성한다. 아래 예제는 Pope_at_tpope.net이 작성한 커밋 메시지이다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;영문 50글자 이하의 간략한 수정 요약

자세한 설명. 영문 72글자 이상이 되면 줄 바꿈을 하고 이어지는 내용을
작성한다. 특정 상황에서는 첫 번째 줄이 이메일 메시지의 제목이 되고
나머지는 메일 내용이 된다. 간략한 요약 이후에 넣는 빈 줄은 자세한 
설명을 아예 쓰지 않는 한 매우 중요하다.

이어지는 추가적인 내용은 한 줄 띄우고 쓴다.

 - 목록 표시도 사용할 수 있다.

 - 보통 &amp;#39;-&amp;#39; 나 &amp;#39;*&amp;#39; 표시를 사용해서 목록을 표현하고 표시 앞에 공백
   하나, 각 목록 사이에는 빈 줄을 하나를 넣는데 상황에 따라 다르다.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;메시지를 이렇게 작성하면 함께 일하는 사람은 물론이고 자신에게도 매우 유용하다. Git 개발 프로젝트에는 잘 쓰인 커밋 메시지가 많으므로 프로젝트를 내려받아서 &lt;code&gt;git log --no-merges&lt;/code&gt; 명령으로 꼭 살펴보기를 권한다.&lt;/p&gt;

&lt;p&gt;이 책에서 설명하는 예제의 커밋 메시지는 시간 관계상 위와 같이 아주 멋지게 쓰지는 않을 것이다. &lt;code&gt;git commit&lt;/code&gt; 명령에서 &lt;code&gt;-m&lt;/code&gt; 옵션을 사용하여 간단하게만 적을 것이다. 하지만! 저자처럼 하지 말고 시킨 대로 하셔야 한다.&lt;/p&gt;

&lt;h3 id='__'&gt;비공개 소규모 팀&lt;/h3&gt;

&lt;p&gt;다양한 프로젝트 환경 중에 가장 간단한 것은 두세 명으로 이루어진 비공개 프로젝트일 것이다. 비공개라고 함은 소스코드가 공개되지 않은 것을 말하는 것이지 외부에서 전혀 접근 불가능한 것을 말하는 것이 아니다. 모든 개발자는 공유하는 저장소에 쓰기 권한이 있어야 한다.&lt;/p&gt;

&lt;p&gt;이런 환경에서는 보통 Subversion 같은 중앙집중형 버전 관리 시스템에서 사용하던 방식을 사용한다. 물론 Git이 가진 오프라인 커밋 기능이나 브랜치 Merge 기능을 이용하긴 하지만 크게 다르지 않다. 가장 큰 차이점은 서버가 아닌 클라이언트 쪽에서 Merge한다는 점이다. 두 개발자가 저장소를 공유하는 시나리오를 살펴보자. 개발자 John씨는 저장소를 Clone하고 파일을 수정하고 나서 로컬에 커밋한다(Git이 출력하는 메시지를 &lt;code&gt;...&lt;/code&gt;으로 줄이고 생략한다).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# John&amp;#39;s Machine
$ git clone john@githost:simplegit.git
Initialized empty Git repository in /home/john/simplegit/.git/
...
$ cd simplegit/
$ vim lib/simplegit.rb 
$ git commit -am &amp;#39;removed invalid default value&amp;#39;
[master 738ee87] removed invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;개발자 Jessica씨도 저장소를 Clone하고 나서 파일을 하나 새로 추가하고 커밋한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Jessica&amp;#39;s Machine
$ git clone jessica@githost:simplegit.git
Initialized empty Git repository in /home/jessica/simplegit/.git/
...
$ cd simplegit/
$ vim TODO 
$ git commit -am &amp;#39;add reset task&amp;#39;
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jessica 씨는 서버로 커밋을 Push한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Jessica&amp;#39;s Machine
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -&amp;gt; master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;John씨도 서버로 커밋을 Push하려고 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# John&amp;#39;s Machine
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -&amp;gt; master (non-fast forward)
error: failed to push some refs to &amp;#39;john@githost:simplegit.git&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jessica씨의 Push는 성공했지만, John씨의 커밋은 서버에서 받아들여지지 않았다. Subversion을 사용했던 사람에게는 특히 이 부분을 이해하는 것이 중요하다. 같은 파일을 수정한 것도 아닌데 왜 Push는 받아들여지지 않는 것일까? Subversion에서는 서로 다른 파일을 수정하는 이런 Merge 작업은 자동으로 서버가 처리한다. 하지만, Git은 로컬에서 먼저 Merge해야 한다. John씨는 Push하기 전에 Jessica씨가 수정한 커밋을 Fetch하고 Merge해야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -&amp;gt; origin/master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fetch하고 나면 John씨의 로컬 저장소는 그림 5-4와 같이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0504-tn.png' /&gt; Figure 5-4. Fetch하고 난 John씨의 저장소.&lt;/p&gt;

&lt;p&gt;John씨는 Jessica씨가 저장소로 Push했던 커밋이 있는 브랜치를 로컬 저장소로 가져왔다. 하지만, Push를 하기 전에 Fetch한 브랜치를 Merge해야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git merge origin/master
Merge made by recursive.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Merge가 잘 이루어지면 John씨의 브랜치는 그림 5-5와 같은 상태가 된다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0505-tn.png' /&gt; Figure 5-5. origin/master 브랜치를 Merge하고 난 후, John씨의 저장소.&lt;/p&gt;

&lt;p&gt;John씨는 Merge하고 나서 자신이 작업한 코드가 제대로 동작하는지 확인하고 공유하는 저장소로 Push한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -&amp;gt; master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 John씨의 저장소는 그림 5-6 처럼 되었다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0506-tn.png' /&gt; Figure 5-6. Push하고 난 후, John씨의 저장소.&lt;/p&gt;

&lt;p&gt;동시에 Jessica씨는 토픽 브랜치를 하나 만들었다. issue54 브랜치를 만들고 세 번에 걸쳐서 커밋을 했다. 아직 John씨의 커밋을 Fetch하지 않은 상황이기 때문에 그림 5-7과 같은 상황이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0507-tn.png' /&gt; Figure 5-7. Jessica씨의 저장소.&lt;/p&gt;

&lt;p&gt;Jessica씨는 John씨의 작업을 적용하기 위해 Fetch를 먼저 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Jessica&amp;#39;s Machine
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -&amp;gt; origin/master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 명령을 통해 John씨가 Push한 커밋을 모두 내려받는다. 그리고 나서 Jessica씨의 저장소는 그림 5-8과 같은 상태가 될 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0508-tn.png' /&gt; Figure 5-8. John씨의 커밋을 Fetch한 후 Jessica씨의 저장소.&lt;/p&gt;

&lt;p&gt;Jessica씨는 토픽 브랜치의 작업을 마치고 만약 origin/master와 Merge를 하게 되면 어떤 내용이 Merge될 지, &lt;code&gt;git log&lt;/code&gt; 명령으로 확인한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --no-merges origin/master ^issue54
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith &amp;lt;jsmith@example.com&amp;gt;
Date:   Fri May 29 16:01:27 2009 -0700

    removed invalid default value&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Merge할 내용을 확인한 Jessica씨는 자신이 작업한 내용과 John씨가 Push한 작업(origin/master)을 master 브랜치에 Merge하고 Push할 차례다. 모든 내용을 합치기 전에 우선 master 브랜치를 Checkout한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master
Switched to branch &amp;quot;master&amp;quot;
Your branch is behind &amp;#39;origin/master&amp;#39; by 2 commits, and can be fast-forwarded.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;origin/master, issue54 모두 master보다 Fast-forward된 브랜치이기 때문에 둘 중에 무엇을 먼저 Merge하든 상관이 없다. 물론 어떤 것을 먼저 Merge하느냐에 따라 히스토리 순서는 달라지지만, 최종 결과는 똑같다. Jessica씨는 먼저 issue54 브랜치를 Merge한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;보다시피 Fast-forward Merge이기 때문에 별 문제 없이 실행된다. 다음은 John씨의 커밋(origin/master)을 Merge할 차례다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같이 Merge가 잘 되면 그림 5-9와 같은 상태가 된다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0509-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-9. Merge 이후 Jessica씨의 저장소.&lt;/p&gt;

&lt;p&gt;origin/master 브랜치가 Jessica씨의 master 브랜치로 나아갈(reachable) 수 있기 때문에 Push는 성공한다(물론 John씨가 그 사이에 Push를 하지 않았다면):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -&amp;gt; master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;두 개발자의 커밋과 Merge가 성공적으로 이루어지고 난 후의 결과는 5-10과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0510-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-10. Jessica씨가 서버로 Push하고 난 후의 저장소.&lt;/p&gt;

&lt;p&gt;여기서 살펴본 예제가 가장 간단한 상황이다. 토픽 브랜치에서 수정하고 로컬의 master 브랜치에 Merge를 한다. 작업한 내용을 프로젝트의 공유 저장소에 Push하고자 할 때에는 우선 origin/master 브랜치를 Fetch하고 Merge한다. 그리고 나서 Merge한 결과를 다시 서버로 Push한다. 이런 일반적인 Workflow은 그림 5-11로 나타낼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0511-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-11. 여러 개발자가 Git을 사용하는 일반적인 Workflow&lt;/p&gt;

&lt;h3 id='__'&gt;비공개 대규모 팀&lt;/h3&gt;

&lt;p&gt;이제 비공개 대규모 팀에서의 역할들을 살펴보자. 이런 상황에는 팀을 여러 개로 나눠야 하기에 각각의 작은 팀들이 서로 어떻게 하나로 Merge하는지 살펴본다.&lt;/p&gt;

&lt;p&gt;John씨와 Jessica씨는 한팀이고 프로젝트에서 어떤 한 부분을 담당한다. 또한, Jessica씨와 Josie씨도 다른 부분을 담당하는 한 팀이다. 이런 상황이라면 회사는 Integration-manager Workflow를 선택하는 게 좋다. 작은 팀들이 수행한 결과물은 Integration-Manager가 Merge하고 공유 저장소의 master 브랜치를 업데이트한다. 팀마다 브랜치를 하나씩 만들고 Integration-Manager는 그 브랜치를 Pull해서 Merge한다.&lt;/p&gt;

&lt;p&gt;두 팀에 모두 속한 Jessica씨의 작업 순서를 살펴보자. 우선 Jessica씨는 저장소를 Clone하고 featureA 작업을 먼저 한다. featureA 브랜치를 만들고 수정을 하고 커밋을 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Jessica&amp;#39;s Machine
$ git checkout -b featureA
Switched to a new branch &amp;quot;featureA&amp;quot;
$ vim lib/simplegit.rb
$ git commit -am &amp;#39;add limit to log function&amp;#39;
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 수정한 부분을 John씨와 공유해야 한다. 공유하려면 우선 featureA 브랜치를 서버로 Push한다. Integration-Manager만 master 브랜치를 업데이트할 수 있기 때문에 master 브랜치로 Push를 할 수 없고 다른 브랜치로 John과 공유한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -&amp;gt; featureA&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jessica씨는 John씨에게 수행한 일을 featureA라는 브랜치로 Push했다는 이메일을 보낸다. John씨의 피드백을 기다리는 동안 Jessica씨는 Josie씨와 함께 하는 featureB 작업을 하기로 한다. 서버의 master 브랜치를 기반으로 새로운 브랜치를 하나 만든다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Jessica&amp;#39;s Machine
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch &amp;quot;featureB&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;몇 가지 작업을 하고 featureB 브랜치에 커밋한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vim lib/simplegit.rb
$ git commit -am &amp;#39;made the ls-tree function recursive&amp;#39;
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am &amp;#39;add ls-files&amp;#39;
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jessica씨의 저장소는 그림 5-12과 같을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0512-tn.png' /&gt; Figure 5-12. Jessica씨의 저장소.&lt;/p&gt;

&lt;p&gt;작업을 마치고 Push하려고 하는데 Jesie씨가 이미 일부 작업을 하고 서버에 featureBee 브랜치로 Push했다는 이메일을 보내왔다. 그러므로 Jessica씨는 Jesie씨의 작업을 먼저 Merge해야만 Push할 수 있다. Merge하기 위해서 우선 &lt;code&gt;git fetch&lt;/code&gt;로 Fetch한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -&amp;gt; origin/featureBee&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fetch해 온 브랜치를 &lt;code&gt;git merge&lt;/code&gt; 명령으로 Merge한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Push하려고 하는데 작은 문제가 생겼다. Jessica씨는 featureB 브랜치에서 작업을 했는데 서버에는 브랜치가 featureBee라는 이름으로 되어 있다. 그래서 &lt;code&gt;git push&lt;/code&gt; 명령으로 Push할 때 로컬 브랜치 featureB 뒤에 콜론(:)과 함께 서버 브랜치 이름을 직접 지정해 준다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -&amp;gt; featureBee&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이것은 &lt;em&gt;refspec&lt;/em&gt; 이란 것을 사용하는 것인데 9장에서 자세하게 살펴볼 것이다.&lt;/p&gt;

&lt;p&gt;John이 몇 가지 작업을 하고 나서 featureA에 Push했고 확인해 달라는 내용의 이메일을 보내왔다. Jessica씨는 &lt;code&gt;git fetch&lt;/code&gt;로 Push한 작업에 대해서 Fetch한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -&amp;gt; origin/featureA&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;어떤 것이 업데이트됐는지 &lt;code&gt;git log&lt;/code&gt;명령으로 확인한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log origin/featureA ^featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith &amp;lt;jsmith@example.com&amp;gt;
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;확인을 마치면 로컬의 featureA 브랜치로 Merge한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout featureA
Switched to branch &amp;quot;featureA&amp;quot;
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jessica씨는 일부 수정하고, 수정한 내용을 다시 서버로 Push한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit -am &amp;#39;small tweak&amp;#39;
[featureA ed774b3] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
$ git push origin featureA
...
To jessica@githost:simplegit.git
   3300904..ed774b3  featureA -&amp;gt; featureA&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같은 작업을 마치고 나면 Jessica씨의 저장소는 그림 5-13과 같은 모습이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0513-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-13. 마지막 Push하고 난 후의 Jessica씨의 저장소&lt;/p&gt;

&lt;p&gt;featureA와 featureBee 브랜치가 프로젝트의 메인 브랜치로 Merge할 준비가 되었다고 Integration-Manager에게 알려준다. Integration-Manager가 두 브랜치를 모두 Merge하고 난 후에 메인 브랜치를 Fetch해 오면 그림 5-14와 같은 모양이 돼 있을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0514-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-14. 두 브랜치가 메인 브랜치에 Merge된 후의 저장소.&lt;/p&gt;

&lt;p&gt;수많은 팀의 작업을 동시에 진행하고 나중에 Merge하는, 이런 기능을 사용하기 위해 다른 버전 관리 시스템에서 Git으로 바꾸는 조직들이 많아지고 있다. 작은 팀이 자신의 브랜치로 작업하면서 메인 브랜치에 영향을 끼치지 않는다는 점이 Git의 장점이다. 그림 5-15는 이런 Workflow을 나타내고 있다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0515-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-15. 대규모 팀의 Workflow.&lt;/p&gt;

&lt;h3 id='__'&gt;공개 소규모 팀&lt;/h3&gt;

&lt;p&gt;비공개 팀을 운영하는 것과 공개 팀을 운영하는 것은 약간 다르다. 공개 팀을 운영할 때에는 모든 개발자가 프로젝트의 공유 저장소에 직접적으로 쓰기 권한을 가지지는 않는다. 그래서 프로젝트의 관리자는 몇 가지 일을 더 해줘야 한다. Fork를 지원하는 Git 호스팅에서 Fork 기능으로 프로젝트에 기여하는 법을 예제를 통해 살펴볼 것이다. repo.or.cz나 Github 같은 Git 호스팅 사이트는 Fork 기능을 지원하며 프로젝트 관리자들은 보통 Fork하는 것으로 프로젝트를 운영한다. 다른 방식으로 이메일과 Patch를 사용하는 방식도 있는데 뒤이어 살펴볼 것이다.&lt;/p&gt;

&lt;p&gt;우선 처음 할 일은 메인 저장소를 Clone 하는 것이다. 그리고 나서 토픽 브랜치를 만들고 일정 부분 기여한다. 그 순서는 다음과 같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone (url)
$ cd project
$ git checkout -b featureA
$ (work)
$ git commit
$ (work)
$ git commit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;rebase -i&lt;/code&gt; 명령을 사용하면 여러 커밋을 하나의 커밋으로 합치거나 프로젝트의 관리자가 수정사항을 쉽게 이해하도록 커밋들을 정리할 수 있다. 6장에서 대화 형식으로 Rebase를 하는 방법을 살펴볼 것이다.&lt;/p&gt;

&lt;p&gt;일단 프로젝트의 웹사이트로 가서 &amp;#8216;Fork&amp;#8217; 버튼을 누르면 원래 프로젝트 저장소에서 갈라져 나온, 쓰기 권한이 있는 저장소가 하나 만들어진다. 그러면 로컬에서 수정한 커밋을 외부에 있는 그 저장소에 Push할 수 있다. 그 저장소를 로컬 저장소의 원격 저장소로 등록한다. 예를 들어 myfork로 등록한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote add myfork (url)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자 이제 등록한 원격 저장소로 Push를 할 차례다. 작업하던 것을 로컬 저장소의 master 브랜치에 Merge한 후 Push하는 것보다 원격 브랜치에 바로 Push를 하는 방식이 훨씬 간단하다. 이렇게 하는 이유는 관리자가 토픽 브랜치를 프로젝트에 포함하지 않더라도 master 브랜치를 토픽 브랜치가 Merge되기 이전으로 되돌릴 필요가 없기 때문이다. 관리자가 토픽 브랜치를 Merge하든 Rebase하든 cherry-pick하든지 간에 결국 다시 관리자의 저장소를 Pull할 때에는 토픽 브랜치의 내용이 포함돼 있을 것이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push myfork featureA&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fork한 저장소로 Push하고 나면 이제 프로젝트 관리자에게 이 내용을 알려야 한다. 이런 것을 &amp;#8216;Pull Request&amp;#8217;이라고 한다. git 호스팅 사이트에서 관리자에게 보낼 메시지를 생성하거나 &lt;code&gt;git request-pull&lt;/code&gt; 명령으로 이메일을 수동으로 만들 수 있다. GitHub의 &amp;#8220;pull request&amp;#8221; 버튼은 자동으로 메시지를 만들어 준다.&lt;/p&gt;

&lt;p&gt;request-pull 명령은 인자를 두 개 입력받는데, 첫 번째는 작업한 토픽 브랜치와 Merge할 브랜치이다. 두 번째 인자는 토픽 브랜치가 위치한 저장소 URL인데 위에서 등록한 원격 저장소 이름을 적을 수 있다. 명령의 결과는 토픽 브랜치의 수정사항에 대한 요약이다. 예를 들어 Jessica씨가 John씨에게 Pull 요청을 보내는 경우 Jessica씨가 토픽 브랜치에 두 번 커밋을 하고 Fork 한 저장소에 Push를 했다면 아래와 같을 것이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
  John Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;관리자에게 이 내용을 보낸다. 이 내용에는 토픽 브랜치가 어느 시점에 분화됐는지, 어떤 커밋들이 있는 지, Pull하기 위해서 어떤 저장소에 접근해야 하는지가 들어 있다.&lt;/p&gt;

&lt;p&gt;프로젝트 관리자가 아니라고 해도 보통 origin/master를 추적하는 master 브랜치를 가지고 있지만, 토픽 브랜치를 만들고 일을 하면 관리자가 수정 내용을 거부할 때 쉽게 버릴 수 있다. 일을 토픽별로 브랜치를 분리했다면 그동안 주 저장소의 master 브랜치가 수정돼서 깨끗하게 커밋하지 못하게 되어도 rebase로 적용할 수 있다. 그리고 토픽 브랜치를 새로 만들 때 앞서 Push한 토픽 브랜치에서 시작하지 말고 주 저장소의 master 브랜치로부터 만들어야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -b featureB origin/master
$ (work)
$ git commit
$ git push myfork featureB
$ (email maintainer)
$ git fetch origin&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그림 5-16 처럼 각 토픽은 일종의 실험실이라고 할 수 있다. 각 토픽은 서로 방해하지 않고 독립적으로 커밋을 수정하거나 Rebase할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0516-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-16. featureB 수정작업이 끝난 직후 저장소의 모습.&lt;/p&gt;

&lt;p&gt;프로젝트 관리자가 사람들의 수정사항을 Merge하고 나서 Jessica씨의 브랜치를 Merge하려고 할 때 충돌이 발생할 수도 있다. 그러면 Jessica씨가 자신의 브랜치를 origin/master에 Rebase해서 충돌을 해결하고 다시 Pull Request을 보낸다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 명령들을 실행하고 나면 그림 5-17과 같아진다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0517-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-17. FeatureA에 대한 Rebase가 적용된 후의 모습&lt;/p&gt;

&lt;p&gt;브랜치를 Rebase해 버렸기 때문에 Push할 때 -f 옵션을 주고 강제로 기존에 서버에 있던 브랜치의 내용을 덮어 써야 한다. 아니면 새로운 브랜치를(예를 들어 featureAv2) 서버에 Push해도 된다.&lt;/p&gt;

&lt;p&gt;또 다른 시나리오를 하나 더 살펴보자. 프로젝트 관리자가 featureB 브랜치의 내용은 좋지만, 상세 구현은 다르게 해보자고 한다. 그리고 하는 김에 featureB 브랜치를 프로젝트의 최신 master 브랜치 기반으로 옮겨 보고자 한다.&lt;/p&gt;

&lt;p&gt;origin/master 브랜치에서 featureBv2 브랜치를 새로 하나 만들고 나서 featureB 커밋들을 모두 Squash해서 Merge를 하고 충돌이 발생하면 해결해 놓는다. 그리고 상세 구현을 수정하고 나서 새 브랜치로 Push를 한다(역주 - squash는 여러 개의 커밋을 하나로 합치는 것이다, 자세한 것은 6장에서 설명한다):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -b featureBv2 origin/master
$ git merge --no-commit --squash featureB
$ (change implementation)
$ git commit
$ git push myfork featureBv2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#8211;squash 옵션은 현재 브랜치에 Merge할 때 해당 브랜치의 커밋을 모두 하나의 커밋으로 합쳐서 Merge시킨다. &amp;#8211;no-commit 옵션을 주면 Git은 Merge하고 나서 자동으로 커밋하지 않는다. 이를 통해 다른 브랜치의 수정사항을 통째로 새로운 브랜치에 Merge하고 좀 더 수정하고 나서 새로운 하나의 커밋으로 만들 수 있다.&lt;/p&gt;

&lt;p&gt;수정을 마치면 관리자에게 featureBv2 브랜치를 확인해 보라고 메시지를 보낸다 (그림 5-18 참고).&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0518-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-18. featureBv2 브랜치를 Commit한 이후 저장소의 모습.&lt;/p&gt;

&lt;h3 id='__'&gt;대규모 공개 프로젝트&lt;/h3&gt;

&lt;p&gt;대규모 프로젝트은 보통 수정사항이나 Patch를 수용하는 자신만의 규칙을 마련해놓고 있다. 프로젝트마다 규칙은 서로 다를 수 있으므로 각 프로젝트의 규칙을 미리 알아둘 필요가 있다. 대규모 프로젝트들은 대부분 메일링리스트를 통해서 Patch를 받아들이는데 여기에서 그 예를 통해 살펴본다.&lt;/p&gt;

&lt;p&gt;토픽 브랜치를 만들어 수정하는 작업은 앞서 살펴본 바와 거의 비슷하지만, Patch를 제출하는 방식이 다르다. 프로젝트를 Fork 하여 Push하는 것이 아니라 커밋 내용을 메일로 만들어 개발자 메일링리스트에 제출하는 것이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -b topicA
$ (work)
$ git commit
$ (work)
$ git commit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;커밋을 두 번 하고 메일링리스트에 보내 보자. &lt;code&gt;git format-patch&lt;/code&gt; 명령으로 메일링리스트에 보낼 mbox 형식의 파일을 생성할 수 있다. 각 커밋은 하나씩 메일 메시지로 생성되는데 커밋 메시지의 첫 번째 줄이 제목이 되고 Merge 메시지 내용과 Patch 자체가 메일 메시지의 본문이 된다. 이 방식의 좋은 점은 수신한 이메일에 들어 있는 Patch를 바로 적용할 수 있다는 것이다. 메일 속에는 커밋의 모든 내용이 포함돼 있다. 메일에 포함된 Patch를 적용하는 것은 다음 절에서 살펴본다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;format-patch 명령을 실행하면 생성한 파일들의 이름을 보여준다. -M 옵션은 이름이 변경된 파일이 있는지 살펴보라는 옵션이다. 각 파일의 내용은 다음과 같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat 0001-add-limit-to-log-function.patch 
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &amp;lt;jessica@example.com&amp;gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = &amp;#39;master&amp;#39;)
-    command(&amp;quot;git log #{treeish}&amp;quot;)
+    command(&amp;quot;git log -n 20 #{treeish}&amp;quot;)
   end

   def ls_tree(treeish = &amp;#39;master&amp;#39;)
-- 
1.6.2.rc1.20.g8c5b.dirty&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;메일링리스트에 메일을 보내기 전에 각 Patch 메일 파일의 내용을 손으로 고칠 수 있다. &amp;#8211; 줄과 Patch가 시작되는 줄(lib/simplegit.rb로 시작하는 줄) 사이에 내용을 추가하면 개발자는 읽을 수 있지만, 나중에 Patch에 적용되지는 않는다.&lt;/p&gt;

&lt;p&gt;특정 메일 프로그램을 사용하거나 이메일을 보내는 명령어로 메일링리스트에 보낼 수 있다. 위의 내용을 붙여 넣기 할 때 그대로 들어가지 않는 메일 프로그램도 있다. 그런 메일 프로그램은 사용자 편의를 위해 공백이나 줄 바꿈 문자 등을 넣어 준다.&lt;/p&gt;

&lt;p&gt;다행히 Git은 Patch 메일을 그대로 보낼 수 있는 도구가 있다. IMAP 프로토콜로 보내진다. 그 예로 저자가 사용하는 Gmail을 사용하여 Patch 메일을 전송하는 방법을 살펴보자. 추가로 Git 프로젝트의 &lt;code&gt;Docuementation/SubmittingPatches&lt;/code&gt; 문서의 마지막 부분을 살펴보면 다양한 메일 프로그램들로 메일을 보내는 방법을 살펴볼 수 있다.&lt;/p&gt;

&lt;p&gt;메일을 보내려면 먼저 ~/.gitconfig 파일에서 이메일 부분 설정을 해야 한다. &lt;code&gt;git config&lt;/code&gt; 명령으로도 추가할 수 있지만, 직접 파일을 열어서 수정하여 추가해 줄 수도 있다. 아무튼, 아래와 같이 설정을 해야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[imap]
  folder = &amp;quot;[Gmail]/Drafts&amp;quot;
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = p4ssw0rd
  port = 993
  sslverify = false&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IMAP 서버가 SSL을 사용하지 않으면 마지막 두 줄은 필요 없고 host 에서 &lt;code&gt;imaps://&lt;/code&gt; 대신 &lt;code&gt;imap://&lt;/code&gt;로 해준다. 이렇게 설정하고 나면 &lt;code&gt;git send-email&lt;/code&gt; 명령을 사용하여 메일을 전송할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith &amp;lt;jessica@example.com&amp;gt;] 
Email’s will be sent from: Jessica Smith &amp;lt;jessica@example.com&amp;gt;
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git이 메일을 보내면 아래와 같은 로그 메시지를 출력할 것이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(mbox) Adding cc: Jessica Smith &amp;lt;jessica@example.com&amp;gt; from 
  \line &amp;#39;From: Jessica Smith &amp;lt;jessica@example.com&amp;gt;&amp;#39;
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith &amp;lt;jessica@example.com&amp;gt;
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: &amp;lt;1243715356-61726-1-git-send-email-jessica@example.com&amp;gt;
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: &amp;lt;y&amp;gt;
References: &amp;lt;y&amp;gt;

Result: OK&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이후 Gmail의 Draft 폴더로 가서 To 부분을 메일링리스트의 주소로 변경하고 CC 부분에 해당 메일을 참고해야 하는 관리자나 개발자의 메일 주소를 적고 실제로 전송한다.&lt;/p&gt;

&lt;h3 id='id58'&gt;요약&lt;/h3&gt;

&lt;p&gt;이번 절에서는 Git을 사용하여 프로젝트를 운영하는 방법과 프로젝트에 기여할 때 필요한 도구들을 살펴보았다. 다음 절에서는 동전의 뒷면인 프로젝트를 운영하는 방법에 대하여 살펴볼 것이다. 즉 친절한 Dictator나 Integration-Manager가 되어 보는 것이다.&lt;/p&gt;

&lt;h2 id='_'&gt;프로젝트 운영하기&lt;/h2&gt;

&lt;p&gt;언젠가는 단순히 프로젝트에 기여하는 것이 아니라 프로젝트를 직접 운영해야 할 수도 있다. 그래서 효율적으로 기여하는 방법뿐만 아니라 효율적으로 운영하는 방법도 알아야 한다. 프로젝트를 운영하는 것은 크게 두 가지로 이루어져 있다. 하나는 format-patch 명령으로 생성한 Patch를 이메일로 받아서 프로젝트에 Patch하고 적용하는 것이다. 다른 하나는 프로젝트의 다른 원격 저장소로부터 변경 내용을 Merge하는 것이다. 저장소를 아주 깔끔하고 정돈된 상태로 운영하고 Patch를 적용하거나 수정사항을 확인하기 쉬운 상태를 유지하려면 좋은 운영 방식을 터득해야 한다. 다른 사람들이 이해하기 쉽고 프로젝트가 오랫동안 운영돼도 흐트러짐이 없도록 하는 것이 좋은 운영 방식이다.&lt;/p&gt;

&lt;h3 id='__'&gt;토픽 브랜치 작업&lt;/h3&gt;

&lt;p&gt;메인 브랜치에 통합하기 전에 임시로 토픽 브랜치를 하나 만들고 거기에 통합해 보고 나서 다시 메인 브랜치에 통합하는 것이 좋다. 이렇게 하면 Patch를 적용할 때 이리저리 수정해 보기도 하고 좀 더 고민해 봐야 하면 Patch를 적용해둔 채로 나중으로 미루기에도 좋다. 무슨 Patch인지 브랜치 이름에 간단히 적어주면 다른 작업을 하다가 나중에 이 브랜치로 돌아왔을 때 기억해내기 훨씬 수월하다. 프로젝트의 관리자라면 이런 토픽 브랜치의 이름을 잘 지어야 한다. 예를 들어 sc라는 사람이 작업한 Patch라면 &lt;code&gt;sc/ruby_client&lt;/code&gt; 처럼 앞에 닉네임을 붙여서 브랜치를 만들 수 있다. master 브랜치에서 새 토픽 브랜치를 다음과 같이 만든다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch sc/ruby_client master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;checkout -b&lt;/code&gt; 옵션으로 브랜치를 만들고 Checkout까지 한 번에 할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -b sc/ruby_client master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 토픽 브랜치를 만들고 Patch를 적용해보고 적용한 내용을 다시 긴 호흡 브랜치로 Merge한다.&lt;/p&gt;

&lt;h3 id='__patch_'&gt;이메일로 받은 Patch를 적용하기&lt;/h3&gt;

&lt;p&gt;이메일로 받은 Patch를 프로젝트에 적용해보기 전에 우선 토픽 브랜치에 Patch를 적용해 본다. Patch를 적용하는 방법은 &lt;code&gt;git apply&lt;/code&gt; 명령을 사용하는 것과 &lt;code&gt;git am&lt;/code&gt; 명령을 사용하는 것 두 가지가 있다.&lt;/p&gt;

&lt;h4 id='apply___'&gt;apply 명령을 사용하는 방법&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;git diff&lt;/code&gt;나 Unix의 diff 명령으로 만든 Patch파일을 적용할 때에는 &lt;code&gt;git apply&lt;/code&gt; 명령을 사용한다. Patch 파일이 &lt;code&gt;/tmp/patch-ruby-client.patch&lt;/code&gt;라고 하면 다음과 같은 명령으로 Patch를 적용할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git apply /tmp/patch-ruby-client.patch&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 명령을 실행하면 Patch 파일 내용에 따라 현재 디렉토리의 파일들을 변경한다. 위 명령은 &lt;code&gt;patch -p1&lt;/code&gt; 명령과 거의 같다. 하지만, 이 명령이 patch 명령보다 훨씬 더 꼼꼼하게 비교한다. &lt;code&gt;git diff&lt;/code&gt;로 생성한 Patch 파일에 파일을 추가하거나, 파일을 삭제하고, 파일의 이름을 변경하는 내용이 들어 있으면 그대로 적용된다. 이런 것은 patch 명령으로 할 수 없다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;code&gt;git apply&lt;/code&gt;는 &amp;#8220;모두 적용, 아니면 모두 취소&amp;#8221; 모델을 사용하기 때문에 Patch를 적용하는 데 실패하면 Patch를 적용하기 이전 상태로 전부 되돌려 놓는다. Patch 명령은 여러 파일에 적용하다가 중간에 실패하면 거기서 그대로 중단하기 때문에 깔끔하지 못하다. &lt;code&gt;git apply&lt;/code&gt;는 Patch보다 훨씬 결벽증 적이다. 명령을 실행하고 나면 자동으로 커밋해 주지 않기 때문에 변경된 파일들을 직접 Stage 영역에 추가하고 커밋해야 한다.&lt;/p&gt;

&lt;p&gt;실제로 Patch를 적용해보기 전에 Patch가 잘 적용될지 한 번 시험해보려면 &lt;code&gt;git apply --check&lt;/code&gt; 명령을 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git apply --check 0001-seeing-if-this-helps-the-gem.patch 
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;화면에 아무런 내용도 뜨지 않으면 Patch가 깔끔하게 적용될 수 있다는 것이다. Patch를 적용해 보고 에러가 발생하면 이 명령은 0이 아닌 값을 반환하기 때문에 쉘 스크립트에서도 사용할 수 있다.&lt;/p&gt;

&lt;h4 id='am___'&gt;am 명령을 사용하는 방법&lt;/h4&gt;

&lt;p&gt;프로젝트 기여자가 Git의 format-patch 명령을 잘 사용하면 경우 관리자의 작업은 훨씬 쉬워진다. format-patch 명령으로 만든 Patch 파일은 기여자의 정보와 커밋 정보가 포함되어 있기 때문이다. 그래서 기여자가 diff보다 format-patch를 사용하도록 권해야 한다. &lt;code&gt;git apply&lt;/code&gt;는 기존의 Patch파일에만 사용한다.&lt;/p&gt;

&lt;p&gt;format-patch 명령으로 생성한 Patch 파일은 &lt;code&gt;git am&lt;/code&gt; 명령으로 적용한다. &lt;code&gt;git am&lt;/code&gt;은 여러 통의 메일이 들어 있는 mbox파일을 읽어서 Patch한다. mbox파일은 간단한 텍스트 파일이고 그 내용은 다음과 같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &amp;lt;jessica@example.com&amp;gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 내용은 format-patch 명령으로 생성한 파일의 앞부분이다. 이 파일은 mbox 형식이다. 받은 메일이 &lt;code&gt;git send-email&lt;/code&gt;로 만든 메일이라면 mbox 형식으로 저장하고 이 mbox 파일을 &lt;code&gt;git am&lt;/code&gt; 명령으로 Patch를 적용한다. 사용하는 메일 클라이언트가 여러 메일을 하나의 mbox 파일로 저장할 수 있다면 메일 여러 개를 한 번에 Patch할 수 있다.&lt;/p&gt;

&lt;p&gt;이메일로 받은 것이 아니라 이슈 트래킹 시스템 같은데 올라온 파일이라면 먼저 내려받고서 &lt;code&gt;git am&lt;/code&gt; 명령으로 Patch한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git am 0001-limit-log-function.patch 
Applying: add limit to log function&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Patch가 성공하면 자동으로 새로운 커밋이 하나 만들어진다. Patch 파일에 들어 있는 기여자의 이메일, 작성시간, 커밋 메시지를 뽑아서 커밋에 함께 저장한다. 예를 들어 위의 mbox 예제 파일을 적용해서 생성되는 커밋은 다음과 같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --pretty=fuller -1
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Author:     Jessica Smith &amp;lt;jessica@example.com&amp;gt;
AuthorDate: Sun Apr 6 10:17:23 2008 -0700
Commit:     Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
CommitDate: Thu Apr 9 09:19:06 2009 -0700

   add limit to log function

   Limit log functionality to the first 20&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Commit 정보를 보면 누가 언제 Patch했는 지 알 수 있다. Author 정보를 보면 실제로 누가 언제 Patch파일을 만들었는지 알 수 있다.&lt;/p&gt;

&lt;p&gt;Patch에 실패할 수도 있다. 보통 Patch가 생성된 시점보다 해당 브랜치가 너무 업데이트 됐을 때이거나 아직 적용되지 않은 다른 Patch가 필요한 경우에 일어난다. 이러면 &lt;code&gt;git am&lt;/code&gt; 명령은 Patch를 중단하고 사용자에게 어떻게 처리할지 물어온다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git am 0001-seeing-if-this-helps-the-gem.patch 
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Patch failed at 0001.
When you have resolved this problem run &amp;quot;git am --resolved&amp;quot;.
  (충돌을 해결하면 &amp;quot;git am --resolved&amp;quot; 입력)
If you would prefer to skip this patch, instead run &amp;quot;git am --skip&amp;quot;.
  (Patch 적용을 생략하려면 &amp;quot;git am --skip&amp;quot; 입력)
To restore the original branch and stop patching run &amp;quot;git am --abort&amp;quot;.
  (Patch 적용을 중단하려면 &amp;quot;git am --abort&amp;quot; 입력)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;성공적으로 Patch하지 못하면 git은 Merge나 Rebase의 경우처럼 문제를 일으킨 파일에 충돌 표시를 해 놓는다. Merge나 Rebase할 때 충돌을 해결하는 것처럼 Patch의 충돌도 해결할 수 있다. 충돌한 파일을 열어서 충돌 부분을 수정하고 나서 Stage 영역에 추가하고 &lt;code&gt;git am --resolved&lt;/code&gt; 명령을 입력한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ (fix the file)
$ git add ticgit.gemspec 
$ git am --resolved
Applying: seeing if this helps the gem&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;충돌이 났을 때 Git에게 좀 더 머리를 써서 Patch를 적용하도록 하려면 -3 옵션을 사용한다. 이 옵션은 Git에게 3-way Patch를 적용해 보라고 하는 것이다. Patch가 저장소의 어느 시점에도 기반을 두지 않을 수 있기 때문에 이 옵션은 기본적으로 비활성화돼 있다. 하지만, 같은 프로젝트의 커밋이라면 기본옵션보다 훨씬 똑똑하게 충돌 상황을 해결해 준다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git am -3 0001-seeing-if-this-helps-the-gem.patch 
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
No changes -- Patch already applied.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 경우는 이미 Patch한 것을 다시 Patch하는 상황이다. -3 옵션이 없었으면 충돌을 알아서 해결하지 못했을 것이다.&lt;/p&gt;

&lt;p&gt;하나의 mbox 파일에 들어 있는 여러 Patch를 적용할 때 대화형 방식을 사용할 수 있다. 이 방식을 사용하면 각 Patch를 적용하기 전에 Patch를 적용할지 물어올 것이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git am -3 -i mbox
Commit Body is:
--------------------------
seeing if this helps the gem
--------------------------
Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 옵션은 Patch를 여러 개 적용할 때 유용하다. 적용하려는 Patch의 내용을 미리 꼭 기억해두지 않아도 되고 적용하기 전에 이미 적용된 Patch인지 알 수 있다.&lt;/p&gt;

&lt;p&gt;모든 Patch를 토픽 브랜치에 적용하고 커밋까지 마치고 나면 긴 호흡 브랜치에 어떻게 통합할지를 결정할 차례다.&lt;/p&gt;

&lt;h3 id='__'&gt;원격 브랜치로부터 통합하기&lt;/h3&gt;

&lt;p&gt;프로젝트 기여자가 자신의 저장소를 만들고 커밋을 여러 번 한 후에 저장소의 URL과 변경 내용을 메일로 보내왔다면 URL을 원격 저장소로 등록하고 Merge할 수 있다.&lt;/p&gt;

&lt;p&gt;예를 들어 Jessica씨는 ruby-client 브랜치에 엄청난 기능을 만들어 놨다고 메일을 보내왔다. 이 원격 브랜치를 등록하고 Checkout해서 테스트를 해 보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote add jessica git://github.com/jessica/myproject.git
$ git fetch jessica
$ git checkout -b rubyclient jessica/ruby-client&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;후에 Jessiaca씨가 이메일로 또 다른 엄청난 기능을 개발한 브랜치를 보내오면 이미 저장소를 등록해놨기 때문에 간단히 Fetch하고 Checkout할 수 있다.&lt;/p&gt;

&lt;p&gt;다른 개발자들과 함께 지속적으로 개발할 때는 이런 방식이 가장 사용하기 좋다. 물론 기여하는 사람이 간단한 Patch를 이따금씩만 만들어 내면 이메일로 Patch 파일을 받는 것이 낫다. 기여자가 저장소 서버를 만들어 커밋하고 관리자가 리모트 저장소로 등록해서 Patch를 가져와서 합치는 작업보다 시간과 노력이 덜 든다. 물론 Patch 한두 개를 보내는 사람들까지도 모두 원격 저장소로 등록해서 사용할 수도 있다. 스크립트나 호스팅 서비스를 사용하면 좀 더 쉽게 관리할 수 있다. 어쨌든 어떤 방식이 좋을지는 우리가 어떻게 개발할지와 어떻게 기여할지에 달렸다.&lt;/p&gt;

&lt;p&gt;원격 저장소로 등록하는 것의 또 다른 장점은 커밋의 히스토리를 알 수 있다는 것이다. Merge하는 시점에 항상 커밋이 시작된 지점을 알 수 있기 때문에 -3 옵션을 주지 않아도 자동으로 3-way Merge가 적용된다.&lt;/p&gt;

&lt;p&gt;계속 함께 일할 개발자가 아닐 때 사용하는 방법으로 원격 저장소를 등록하지 않고도 Merge할 수 있다. 아래는 원격 저장소로 등록하지 않고 URL을 직접 사용하여 Merge를 하는 예이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git pull git://github.com/onetimeguy/project.git
From git://github.com/onetimeguy/project
 * branch            HEAD       -&amp;gt; FETCH_HEAD
Merge made by recursive.&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='__'&gt;기여한 사항 확인하기&lt;/h3&gt;

&lt;p&gt;이번 절에서는 다른 기여자들의 커밋을 토픽 브랜치에 Merge해놓고 사용하는 Git 명령을 살펴보고 각 커밋을 어떻게 효율적으로 리뷰하고 메인 브랜치에 Merge하는 지 살펴본다.&lt;/p&gt;

&lt;p&gt;먼저 지금 작업하는 브랜치에서 master 브랜치에 속하지 않는 커밋만 살펴보는 것이 좋다. 히스토리에서 master 브랜치에 속한 커밋을 제외하고 살펴보려면 &amp;#8211;not 옵션을 사용한다. 예를 들어 contrib 브랜치에 Patch를 두 개 Merge했다면 아래와 같은 명령어로 그 결과를 살펴볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log contrib --not master
commit 5b6235bd297351589efc4d73316f0a68d484f118
Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
Date:   Fri Oct 24 09:53:59 2008 -0700

    seeing if this helps the gem

commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
Date:   Mon Oct 22 19:38:36 2008 -0700

    updated the gemspec to hopefully work better&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git log&lt;/code&gt; 명령에 -p 옵션을 주면 각 커밋에서 실제로 무슨 내용이 변경됐는지 살펴볼 수 있다. 이 옵션은 각 commit의 뒤에 diff의 내용을 출력해 준다.&lt;/p&gt;

&lt;p&gt;현재의 토픽 브랜치를 다른 브랜치에 Merge하면 어떤 부분이 변경되는지 미리 살펴볼 수 있다. 이때는 색다른 명령을 사용해야 한다. 물론 아래와 같은 명령을 사용할 수도 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 diff 내용을 보여주긴 하지만 오해를 불러올 수 있다. 토픽 브랜치에서 작업하는 동안 master 브랜치에 새로운 커밋이 좀 더 추가됐을 수 있기 때문에 기대하는 diff 결과가 아닐 수 있다. Git은 각 브랜치의 마지막 Snapshot을 비교하기 때문에 원하는 결과가 아니다. 예를 들어 master 브랜치에 한 줄을 추가하면 이 명령은 결과를 비교하기 때문에 토픽 브랜치에서 추가한 줄이 삭제된 것으로 보여 준다.&lt;/p&gt;

&lt;p&gt;master 브랜치가 가리키는 커밋이 토픽 브랜치의 조상이라면 아무 문제 없다. 하지만, 그렇지 않은 경우라면 이 diff 도구는 토픽 브랜치의 내용은 추가하는 것이고 master 브랜치에만 있는 내용은 삭제하려는 것으로 간주한다.&lt;/p&gt;

&lt;p&gt;정말 보고 싶은 것은 토픽 브랜치에 추가한 것이고 이것을 master 브랜치에 추가하려는 것이다. 그러니까 master 브랜치와 토픽 브랜치의 공통 조상인 커밋과 토픽 브랜치가 현재 가리키는 커밋을 비교해야 한다.&lt;/p&gt;

&lt;p&gt;다음과 같은 명령으로 공통 조상인 커밋을 찾고 이 조상 커밋에서 변경된 내용을 살펴본다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git merge-base contrib master
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
$ git diff 36c7db &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 방법으로 원하는 결과를 얻을 수 있지만, 사용법이 불편하다. Git은 Triple-Dot으로 간단하게 위와 같이 비교하는 방법을 지원한다. diff 명령을 사용할 때 두 브랜치 사이에 &amp;#8230;를 한쪽 브랜치에만 있는 것을 살펴볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff master...contrib&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 master 브랜치로부터 현재 토픽 브랜치의 다른 것들만 보여주기 때문에 기억해두면 매우 유용하게 사용할 수 있을 것이다.&lt;/p&gt;

&lt;h3 id='_'&gt;기여물 통합하기&lt;/h3&gt;

&lt;p&gt;기여물을 토픽 브랜치에 적용을 다 하고 긴 호흡의 브랜치나 master 브랜치로 통합할 준비가 되었다면 이제 어떻게 해야 할까? 프로젝트를 운영하는 데 쓸 수 있는 일반적인 작업 방식은 어떤 것이 있을까? 앞으로 그 예제 몇 가지를 살펴볼 것이다.&lt;/p&gt;

&lt;h4 id='merge_workflow'&gt;Merge Workflow&lt;/h4&gt;

&lt;p&gt;바로 master 브랜치에 Merge하는 것이 가장 간단하다. 이 Workflow에서는 master 브랜치가 안전한 코드라고 가정해야 한다. 토픽 브랜치를 검증하고 master 브랜치로 Merge할 때마다 토픽 브랜치를 삭제한다. 그림 5-19처럼 &lt;code&gt;ruby_client&lt;/code&gt; 브랜치와 &lt;code&gt;php_client&lt;/code&gt; 브랜치가 있을 때 &lt;code&gt;ruby_client&lt;/code&gt; 브랜치를 master 브랜치로 Merge한 후 &lt;code&gt;php_client&lt;/code&gt; 브랜치를 Merge하면 그림 5-20과 같아진다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0519-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-19. 저장소의 두 브랜치.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0520-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-20. Merge한 후의 저장소.&lt;/p&gt;

&lt;p&gt;이 Workflow은 간단하지만, 프로젝트의 규모가 커지면 문제가 생길 수 있다.&lt;/p&gt;

&lt;p&gt;개발자가 많고 규모가 큰 프로젝트에서는 두 단계로 Merge하는 것이 좋다. 그래서 긴 호흡 브랜치를 두 개로 유지해야 한다. master 브랜치는 아주 안정적인 버전을 Release하기 위해서 사용하고 develop 브랜치는 새로 수정된 코드들을 통합할 때 사용한다. 그리고 두 브랜치를 모두 저장소에 Push한다. 우선 develop 브랜치에 토픽 브랜치(그림 5-21)를 그림 5-22과 같이 Merge한다. 그 후에 Release해도 될만한 수준이 되면 master 브랜치를 develop 브랜치까지 Fast-forward시킨다(그림 5-23).&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0521-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-21. 토픽 브랜치를 Merge하기 전.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0522-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-22. 토픽 브랜치를 Merge한 후.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0523-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-23. 토픽 브랜치를 Release한 후.&lt;/p&gt;

&lt;p&gt;이 Workflow을 사용하면 개발자들은 프로젝트 저장소를 Clone하고 나서 안정 버전이 필요할 때에는 master 브랜치를 빌드하고 안정적이지 않더라도 좀 더 최신 버전이 필요할 때에는 develop 브랜치를 Checkout하여 빌드할 수 있다. 이 개념을 좀 더 확장해서 토픽 브랜치를 검증하기 위한 integrate 브랜치를 만들어 Merge하고 토픽 브랜치가 검증되면 develop 브랜치에 머지한다. 그리고 develop 브랜치에서 충분히 안정하다는 것이 증명되면 그때 master 브랜치에 Merge한다.&lt;/p&gt;

&lt;h4 id='_merge_workflow'&gt;대규모 Merge Workflow&lt;/h4&gt;

&lt;p&gt;Git을 개발하는 프로젝트는 긴 호흡의 브랜치를 4개 운영한다. 각 브랜치 이름은 master, next, pu (Proposed Updates), maint 이다. maint는 마지막으로 Release한 버전을 지원하기 위한 브랜치이다. 기여자들이 새로운 기능을 제안하면 관리자는 그림 5-24처럼 자신의 저장소에 토픽 브랜치를 만들어 관리한다. 그리고 각 토픽이 부족한 점이 없는지 안정적인지 계속 테스트한다. 안정화되면 next로 Merge하고 저장소에 Push한다. 그러면 모두가 잘 통합됐는지 확인할 수 있게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0524-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-24. 토픽 브랜치를 동시에 여러 개 관리하는 것은 복잡하다.&lt;/p&gt;

&lt;p&gt;토픽 브랜치가 좀 더 개선돼야 하면 next가 아니라 pu에 Merge한다. 그 후에 충분히 검증을 마치면 pu에서 next로 옮기고 next를 기반으로 pu를 다시 만든다. next에는 아직 master에 넣기에 모자라 보이는 것들이 들어 있다. 즉 next 브랜치는 정말 가끔 Rebase하고 pu는 자주 Rebase하지만 master는 항상 Fast-forward한다(그림 5-25).&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0525-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-25. 토픽 브랜치를 긴 호흡의 통합 브랜치로 Merge하기.&lt;/p&gt;

&lt;p&gt;토픽 브랜치가 결국 master 브랜치로 Merge되면 저장소에서 결국 삭제된다. 그리고 이전 Release 버전에 Patch가 필요하면 maint 브랜치를 이용해 대응한다. Git을 개발하는 프로젝트를 Clone하면 브랜치가 4개 있고 각 브랜치를 이용하여 진행사항을 확인해볼 수 있다. 그래서 새로운 기능을 추가하려면 적당한 브랜치를 보고 고르면 된다. 이 Workflow는 잘 구조화돼 있어서 코드가 새로 추가돼도 테스트하기 쉽다.&lt;/p&gt;

&lt;h4 id='rebase_cherrypick_workflow'&gt;Rebase와 Cherry-Pick Workflow&lt;/h4&gt;

&lt;p&gt;히스토리를 평평하게 관리하기 위해 Merge보다 Rebase나 Cherry-Pick을 더 선호하는 관리자들도 있다. 토픽 브랜치에서 작업을 마친 후 master에 통합하려면 master 브랜치 기반으로 Rebase해서 커밋을 다시 만든다. master 대신 develop 등의 브랜치에도 가능하다. 문제가 없으면 master 브랜치를 Fast-forward시킨다. 이렇게 평평한 히스토리를 유지할 수 있다.&lt;/p&gt;

&lt;p&gt;한 브랜치에서 다른 브랜치로 작업한 내용을 옮기는 또 다른 방식으로 Cherry-pick이란 것도 있다. Git의 Cherry-pick은 하나의 커밋만 Rebase하는 것이다. 하나의 커밋에서 Patch 내용을 만들어 현재 브랜치에 적용을 하는 것이다. 토픽 브랜치에 있는 커밋중에서 하나만 고르거나 토픽 브랜치에 커밋이 하나밖에 없을 때 Rebase보다 유용하다. 그림 5-26의 예를 들어보자.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0526-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-26. Cherry-pick을 실행하기 전의 저장소.&lt;/p&gt;

&lt;p&gt;e43a6 커밋 하나만 현재 브랜치에 적용하려면 다음과 같은 명령을 실행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf
Finished one cherry-pick.
[master]: created a0a41a9: &amp;quot;More friendly message when locking the index fails.&amp;quot;
 3 files changed, 17 insertions(+), 3 deletions(-)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 명령을 실행하면 e43a6 커밋에서 변경된 내용을 현재 브랜치에 똑같이 적용을 한다. 하지만, 변경을 적용한 시점이 다르므로 새 커밋의 SHA-1 해시 값은 달라진다. 명령을 실행하고 나면 그림 5-27과 같이 될 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0527-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 5-27. Cherry-pick 방식으로 커밋 하나를 적용한 후의 저장소.&lt;/p&gt;

&lt;p&gt;Rebase나 Cherry-pick 방식으로 토픽 브랜치의 내용을 합치고 나면, 필요없는 토픽 브랜치나 커밋을 삭제한다.&lt;/p&gt;

&lt;h3 id='release__tag_'&gt;Release 버전에 Tag 달기&lt;/h3&gt;

&lt;p&gt;적당한 때가 되면 Release를 해야 하고 언제든지 그 시점으로 되돌릴 수 있게 태그를 달아 놓는 것이 좋다. 2장에서 살펴본 대로 태그를 달면 되고 서명된 태그를 달면 다음과 같이 출력될 것이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag -s v1.5 -m &amp;#39;my signed 1.5 tag&amp;#39;
You need a passphrase to unlock the secret key for
user: &amp;quot;Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;&amp;quot;
1024-bit DSA key, ID F721C45A, created 2009-02-09&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;태그에 서명하면 서명에 사용한 PGP 공개키도 Release 해야 한다. Git 개발 프로젝트는 관리자의 PGP 공개키를 Blob 형식으로 Git 저장소에 함께 Release하고 이 Blob파일을 사용하여 태그에 서명했다. 다음과 같은 명령으로 어떤 PGP 공개키를 포함할지 확인한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
uid                  Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git hash-object&lt;/code&gt;라는 명령으로 공개키를 바로 Git 저장소에 넣을 수 있다. 이 명령은 Git 저장소 안에 Blob 형식으로 공개키를 저장해주고 그 Blob의 SHA-1 값을 알려준다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gpg -a --export F721C45A | git hash-object -w --stdin
659ef797d181633c87ec71ac3f9ba29fe5775b92&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 SHA-1 해시 값으로 PGP 공개키를 가리키는 태그를 만들 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git push --tags&lt;/code&gt; 명령으로 앞서 만든 maintainer-pgp-pub 태그를 공유할 수 있다. 다른 사람이 태그의 서명을 확인하려면 우선 Git 저장소에 저장된 PGP 공개키를 꺼내서 GPG키 데이터베이스에 저장해야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git show maintainer-pgp-pub | gpg --import&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;사람들은 이렇게 공개키를 얻어서 서명된 태그를 확인할 수 있다. 또한, 관리자가 태그 메시지에 서명을 확인하는 방법을 적어 놓으면 사람들은 &lt;code&gt;git show &amp;lt;tag&amp;gt;&amp;#39;으로 어떻게 서명된 태그를 확인해야 하는지 알 수 있다.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id='_'&gt;빌드넘버 만들기&lt;/h3&gt;

&lt;p&gt;Git은 &amp;#8216;v123&amp;#8217; 처럼 숫자 형태로 커밋 이름을 만들지 않기 때문에 사람이 이해하기가 쉽지 않다. 하지만 &lt;code&gt;git describe&lt;/code&gt; 명령으로 좀 더 사람이 기억하기 쉬운 이름을 얻을 수 있다. Git은 가장 가까운 태그의 이름과 태그에서 얼마나 더 커밋이 쌓였는지 그리고 해당 커밋의 SHA-1 값을 조금 가져다가 이름을 만든다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git describe master
v1.6.2-rc1-20-g8c5b85c&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 사람이 읽을 수 있는 이름으로 Snapshot이나 Build를 만들 수 있다. 만약 저장소에서 Clone한 후 소스코드로 Git을 설치하면 &lt;code&gt;git --version&lt;/code&gt; 명령은 이렇게 생긴 빌드넘버를 보여준다. Tag가 달린 커밋에 &lt;code&gt;git describe&lt;/code&gt;명령을 사용하면 다른 정보 없이 Tag 이름만 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git describe&lt;/code&gt; 명령은 -a나 -s 옵션을 주고 만든 Annotated Tag가 필요하다. Release Tag는 &lt;code&gt;git describe&lt;/code&gt;명령으로 만드는 것이기 때문에 꼭 이름이 적당한지 사전에 확인해야 한다. 그리고 이 값은 Checkout이나 Show 명령에도 사용할 수 있지만, 전적으로 이름 뒤에 붙은 SHA-1 값을 사용하는 것이다. 그래서 이 값으로는 커밋을 못 찾을 수도 있다. 최근 Linux Kernel은 충돌 때문에 축약된 SHA-1를 8자에서 10자로 늘렸다. 이제는 8자일 때 생성한 값은 사용할 수 없다.&lt;/p&gt;

&lt;h3 id='release_'&gt;Release 준비하기&lt;/h3&gt;

&lt;p&gt;먼저 Git을 사용하지 않는 사람을 위해 소스코드의 Snopshot을 압축한다. 쉽게 압축할 수 있도록 Git은 &lt;code&gt;git archive&lt;/code&gt; 명령을 지원한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git archive master --prefix=&amp;#39;project/&amp;#39; | gzip &amp;gt; `git describe master`.tar.gz
$ ls *.tar.gz
v1.6.2-rc1-20-g8c5b85c.tar.gz&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 압축 파일을 풀면 프로젝트의 가장 마지막 Snapshot이 나온다. ZIP 형식으로 압축파일을 만들려면 &lt;code&gt;--format=zip&lt;/code&gt; 옵션을 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git archive master --prefix=&amp;#39;project/&amp;#39; --format=zip &amp;gt; `git describe master`.zip&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 압축한 Snapshot 파일은 Website나 이메일로 사람들에게 배포할 수 있다.&lt;/p&gt;

&lt;h3 id='shortlog_'&gt;Shortlog 보기&lt;/h3&gt;

&lt;p&gt;이메일로 프로젝트의 변경 사항을 사람들에게 알려야 할 때, &lt;code&gt;git shortlog&lt;/code&gt; 명령을 사용하면 지난 릴리즈 이후의 변경 사항의 목록을 쉽게 얻어올 수 있다. &lt;code&gt;git shortlog&lt;/code&gt; 명령은 주어진 범위에 있는 커밋들을 요약해준다. 아래는 최근 릴리즈 버전인 v1.0.1 이후의 커밋들을 요약해 주는 예제이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git shortlog --no-merges master --not v1.0.1
Chris Wanstrath (8):
      Add support for annotated tags to Grit::Tag
      Add packed-refs annotated tag support.
      Add Grit::Commit#to_patch
      Update version and History.txt
      Remove stray `puts`
      Make ls_tree ignore nils

Tom Preston-Werner (4):
      fix dates in history
      dynamic version method
      Version bump to 1.0.2
      Regenerated gemspec for version 1.0.2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 Author를 기준으로 정리한 커밋들을 이메일로 전송한다.&lt;/p&gt;

&lt;h2 id='id59'&gt;요약&lt;/h2&gt;

&lt;p&gt;이제 Git 프로젝트에 기여하고, 자신의 프로젝트를 운영하고, 다른 사람이 기여한 내용을 통합하는 것 정도는 쉽게 할 수 있을 것이다. 일단 쓸만한 Git 개발자가 된 것을 축하한다. 다음 장에서 복잡한 상황을 다루는 방법과 강력한 도구들을 배우고 나면 Git 장인이라고 불릴 수 있을 것이다.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Pro Git - 4. Git 서버</title>
   <link href="http://ygpark.github.com/Pro Git/2012/08/29/pro-git-4-git-server"/>
   <updated>2012-08-29T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Pro Git/2012/08/29/pro-git-4-git-server</id>
   <content type="html">&lt;h1 id='git_'&gt;Git 서버&lt;/h1&gt;

&lt;p&gt;이 글을 읽는 독자라면 이미 Git으로 하루 중 대부분 업무를 처리할 수 있을 것이다. 그러나 이제는 다른 사람과 협업하는 방법을 고민할 차례다. 다른 사람과 협업하려면 원격 저장소가 필요하다. 물론 혼자서 저장소를 만들고 거기에 Push하고 Pull할 수도 있지만 이렇게 하는 것은 아무 의미가 없다. 이렇게 하면 항상 집중하고 있어야 다른 사람이 무슨 일을 하고 있는지 간신히 알 수 있을 것이다. 당신 컴퓨터가 오프라인일 때에도 동료가 저장소를 사용할 수 있도록 언제나 이용할 수 있는 저장소가 필요하다. 즉, 공동으로 사용할 수 있는 저장소를 만들고 모두 이 저장소에 접근하여 Push, Pull할 수 있어야 한다. 우리는 이 저장소를 &amp;#8220;Git 서버&amp;#8221;라고 부른다. Git 저장소를 운영하는데 많은 자원이 필요한 것이 아녀서 별도로 Git 서버를 준비하지 않아도 된다.&lt;/p&gt;

&lt;p&gt;Git 서버를 운영하는 것은 어렵지 않다. 우선 사용할 전송 프로토콜부터 정한다. 이 장의 앞부분에서는 어떤 프로토콜이 있는지 그리고 각 장단점은 무엇인지 살펴볼 것이다. 그다음엔 각 프로토콜을 사용하는 방법과 그 프로토콜을 사용할 수 있도록 서버를 구성하는 방법을 살펴볼 것이다. 마지막으로 다른 사람의 서버에 내 코드를 맡기긴 싫고 고생스럽게 서버를 설치하고 관리하고 싶지도 않을 때 고를 수 있는 선택지가 어떤 것들이 있는지 살펴볼 것이다.&lt;/p&gt;

&lt;p&gt;서버를 직접 설치해서 운영할 생각이 없으면 이 장의 마지막 절만 읽어도 된다. 마지막 절에서는 Git 호스팅 서비스에 계정을 만들고 사용하는 방법에 대해 설명한다. 그리고 다음 장에서는 분산 환경에서 소스를 관리하는 다양한 패턴에 대해 논의할 것이다.&lt;/p&gt;

&lt;p&gt;원격 저장소는 일반적으로 Working Directory가 없는 &lt;em&gt;Bare 저장소&lt;/em&gt; 이다. 이 저장소는 협업용이기 때문에 체크아웃이 필요 없다. 그냥 Git 데이터만 있으면 된다. 다시 말해서 Bare 저장소는 일반 프로젝트에서 &lt;code&gt;.git&lt;/code&gt; 디렉토리만 있는 저장소다.&lt;/p&gt;

&lt;h2 id='id46'&gt;프로토콜&lt;/h2&gt;

&lt;p&gt;Git은 Local, SSH, Git, HTTP 이렇게 네 가지의 네트워크 프로토콜을 사용할 수 있다. 이 절에서는 각각 어떤 경우에 유용한지 살펴볼 것이다.&lt;/p&gt;

&lt;p&gt;HTTP 프로토콜를 제외한 나머지들은 모두 Git이 서버에 설치돼 있어야 한다.&lt;/p&gt;

&lt;h3 id='_'&gt;로컬 프로토콜&lt;/h3&gt;

&lt;p&gt;가장 기본적인 것이 &lt;em&gt;로컬 프로토콜&lt;/em&gt; 이다. 원격 저장소가 단순히 디스크의 다른 디렉토리에 있을 때 사용한다. 팀원들이 전부 한 시스템에 로그인하여 개발하거나 아니면 NFS같은 것으로 파일시스템을 공유하고 있을 때 사용한다. 전자는 문제가 될 수 있다. 모든 저장소가 한 시스템에 있기 때문에 한순간에 찌질해질 수 있다.&lt;/p&gt;

&lt;p&gt;공유 파일시스템을 마운트했을 때는 로컬 저장소를 사용하는 것처럼 Clone하고 Push하고 Pull하면 된다. 일단 저장소를 Clone하거나 프로젝트에 원격 저장소로 추가한다. 추가할 때 URL 자리에 저장소의 경로를 사용한다. 예를 들어 다음과 같이 로컬 저장소를 Clone할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone /opt/git/project.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음처럼도 가능하다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone file:///opt/git/project.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git은 파일 경로를 직접 쓸 때와 &lt;code&gt;file://&lt;/code&gt;로 시작하는 URL을 사용할 때에 약간 다르게 처리한다. 디렉토리 경로를 그대로 사용하면 Git은 필요한 파일을 직접 복사하거나 하드 링크를 사용한다. 하지만 &lt;code&gt;file://&lt;/code&gt;로 시작하면 Git은 네트워크를 통해서 데이터를 전송할 때처럼 프로세스를 별도로 생성하여 처리한다. 이 프로세스로 데이터를 전송하는 것은 효율이 좀 떨어지지만 그래도 &lt;code&gt;file://&lt;/code&gt;를 사용하는 이유가 있다. 이것은 외부 참조나 개체들이 포함된 저장소의 복사본을 깨끗한 상태로 남겨두고자 함이다. 보통은 다른 버전 관리 시스템들에서 임포트한 후에 사용한다(9장에서 자세히 다룬다). 여기서는 속도가 빠른 디렉토리 경로를 사용할 것이다.&lt;/p&gt;

&lt;p&gt;이미 가진 Git 프로젝트에는 다음과 같이 로컬 저장소를 추가한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote add local_proj /opt/git/project.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그러면 네트워크에 있는 원격 저장소처럼 Push하거나 Pull할 수 있다.&lt;/p&gt;

&lt;h4 id='id47'&gt;장점&lt;/h4&gt;

&lt;p&gt;파일 기반 저장소의 장점은 간단하다는 것이다. 기존에 있던 네트워크나 파일의 권한을 그대로 사용하기 때문에 설정하기 쉽다. 이미 팀 전체가 접근할 수 있는 파일시스템을 가지고 있다면 저장소를 아주 쉽게 구성할 수 있다. 다른 디렉토리를 공유할 때처럼 모든 동료가 읽고 쓸 수 있는 공유 디렉토리에 Bare 저장소를 만들면 된다. 다음 절인 &amp;#8220;서버에 Git 설치하기&amp;#8221;에서 Bare 저장소를 만드는 방법을 살펴볼 것이다.&lt;/p&gt;

&lt;p&gt;또한, 동료가 작업하는 저장소에서 한 일을 바로 가져오기에도 좋다. 만약 함께 프로젝트를 하는 동료가 자신이 한 일을 당신이 확인해 줬으면 한다. 이럴 때 그 동료가 서버에 Push하고 당신이 다시 Pull할 필요없이 &lt;code&gt;git pull /home/john/project&lt;/code&gt; 처럼 명령어를 실행시켜서 매우 쉽게 동료의 코드를 가져올 수 있다.&lt;/p&gt;

&lt;h4 id='id48'&gt;단점&lt;/h4&gt;

&lt;p&gt;다양한 상황에서 접근할 수 있도록 디렉토리를 공유하는 것 자체가 일반적으로 어렵다. 집에 있을 때 Push해야 하면 원격 저장소가 있는 디스크를 마운트해야 하는데 이것은 다른 프로토콜을 이용하는 방법보다 느리고 어렵다.&lt;/p&gt;

&lt;p&gt;게다가 파일시스템을 마운트해서 사용하는 중이라면 별로 빠르지도 않다. 로컬 저장소는 데이터를 빠르게 읽을 수 있을 때만 빠르다. NFS에 있는 저장소에 Git을 사용하는 것은 보통 같은 서버에 SSH로 접근하는 것보다 느리다.&lt;/p&gt;

&lt;h3 id='ssh_'&gt;SSH 프로토콜&lt;/h3&gt;

&lt;p&gt;Git의 대표 프로토콜은 SSH이다. 대부분 서버는 SSH로 접근할 수 있도록 설정돼 있다. 뭐, 설정돼 있지 않더라도 쉽게 설정할 수 있다. 그리고 SSH는 읽기/쓰기 접근을 쉽게 할 수 있는 유일한 네트워크 프로토콜이다. 다른 네트워크 프로토콜인 HTTP와 Git은 일반적으로 읽기만 가능하다. 그래서 초보자(unwashed masses)라고 해도 쓰기 명령을 이용하려면 SSH가 필요하다. SSH는 또한 인증도 지원한다. SSH는 보통 유비쿼터스 적이면서도, 사용하기도, 설치하기도 쉽다.&lt;/p&gt;

&lt;p&gt;SSH를 통해 Git 저장소를 Clone하려면 &lt;code&gt;ssh://&lt;/code&gt;로 시작하는 URL을 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone ssh://user@server:project.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음과 같이 프로토콜 이름을 명시하지 않고도 SSH를 사용할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone user@server:project.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;사용자 계정을 생략할 수도 있는데 계정을 생략하면 Git은 현재 로그인한 사용자의 계정을 사용한다.&lt;/p&gt;

&lt;h4 id='id49'&gt;장점&lt;/h4&gt;

&lt;p&gt;SSH는 장점이 매우 많은 프로토콜이다. 첫째, 누가 원격에서 저장소에 접근하는지 알고 싶다면 SSH를 사용해야 한다. 둘째 SSH는 상대적으로 설정하기 쉽다. SSH 데몬은 정말 흔하다. 많은 네트워크 관리자들은 SSH 데몬을 다루어본 경험이 있고 대부분의 OS 배포판에는 SSH 데몬과 관리도구들이 모두 들어 있다. 셋째 SSH를 통해 접근하면 보안에 안전하다. 모든 데이터는 암호화되어 인증된 상태로 전송된다. 마지막으로 SSH는 전송 시 데이터를 가능한 압축하기 때문에 효율적이다.&lt;/p&gt;

&lt;h4 id='id50'&gt;단점&lt;/h4&gt;

&lt;p&gt;SSH의 단점은 익명으로 접근할 수 없다는 것이다. 심지어 읽기 전용인 경우에도 익명으로 시스템에 접근할 수 없다. 회사에서만 사용할 것이라면 SSH가 가장 적합한 프로토콜일 것이지만 오픈소스 프로젝트는 SSH만으로는 부족하다. 만약 사람들이 프로젝트에 익명으로 접근할 수 있게 하려면 혼자만 Push할 수 있고 다른 사람들은 Pull만 할 수 있도록 SSH를 설정해야 한다.&lt;/p&gt;

&lt;h3 id='git_'&gt;Git 프로토콜&lt;/h3&gt;

&lt;p&gt;Git 프로토콜은 Git에 포함된 데몬을 사용하는 것이다. 포트는 9418이며 SSH 프로토콜과 비슷한 서비스를 제공하지만, 인증 메커니즘이 없다. 저장소에 git-export-daemon-ok 파일을 만들면 Git 프로토콜로 서비스할 수 있지만, 보안은 없다. 이 파일이 없는 저장소는 서비스되지 않는다. 이 저장소는 누구나 Clone할 수 있거나 아무도 Clone할 수 없거나 둘 중의 하나만 선택할 수 있다. 그래서 이 프로토콜로는 Push하게 할 수 없다. 엄밀히 말하자면 Push할 수 있도록 설정할 수 있지만, 인증하도록 할 수 없다. 그러니까 당신이 Push할 수 있으면 이 프로젝트의 URL을 아는 사람은 누구나 Push할 수 있다. 그냥 이런 것도 있지만 잘 안 쓴다고 알고 있으면 된다.&lt;/p&gt;

&lt;h4 id='id51'&gt;장점&lt;/h4&gt;

&lt;p&gt;Git 프로토콜은 전송속도가 가장 빠르다. 교통이 많은 공개 프로젝트나 별도의 인증이 필요 없고 읽기만 허용하는 프로젝트를 서비스할 때 유용하다. 암호화와 인증을 빼면 SSH 프로토콜과 전송 메커니즘이 별반 다르지 않다.&lt;/p&gt;

&lt;h4 id='id52'&gt;단점&lt;/h4&gt;

&lt;p&gt;Git 프로토콜의 단점은 인증 메커니즘이 없는 거다. Git 프로토콜만으로 접근할 수 있는 프로젝트는 바람직하지 못하다. 일반적으로 SSH 프로토콜과 함께 사용한다. 소수의 개발자만 Push할 수 있고 대다수 사람은 &lt;code&gt;git://&lt;/code&gt;을 사용하여 읽을 수만 있게 하는 것이다. 어쩌면 가장 설치하기 어려운 방법일 수도 있다. 별도의 데몬이 필요하고 프로젝트에 맞게 설정해야 한다. 이 장의 Gitosis 절에서 설정하는 법을 살펴볼 것이다. 자원을 아낄 수 있도록 xinetd 같은 것도 설정해야 하고 방화벽을 통과할 수 있도록 9418 포트도 열어야 한다. 이 포트는 일반적으로 회사들이 허용하는 표준 포트가 아니다. 규모가 큰 회사의 방화벽이라면 당연히 이 포트를 막아 놓는다.&lt;/p&gt;

&lt;h3 id='https_'&gt;HTTP/S 프로토콜&lt;/h3&gt;

&lt;p&gt;마지막으로, HTTP 프로토콜이 있다. HTTP와 HTTPS 프로토콜의 미학은 설정이 간단하다는 점이다. HTTP 도큐먼트 루트 밑에 Bare 저장소를 두고 post-update 훅을 설정하는 것이 기본적으로 해야 하는 일의 전부다(7장에서 Git 훅에 대해 자세히 다룰 것이다). 저장소가 있는 웹 서버에 접근할 수 있다면 그 저장소를 Clone할 수도 있다. HTTP를 통해서 저장소를 읽을 수 있게 하려면 다음과 같이 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /var/www/htdocs/
$ git clone --bare /path/to/git_project gitproject.git
$ cd gitproject.git
$ mv hooks/post-update.sample hooks/post-update
$ chmod a+x hooks/post-update&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;post-update 훅은 Git에 포함되어 있으며 &lt;code&gt;git update-server-info&lt;/code&gt;라는 명령어를 실행시킨다. 이 명령어는 HTTP로 Fetch와 Clone 명령이 잘 동작하게 한다. SSH를 통해서 저장소에 Push할 때 실행되며, 사람들은 다음과 같이 Clone한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone http://example.com/gitproject.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서는 Apache 서버가 기본으로 사용하는 &lt;code&gt;/var/www/htdocs&lt;/code&gt;을 루트 디렉토리로 사용하지만 다른 웹 서버를 사용해도 된다. 단순히 Bare 저장소를 HTTP 문서 루트에 넣으면 된다. Git 데이터는 일반적인 정적 파일처럼 취급된다(9장에서 정확히 어떻게 처리하는지 다룰 것이다).&lt;/p&gt;

&lt;p&gt;HTTP를 통해서 Push하는 것도 가능하다. 단지 이 방법은 잘 사용하지 않는 WebDAV 환경을 완벽하게 구축해야 한다. 잘 사용하지 않기 때문에 이 책에서도 다루지 않는다. HTTP 프로토콜로 Push하고 싶으면 &lt;code&gt;http://www.kernel.org/pub/software/scm/git/docs/howto/setup-git-server-over-http.txt&lt;/code&gt; 읽고 저장소를 만들면 된다. HTTP를 통해서 Push하는 방법의 좋은 점은 WebDAV 서버를 아무거나 골라 쓸 수 있다는 것이다. 그래서 WebDAV를 지원하는 웹 호스팅 업체를 이용하면 이 기능을 사용할 수 있다.&lt;/p&gt;

&lt;h4 id='id53'&gt;장점&lt;/h4&gt;

&lt;p&gt;HTTP 프로토콜은 설정하기 쉽다는 것이 장점이다. 몇 개의 필수 명령어만 실행하면 세계 어디에서나 당신의 저장소에 접근할 수 있게 만들 수 있다. 이렇게 하는데 몇 분이면 충분하다. HTTP 프로토콜은 서버의 리소스를 많이 잡아먹지도 않는다. 보통은 정적 HTTP 서버만으로도 충분하기 때문에 흔한 Apache 서버로 초당 수천 개의 파일을 처리할 수 있다. 작은 서버로도 충분히 감당할 수 있다.&lt;/p&gt;

&lt;p&gt;또 HTTPS를 사용해서 서비스할 수도 있기 때문에 전송하는 데이터를 암호화할 수 있다. 그리고 클라이언트가 서명된 SSL 인증서를 사용하게 할 수도 있다. 이렇게 하더라도 SSH 공개키를 사용하는 방식보다 쉽다. 서명한 SSL 인증서를 사용하는 게 나을 때도 있고 단순히 HTTPS위에서 HTTP기반 인증을 사용하는 게 나을 때도 있다.&lt;/p&gt;

&lt;p&gt;HTTP는 매우 보편적인 프로토콜이라서 거의 모든 회사가 트래픽이 방화벽을 통과하도록 허용한다는 장점도 있다.&lt;/p&gt;

&lt;h4 id='id54'&gt;단점&lt;/h4&gt;

&lt;p&gt;클라이언트에서는 HTTP가 좀 비효율적이다. 저장소에서 Fetch하거나 Clone할 때 좀 더 오래 걸린다. 다른 프로토콜의 네트워크 오버헤드보다 HTTP의 오버헤드가 좀 더 크다. 지능적으로 정말 필요한 데이터만 전송하지 않기 때문에 HTTP 프로토콜은 &lt;em&gt;멍청한&lt;/em&gt; 프로토콜(Dumb Protocol)이라고도 부른다. 효율적으로 전송하고자 서버는 아무것도 하지 않는다. HTTP와 다른 프로토콜의 성능 차이는 9장에서 자세히 설명한다.&lt;/p&gt;

&lt;h2 id='_git_'&gt;서버에 Git 설치하기&lt;/h2&gt;

&lt;p&gt;어떤 서버를 설치하더라도 일단 저장소를 Bare 저장소로 만들어야 한다. 다시 말하지만, Bare 저장소는 Working Directory가 없는 저장소이다. &lt;code&gt;--bare&lt;/code&gt; 옵션을 주고 Clone하면 새로운 Bare 저장소가 만들어진다. Bare 저장소 디렉토리는 관례에 따라. git 확장자로 끝난다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone --bare my_project my_project.git
Initialized empty Git repository in /opt/projects/my_project.git/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령의 결과는 조금 특이하다. 사실 &lt;code&gt;git clone&lt;/code&gt; 명령은 &lt;code&gt;git init&lt;/code&gt;을 하고 나서 &lt;code&gt;git fetch&lt;/code&gt;를 한다. 그래서 빈 디렉토리밖에 만들지 않는 &lt;code&gt;git init&lt;/code&gt; 명령의 메시지만 보여준다. 그래서 실제 개체들을 전송하는 것과 관련된 메시지는 아무것도 보여주지 않는다. 그래서 &lt;code&gt;my_project.git&lt;/code&gt; 디렉토리에는 복사한 Git 디렉토리 데이터만 들어 있다.&lt;/p&gt;

&lt;p&gt;다음과 같이 실행한 것과 비슷하다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cp -Rf my_project/.git my_project.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;물론 설정 상의 미세한 차이가 있지만, 저장소의 내용만 고려한다면 같다고 볼 수 있다. Working Directory가 없는 Git 저장소인 데다가 별도의 디렉토리도 하나 만들었다는 점에서는 같다.&lt;/p&gt;

&lt;h3 id='_bare__'&gt;서버에 Bare 저장소 넣기&lt;/h3&gt;

&lt;p&gt;Bare 저장소는 이제 만들었으니까 서버에 넣고 프로토콜을 설정한다. &lt;code&gt;git.example.com&lt;/code&gt;라는 이름의 서버를 하나 준비하자. 그리고 그 서버에 SSH로 접속할 수 있게 만들고 Git 저장소를 /opt/git에 저장할 것이다. 다음과 같이 Bare 저장소를 복사한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ scp -r my_project.git user@git.example.com:/opt/git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 다른 사용자들은 SSH로 서버에 접근해서 저장소를 Clone할 수 있다. 사용자는 &lt;code&gt;/opt/git&lt;/code&gt; 디렉토리에 읽기 권한이 있어야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone user@git.example.com:/opt/git/my_project.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 서버에 SSH로 접근할 수 있는 사용자가 &lt;code&gt;/opt/git/my_project.git&lt;/code&gt; 디렉토리에 쓰기 권한까지 가지고 있으면 바로 Push할 수 있다. &lt;code&gt;git init&lt;/code&gt; 명령에 &lt;code&gt;--shared&lt;/code&gt; 옵션을 추가하면 Git은 자동으로 그룹 쓰기 권한을 추가한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh user@git.example.com
$ cd /opt/git/my_project.git
$ git init --bare --shared&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git 저장소를 만드는 것이 얼마나 쉬운지 살펴보았다. Bare 저장소를 만들어 SSH로 접근할 수 있는 서버에 올리면 동료와 함께 일할 준비가 끝난다.&lt;/p&gt;

&lt;p&gt;그러니까 Git 서버를 구축하는데 사람이 할 일은 정말 별로 없다. SSH로 접속할 수 있도록 서버에 계정을 만들고 Bare 저장소를 사람들이 읽고 쓸 수 있는 곳에 넣어 두기만 하면 된다. 다른 것은 아무것도 필요 없다.&lt;/p&gt;

&lt;p&gt;다음 절에서는 좀 더 정교하게 설정하는 법을 살펴볼 것이다. 사용자에게 계정을 만들어 주는 법, 저장소를 읽고 쓸 수 있게 하는 법, Web UI를 설정하는 법, Gitosis를 사용하는 법, 등등은 여기에서 설명하지 않는다. 즉, 동료와 함께 개발할 때 꼭 필요한 것은 SSH 서버와 Bare 저장소뿐이라는 것을 꼭 기억해야 한다.&lt;/p&gt;

&lt;h3 id='__'&gt;초 간단 뚝딱&lt;/h3&gt;

&lt;p&gt;만약 창업을 준비 중이거나 회사에서 Git을 막 도입하려고 할 때처럼 사용할 개발자의 수가 많지 않을 때에는 설정할 게 별로 없다. 사용자를 관리하는 것이 Git 서버를 설정할 때 가장 골치 아픈 것 중 하나다. 사람이 많으면 어떤 사용자는 읽기만 가능하게 하고 어떤 사용자는 읽고 쓰기 둘 다 가능하게 하는 것은 조금 까다롭다.&lt;/p&gt;

&lt;h4 id='ssh_'&gt;SSH 접근&lt;/h4&gt;

&lt;p&gt;만약 모든 개발자가 SSH로 접속할 수 있는 서버가 있으면 너무 쉽게 저장소를 만들 수 있다. 앞서 말했듯이 정말 할 일이 별로 없다. 그리고 저장소의 권한을 꼼꼼하게 관리해야 하면 운영체제의 파일시스템 권한관리를 이용할 수 있다. 동료가 저장소에 쓰기 접근을 해야 하는 데 아직 SSH로 접속할 수 있는 서버가 없으면 하나 마련해야 한다. 아마 당신에게 서버가 하나 있다면 그 서버에는 이미 SSH 서버가 설치되어 있고 지금도 SSH로 접속하고 있을 것이다.&lt;/p&gt;

&lt;p&gt;팀원들이 접속할 수 있도록 하는 방법은 몇 가지가 있다. 첫째로 모두에게 계정을 만들어 주는 방법이 있다. 이 방법이 제일 단순하지만 다소 귀찮은 방법이다. 팀원마다 adduser를 실행시키고 임시 암호를 부여해야 하기 때문에 보통 이 방법을 쓰고 싶어 하지 않는다.&lt;/p&gt;

&lt;p&gt;둘째로 서버마다 git이라는 계정을 하나씩 만드는 방법이 있다. 쓰기 권한이 필요한 사용자의 SSH 공개키를 모두 모아서 git 계정의 &lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt;파일에 모든 키를 입력한다. 그러면 모두 git 계정으로 그 서버에 접속할 수 있다. 이 git 계정은 커밋 데이터에는 아무런 영향을 끼치지 않는다. 다시 말해서 접속하는 데 사용한 SSH 계정과 커밋에 저장되는 사용자는 아무 상관없다.&lt;/p&gt;

&lt;p&gt;이미 LDAP 서버 같은 중앙집중식 인증 소스를 가지고 있으면 해당 인증을 이용하여 SSH 서버에 인증하도록 할 수도 있다. SSH 인증 메커니즘 중 아무거나 하나라도 이용할 수 있으면 사용자는 그 서버에 접근할 수 있다.&lt;/p&gt;

&lt;h2 id='ssh__'&gt;SSH 공개키 만들기&lt;/h2&gt;

&lt;p&gt;이미 말했듯이 많은 Git 서버들은 SSH 공개키로 인증한다. 공개키를 사용하려면 일단 공개키를 만들어야 한다. 공개키를 만드는 방법은 모든 운영체제가 비슷하다. 먼저 키가 있는지부터 확인하자. 사용자의 SSH 키들은 기본적으로 사용자의 &lt;code&gt;~/.ssh&lt;/code&gt; 디렉토리에 저장한다. 그래서 만약 디렉토리의 파일을 살펴보면 공개키를 가졌는지 확인할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/.ssh
$ ls
authorized_keys2  id_dsa       known_hosts
config            id_dsa.pub&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;something, something.pub이라는 형식으로 된 파일을 볼 수 있을 것이다. something은 보통 &lt;code&gt;id_dsa&lt;/code&gt;나 &lt;code&gt;id_rsa&lt;/code&gt;라고 돼 있다. 그중 &lt;code&gt;.pub&lt;/code&gt;파일이 공개키이고 다른 파일은 개인키이다. 만약 이 파일들이 없거나 &lt;code&gt;.ssh&lt;/code&gt; 디렉토리도 없으면 &lt;code&gt;ssh-keygen&lt;/code&gt;이라는 프로그램으로 키를 생성해야 한다. &lt;code&gt;ssh-keygen&lt;/code&gt; 프로그램은 리눅스나 Mac의 SSH 패키지에 포함돼 있고 윈도우는 MSysGit 패키지 안에 들어 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh-keygen 
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/schacon/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /Users/schacon/.ssh/id_rsa.
Your public key has been saved in /Users/schacon/.ssh/id_rsa.pub.
The key fingerprint is:
43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a schacon@agadorlaptop.local&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.ssh/id_rsa&lt;/code&gt; 키를 저장하고 싶은 디렉토리를 입력하고 암호를 두 번 입력한다. 이때 암호를 비워두면 키를 사용할 때 암호를 묻지 않는다.&lt;/p&gt;

&lt;p&gt;다음은 사용자가 자신의 공개기를 Git 서버 관리자에게 보내야 한다. 사용자는 &lt;code&gt;.pub&lt;/code&gt; 파일의 내용을 복사하여 메일을 보내기만 하면 된다. 공개키는 다음과 같이 생겼다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat ~/.ssh/id_rsa.pub 
ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU
GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3
Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA
t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En
mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx
NrRFi9wrf+M7Q== schacon@agadorlaptop.local&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다양한 운영 체제에서 SSH 키를 만드는 방법이 궁금하면 &lt;code&gt;http://github.com/guides/providing-your-ssh-key&lt;/code&gt;에 있는 Github 설명서를 찾아보는 게 좋다.&lt;/p&gt;

&lt;h2 id='_'&gt;서버 설정하기&lt;/h2&gt;

&lt;p&gt;서버에서 설정하는 일을 살펴보자. 일단 Ubuntu같은 표준 리눅스 배포판을 사용한다고 가정한다. 사용자들은 아마도 &lt;code&gt;authorized_keys&lt;/code&gt; 파일로 인증할 것이다. 먼저 &lt;code&gt;git&lt;/code&gt; 계정을 만들고 사용자 홈 디렉토리에 .ssh 디렉토리를 만든다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo adduser git
$ su git
$ cd
$ mkdir .ssh&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;authorized_keys&lt;/code&gt; 파일에 SSH 공개키를 추가해야 사용자가 접근할 수 있다. 추가하기 전에 이미 이메일로 공개키를 몇 개 받아서 가지고 있다고 가정하자. 공개키가 어떻게 생겼는지 다시 한번 확인해보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /tmp/id_rsa.john.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4L
ojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4k
Yjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez
Sdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myiv
O7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq
dAv8JggJICUvax2T9va5 gsg-keypair&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;authorized_keys&lt;/code&gt; 파일에 추가한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat /tmp/id_rsa.john.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.josie.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.jessica.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--bare&lt;/code&gt; 옵션을 주고 &lt;code&gt;git init&lt;/code&gt;을 실행해서 Working Directory가 없는 빈 저장소를 하나 만든다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /opt/git
$ mkdir project.git
$ cd project.git
$ git --bare init&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 John씨, Josie씨, Jessica씨는 이 저장소를 원격 저장소로 등록하고 나서 브랜치를 Push할 수 있다. 프로젝트마다 적어도 한 명은 서버에 접속하여 Bare 저장소를 만들어야 한다. git 계정과 저장소를 만든 서버의 호스트 이름이 &lt;code&gt;gitserver&lt;/code&gt;라고 하자. 만약 이 서버가 내부망에 있는 거면 &lt;code&gt;gitserver&lt;/code&gt;가 그 서버를 가리키도록 DNS에 설정하면 다음과 같은 명령을 사용할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# on Johns computer
$ cd myproject
$ git init
$ git add .
$ git commit -m &amp;#39;initial commit&amp;#39;
$ git remote add origin git@gitserver:/opt/git/project.git
$ git push origin master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 이 프로젝트를 Clone하고 나서 수정하고 Push할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git@gitserver:/opt/git/project.git
$ vim README
$ git commit -am &amp;#39;fix for the README file&amp;#39;
$ git push origin master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 개발자들이 읽고 쓸 수 있는 Git 서버를 쉽게 만들 수 있다.&lt;/p&gt;

&lt;p&gt;그리고 추가적인 보안 대책으로 &lt;code&gt;git-shell&lt;/code&gt;이라는 걸 사용할 수 있다. 이 쉘로 git 계정을 사용하는 사용자들이 Git 말고 다른 것을 할 수 없도록 제한하는 것이다. git 계정의 로그인 쉘을 이것으로 설정하면 &lt;code&gt;git&lt;/code&gt; 사용자는 일반적인 쉘을 사용할 수 없다. 통상의 bash, csh 대신에 &lt;code&gt;git-shell&lt;/code&gt;을 로그인 쉘로 설정하기만 하면 된다. 이것을 하려면 &lt;code&gt;/etc/passwd&lt;/code&gt; 파일을 편집한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo vim /etc/passwd&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 다음과 같은 줄을 찾는다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git:x:1000:1000::/home/git:/bin/sh&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/bin/sh&lt;/code&gt;를 &lt;code&gt;/usr/bin/git-shell&lt;/code&gt;로(&lt;code&gt;which git-shell&lt;/code&gt; 명령으로 어디에 설치됐는지 확인할 수 있다) 변경한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git:x:1000:1000::/home/git:/usr/bin/git-shell&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;git&lt;/code&gt; 계정은 Git 저장소에 Push하고 Pull하는 것만 가능하고 서버의 쉘에는 접근할 수 없다. 실제로 로그인을 해보면 다음과 같은 메시지로 로그인이 거절된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh git@gitserver
fatal: What do you think I am? A shell?
Connection to gitserver closed.&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id55'&gt;공개하기&lt;/h2&gt;

&lt;p&gt;익명의 사용자에게 읽기 접근을 허용하고 싶을 땐 어떻게 해야 할까? 프로젝트를 비공개가 아니라 오픈 소스 프로젝트로 공개하고 싶거나 자동 빌드 서버나 CI(Continuous Integration) 서버들이 많아서 계정마다 하나하나 설정하기엔 손이 너무 많이 간다. 아니면 그냥 매번 SSH 키를 생성하는 게 귀찮을 수도 있다. 그러니까 그냥 간단하게 익명의 사용자도 읽을 수 있도록 하고 싶을 때를 말하는 것이다.&lt;/p&gt;

&lt;p&gt;아마 웹 서버를 설치하는 것이 가장 쉬운 방법이다. 이 장의 첫 부분에 설명했듯이 웹 서버를 설치하고 Git 저장소를 문서 루트 디렉토리에 두고 &lt;code&gt;post-update&lt;/code&gt; 훅을 켜기만 하면 된다. 먼저 설명했던 예제를 따라 해보자. &lt;code&gt;/opt/git&lt;/code&gt; 디렉토리에 저장소가 있고 서버에 Apache가 설치돼 있다고 가정하자. 아무 웹 서버나 다 사용할 수 있지만, 이 예제에서는 Apache를 사용한다. 여기에서는 이해하는 것이 목적이므로 아주 기본적인 Apache 설정만을 보여줄 것이다.&lt;/p&gt;

&lt;p&gt;먼저 이 훅을 설정해야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd project.git
$ mv hooks/post-update.sample hooks/post-update
$ chmod a+x hooks/post-update&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 1.6보다 낮은 버전의 Git을 사용하고 있으면 &lt;code&gt;mv&lt;/code&gt; 명령은 필요하지 않다. Git은 최근에서야 훅 예제에 &lt;code&gt;.sample&lt;/code&gt; 확장자를 사용하기 시작했다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;post-update&lt;/code&gt; 훅은 무슨 일을 할까? 기본적으로 다음과 같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat .git/hooks/post-update 
#!/bin/sh
exec git-update-server-info&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SSH를 통해서 서버에 Push하면 Git은 이 명령어를 실행하여 HTTP를 통해서도 Fetch할 수 있도록 파일들을 갱신한다.&lt;/p&gt;

&lt;p&gt;그다음 Apache 설정에 VirtualHost 항목을 추가한다. 이 항목에서 문서 루트가 Git 저장소의 루트 디렉토리가 되도록 한다. 그리고 &lt;code&gt;*.gitserver&lt;/code&gt;로 접속하는 사람들이 모두 이 서버에 접속하도록 와일드카드를 이용하여 VirtualHost항목을 다음과 같이 설정한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;VirtualHost *:80&amp;gt;
    ServerName git.gitserver
    DocumentRoot /opt/git
    &amp;lt;Directory /opt/git/&amp;gt;
        Order allow, deny
        allow from all
    &amp;lt;/Directory&amp;gt;
&amp;lt;/VirtualHost&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 Apache 서버는 &lt;code&gt;www-data&lt;/code&gt; 권한으로 CGI 스크립트를 실행시키기 때문에 &lt;code&gt;/opt/git&lt;/code&gt; 디렉토리의 그룹 소유 권한을 &lt;code&gt;www-data&lt;/code&gt;로 수정해 주어야 웹 서버로 접근하는 사용자들이 읽을 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ chgrp -R www-data /opt/git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apache를 재시작하면 다음과 같은 URL로 저장소를 Clone할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone http://git.gitserver/project.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 사용자들이 HTTP로 프로젝트에 접근하도록 설정하는 데 몇 분밖에 걸리지 않는다. 프로세스를 데몬으로 만들어야 한다는 단점이 있지만, Git 데몬으로도 똑같이 인증 없이 접속하게 할 수 있다. 이것은 다음 절에서 살펴볼 것이다.&lt;/p&gt;

&lt;h2 id='gitweb'&gt;GitWeb&lt;/h2&gt;

&lt;p&gt;프로젝트 저장소를 단순히 읽거나 쓰는 것에 대한 설정은 다뤘다. 이제는 웹 기반 인터페이스를 설정해 보자. Git은 웹에서 저장소들을 조회할 수 있는 GitWeb이라는 CGI 스크립트를 제공한다. &lt;code&gt;http://git.kernel.org&lt;/code&gt;같은 사이트에서 GitWeb을 구경할 수 있다(그림 4-1).&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0401-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 4-1. Git 웹용 UI, GitWeb&lt;/p&gt;

&lt;p&gt;Git은 GitWeb을 쉽게 사용해 볼 수 있도록 서버를 잠시 띄워 볼 수 있는 명령을 제공한다. 시스템에 &lt;code&gt;lighttpd&lt;/code&gt;나 &lt;code&gt;webrick&lt;/code&gt; 같은 경량 웹서버가 설치돼 있어야 이 명령을 사용할 수 있다. 리눅스에서는 &lt;code&gt;lighttpd&lt;/code&gt;가 설치돼 있을 확률이 높아서 프로젝트 디렉토리에서 그냥 &lt;code&gt;git instaweb&lt;/code&gt;을 실행하면 바로 실행될 것이다. Mac의 Leopard 버전은 Ruby가 미리 설치돼 있기 때문에 &lt;code&gt;webrick&lt;/code&gt;이 더 나은 선택이다. lighttpd이 아니라면 다음과 같이 &lt;code&gt;--httpd&lt;/code&gt; 옵션을 사용해야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git instaweb --httpd=webrick
[2009-02-21 10:02:21] INFO  WEBrick 1.3.1
[2009-02-21 10:02:21] INFO  ruby 1.8.6 (2008-03-03) [universal-darwin9.0]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1234 포트로 HTTPD 서버를 시작하고 이 페이지를 여는 웹브라우저를 자동으로 실행시킨다. 사용자에게는 꽤 편리하다. 필요한 일을 모두 마치고 나서 같은 명령어에 &lt;code&gt;--stop&lt;/code&gt; 옵션을 추가하여 서버를 중지한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git instaweb --httpd=webrick --stop&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자신의 프로젝트에서 언제나 웹 인터페이스를 운영하려면 먼저 웹서버에 이 CGI 스크립트를 설치해야 한다. &lt;code&gt;apt&lt;/code&gt;나 &lt;code&gt;yum&lt;/code&gt;으로도 &lt;code&gt;gitweb&lt;/code&gt;을 설치할 수 있지만, 여기에서는 수동으로 설치한다. 먼저 GitWeb이 포함된 Git 소스 코드를 구한 다음 CGI 스크립트를 빌드한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git://git.kernel.org/pub/scm/git/git.git
$ cd git/
$ make GITWEB_PROJECTROOT=&amp;quot;/opt/git&amp;quot; \
        prefix=/usr gitweb/gitweb.cgi
$ sudo cp -Rf gitweb /var/www/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;빌드할 때 &lt;code&gt;GITWEB_PROJECTROOT&lt;/code&gt; 변수로 Git 저장소의 위치를 알려줘야 한다. 이제 Apache가 이 스크립트를 사용하도록 VirtualHost 항목을 설정해야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;VirtualHost *:80&amp;gt;
    ServerName gitserver
    DocumentRoot /var/www/gitweb
    &amp;lt;Directory /var/www/gitweb&amp;gt;
        Options ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch
        AllowOverride All
        order allow,deny
        Allow from all
        AddHandler cgi-script cgi
        DirectoryIndex gitweb.cgi
    &amp;lt;/Directory&amp;gt;
&amp;lt;/VirtualHost&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다시 말해서 GitWeb은 CGI를 지원하는 웹서버라면 아무거나 사용할 수 있다. 이제 &lt;code&gt;http://gitserver/&lt;/code&gt;에 접속하여 온라인으로 저장소를 확인할 수 있을 뿐만 아니라 &lt;code&gt;http://git.gitserver&lt;/code&gt;를 URL로 HTTP를 통해서 저장소를 Clone하고 Fetch할 수 있다.&lt;/p&gt;

&lt;h2 id='gitosis'&gt;Gitosis&lt;/h2&gt;

&lt;p&gt;처음에는 모든 사용자의 공개키를 &lt;code&gt;authorized_keys&lt;/code&gt;에 저장하는 방법으로도 불편하지 않을 것이다. 하지만, 사용자가 수백 명이 넘으면 관리하기가 매우 고통스럽다. 사용자를 추가할 때마다 매번 서버에 접속해야 하고 권한 관리도 할 수 없다. &lt;code&gt;authorized_keys&lt;/code&gt;에 등록된 모든 사용자는 누구나 프로젝트를 읽고 쓸 수 있다.&lt;/p&gt;

&lt;p&gt;이 문제는 매우 널리 사용되고 있는 Gitosis라는 소프트웨어로 해결할 수 있다. Gitosis는 기본적으로 &lt;code&gt;authorized_keys&lt;/code&gt; 파일을 관리하고 접근제어를 돕는 스크립트 패키지다. 사용자를 추가하고 권한을 관리하는 UI가 웹 인터페이스가 아니라 일종의 Git 저장소라는 점이 재미있다. 프로젝트 설정을 Push하면 그 설정이 Gitosis에 적용된다. 신비롭다!&lt;/p&gt;

&lt;p&gt;Gitosis를 설치하기가 쉽지는 않지만 그렇다고 어렵지도 않다. Gitosis는 리눅스에 설치하는 것이 가장 쉽다. 여기서는 Ubuntu 8.10 서버를 사용한다.&lt;/p&gt;

&lt;p&gt;Gitosis는 Python이 필요하기 때문에 먼저 Python setuptools 패키지를 설치해야 한다. Ubuntu에서는 다음과 같이 설치한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install python-setuptools&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 Gitosis 프로젝트 사이트에서 Gitosis를 Clone한 후 설치한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git://eagain.net/gitosis.git
$ cd gitosis
$ sudo python setup.py install&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gitosis을 설치하고 나면 Gitosis는 저장소 디렉토리로 &lt;code&gt;/home/git&lt;/code&gt;를 사용하려고 한다. 이대로 사용해도 괜찮지만, 우리의 저장소는 이미 &lt;code&gt;/opt/git&lt;/code&gt;에 있다. 다시 설정하지 말고 다음과 같이 간단하게 심볼릭 링크를 만들자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ln -s /opt/git /home/git/repositories&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gitosis가 키들을 관리할 것이기 때문에 현재 파일은 삭제하고 다시 추가해야 한다. 이제부터는 Gitosis가 &lt;code&gt;authorized_keys&lt;/code&gt;파일을 자동으로 관리할 것이다. &lt;code&gt;authorized_keys&lt;/code&gt; 파일을 백업해두자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mv /home/git/.ssh/authorized_keys /home/git/.ssh/ak.bak&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 &lt;code&gt;git&lt;/code&gt; 계정의 쉘을 &lt;code&gt;git-shell&lt;/code&gt;로 변경했었다면 원래대로 복원해야 한다. Gitosis가 대신 이 일을 맡아줄 것이기 때문에 복원해도 사람들은 여전히 로그인할 수 없다. &lt;code&gt;/etc/passwd&lt;/code&gt; 파일의 다음 줄을:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git:x:1000:1000::/home/git:/usr/bin/git-shell&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음과 같이 변경한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git:x:1000:1000::/home/git:/bin/sh&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 Gitosis를 초기화할 차례다. &lt;code&gt;gitosis-init&lt;/code&gt; 명령을 공개키와 함께 실행한다. 만약 공개키가 서버에 없으면 공개키를 서버로 복사해와야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo -H -u git gitosis-init &amp;lt; /tmp/id_dsa.pub
Initialized empty Git repository in /opt/git/gitosis-admin.git/
Reinitialized existing Git repository in /opt/git/gitosis-admin.git/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 이 키의 사용자가 Gitosis를 제어하는 파일들이 있는 Gitosis 제어 저장소 수정할 수 있게 한다. 그리고 수동으로 &lt;code&gt;post-update&lt;/code&gt; 스크립트에 실행권한을 부여해야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo chmod 755 /opt/git/gitosis-admin.git/hooks/post-update&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;모든 준비가 끝났다. 설정이 잘 됐으면 추가한 공개키의 사용자로 SSH 서버에 접속했을 때 다음과 같은 메시지를 볼 수 있을 것이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh git@gitserver
PTY allocation request failed on channel 0
fatal: unrecognized command &amp;#39;gitosis-serve schacon@quaternion&amp;#39;
  Connection to gitserver closed.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이것은 접속을 시도한 사용자가 누구인지 식별할 수는 있지만, Git 명령이 아녀서 거절한다는 것을 의미한다. 그러니까 실제 Git 명령어를 실행시켜보자. Gitosis 제어 저장소를 Clone한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# on your local computer
$ git clone git@gitserver:gitosis-admin.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;gitosis-admin&lt;/code&gt;이라는 디렉토리가 생긴다. 디렉토리 내용을 크게 두 가지로 나누어 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd gitosis-admin
$ find .
./gitosis.conf
./keydir
./keydir/scott.pub&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;gitoiss.conf&lt;/code&gt; 파일은 사용자, 저장소, 권한 등을 명시하는 설정파일이다. &lt;code&gt;keydir&lt;/code&gt; 디렉토리는 저장소에 접근할 수 있는 사용자들의 공개키가 저장돼 있다. 사용자마다 공개키가 하나씩 있고 이 공개키로 서버에 접근한다. 이 예제에서는 &lt;code&gt;scott.pub&lt;/code&gt;이지만 &lt;code&gt;keydir&lt;/code&gt; 안에 있는 파일의 이름은 사용자마다 다르다. Gitosis는 &lt;code&gt;gitosis-init&lt;/code&gt; 스크립트로 공개키를 추가할 때 그 공개키의 끝 부분에 입력한 이름을 사용한다.&lt;/p&gt;

&lt;p&gt;이제 &lt;code&gt;gitosis.conf&lt;/code&gt; 파일을 열어보자. 지금 막 Clone한 &lt;code&gt;gitosis-admin&lt;/code&gt; 프로젝트에 대한 정보만 들어 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat gitosis.conf 
[gitosis]

[group gitosis-admin]
writable = gitosis-admin
members = scott&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;scott이라는 사용자는 Gitosis를 초기화할 때 사용한 공개키의 사용자이다. 이 사용자만 &lt;code&gt;gitosis-admin&lt;/code&gt; 프로젝트에 접근할 수 있다.&lt;/p&gt;

&lt;p&gt;이제 프로젝트를 새로 추가해보자. &lt;code&gt;mobile&lt;/code&gt; 단락을 추가하고 그 프로젝트에 속한 개발자나 프로젝트에 접근해야 하는 사용자를 추가한다. 현재는 scott이외에 다른 사용자가 없어서 &lt;code&gt;scott&lt;/code&gt;만 추가한다. 그리고 새로운 &lt;code&gt;iphone_project&lt;/code&gt; 프로젝트를 추가한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[group mobile]
writable = iphone_project
members = scott&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;gitosis-admin&lt;/code&gt; 프로젝트를 수정하면 커밋하고 서버에 Push해야 수정한 설정이 적용된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit -am &amp;#39;add iphone_project and mobile group&amp;#39;
[master]: created 8962da8: &amp;quot;changed name&amp;quot;
 1 files changed, 4 insertions(+), 0 deletions(-)
$ git push
Counting objects: 5, done.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 272 bytes, done.
Total 3 (delta 1), reused 0 (delta 0)
To git@gitserver:/opt/git/gitosis-admin.git
   fb27aec..8962da8  master -&amp;gt; master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;로컬에 있는 &lt;code&gt;iphone_project&lt;/code&gt; 프로젝트에 이 서버를 원격 저장소로 추가하고 Push하면 서버에 새로운 저장소가 추가된다. 서버에 프로젝트를 새로 만들 때 더는 수동으로 Bare 저장소를 만들 필요 없다. 처음 Push할 때 Gitosis가 알아서 생성해 준다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote add origin git@gitserver:iphone_project.git
$ git push origin master
Initialized empty Git repository in /opt/git/iphone_project.git/
Counting objects: 3, done.
Writing objects: 100% (3/3), 230 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To git@gitserver:iphone_project.git
 * [new branch]      master -&amp;gt; master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gitosis를 이용할 때에는 저장소 경로를 명시할 필요도 없고 사용할 수도 없다. 단지 콜론 뒤에 프로젝트 이름만 적어도 Gitosis가 알아서 찾아 준다.&lt;/p&gt;

&lt;p&gt;동료와 이 프로젝트를 공유하려면 동료의 공개키도 모두 추가해야 한다. &lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt; 파일에 수동으로 추가하는 게 아니라 &lt;code&gt;keydir&lt;/code&gt; 디렉토리에 하나의 공개키를 하나의 파일로 추가한다. 이 공개키의 파일이름이 &lt;code&gt;gitosis.conf&lt;/code&gt; 파일에서 사용하는 사용자 이름을 결정한다. John, Josie, Jessica의 공개키를 추가해 보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cp /tmp/id_rsa.john.pub keydir/john.pub
$ cp /tmp/id_rsa.josie.pub keydir/josie.pub
$ cp /tmp/id_rsa.jessica.pub keydir/jessica.pub&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 세 사람을 모두 mobile 팀으로 추가하여 &lt;code&gt;iphone_project&lt;/code&gt; 에 대한 읽기, 쓰기를 허용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[group mobile]
writable = iphone_project
members = scott john josie jessica&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 파일을 커밋하고 Push하고 나면 네 명 모두 &lt;code&gt;iphone_project&lt;/code&gt;를 읽고 쓸 수 있게 된다.&lt;/p&gt;

&lt;p&gt;Gitosis의 접근제어 방법은 매우 단순하다. 만약 John은 이 프로젝트를 읽을 수만 있도록 설정하려면 다음과 같이 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[group mobile]
writable = iphone_project
members = scott josie jessica

[group mobile_ro]
readonly = iphone_project
members = john&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 John은 프로젝트를 Clone하거나 Fetch할 수는 있지만, 프로젝트에 Push할 수는 없다. 다양한 사용자와 프로젝트가 있어도 필요한 만큼 그룹을 만들어 사용하면 된다. 그리고 members 항목에 사용자 대신 그룹명을 사용할 수도 있다. 그룹명 앞에 &lt;code&gt;@&lt;/code&gt;를 붙여 사용하면 그 그룹의 사용자을 그대로 상속한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[group mobile_committers]
members = scott josie jessica

[group mobile]
writable  = iphone_project
members   = @mobile_committers

[group mobile_2]
writable  = another_iphone_project
members   = @mobile_committers john&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;[gitosis]&lt;/code&gt; 절에 &lt;code&gt;loglevel=DEBUG&lt;/code&gt;라고 적으면 문제가 생겼을 때 도움이 된다. 그리고 설정이 꼬여버려서 Push할 수 없게 되면 서버에 있는 파일을 수동으로 고칠 수 있다. Gitosis는 &lt;code&gt;/home/git/.gitosis.conf&lt;/code&gt; 파일의 정보를 읽기 때문에 이 파일을 고치면 된다. &lt;code&gt;gitosis.conf&lt;/code&gt;가 Push할 때 거기로 복사되기 때문에 수동으로 고친 파일은 &lt;code&gt;gitosis-admin&lt;/code&gt; 프로젝트가 다음에 Push될 때까지 유지된다.&lt;/p&gt;

&lt;h2 id='gitolite'&gt;Gitolite&lt;/h2&gt;

&lt;p&gt;주의사항: 이 절의 최신판은 항상 &lt;a href='http://github.com/sitaramc/gitolite/blob/pu/doc/progit-article.mkd'&gt;gitolite documentation&lt;/a&gt;에서 확인할 수 있다. 저자는 다른 참고 문서 없이 이 절만 읽고서도 gtolite를 설치할 수 있도록 문서를 작성했다고 말했다. 이 절은 꼭 필요하지만 완벽하지 않고 gitolite에 대한 방대한 문서를 대체할 수도 없다.&lt;/p&gt;

&lt;p&gt;Git은 좀 더 꼼꼼한 접근 제어가 필요한 기업환경에서도 많이 쓰인다. 원래 이 요구 사항 덕분에 Gitolite가 만들어졌다. 그리고 오픈 소스 진영에서도 매우 유용하다는 것이 밝혀졌다. Fedora 프로젝트는 gitolite를 사용하여 10,000개가 넘는 패키지 관리용 저장소의 권한을 제어한다. Fedora의 gitolite가 아마도 가장 규모가 클 것이다.&lt;/p&gt;

&lt;p&gt;Gitolite는 저장소뿐만 아니라 저장소의 브랜치나 태그에도 권한을 명시할 수 있다. 즉, 어떤 사람들은 refs(브랜치나 태그)에 Push할 수 있고 어떤 사람은 할 수 없게 하는 것이 가능하다.&lt;/p&gt;

&lt;h3 id='id56'&gt;설치하기&lt;/h3&gt;

&lt;p&gt;별도 문서를 읽지 않아도 유닉스 계정만 하나 있으면 Gitolite를 쉽게 설치할 수 있다. 이 글은 여러 가지 리눅스들과 솔라리스 10에서 테스트를 마쳤다. git, perl, openssh가 호환되는 ssh 서버가 설치돼 있으면 root 권한도 필요 없다. 앞서 사용했던 &lt;code&gt;gitserver&lt;/code&gt;라는 서버와 그 서버에 &lt;code&gt;gitolite&lt;/code&gt; 계정을 만들어 사용할 것이다.&lt;/p&gt;

&lt;p&gt;Gitolite는 보통의 서버 소프트웨어와는 약간 다르다. ssh를 통해서 접근하지만, 서버의 모든 계정은 근본적으로 &amp;#8220;gitolite 호스트&amp;#8221;가 될 수 있다. 그래서 설치하는 일은 소프트웨어 자체를 설치하는 일과 한 계정을 &amp;#8220;gitolite 호스트&amp;#8221;로 설정하는 작업으로 나눌 수 있다.&lt;/p&gt;

&lt;p&gt;Gitolite를 설치하는 방법은 모두 네 가지이다. Fedora나 Debian을 사용하고 있으면 RPM이나 DEB 패키지를 구해서 설치하거나 수동으로 설치할 수 있다. 이 방법들은 root 권한이 필요하다. 이 두 가지 모두 시스템의 모든 사용자를 각각 &amp;#8220;gitolite host&amp;#8221;로 만들 수 있다.&lt;/p&gt;

&lt;p&gt;서버의 Root 권한을 얻을 수 없는 사용자는 자신의 계정에 설치할 수 있다. 서버에서 Bash 스크립트를 실행하여 Gitolite를 설치할 수 있다. 심지어 Windows 환경에서 msysgit에 들어 있는 bash에서도 실행된다.&lt;/p&gt;

&lt;p&gt;이 글에서는 마지막 방법을 설명할 것이다; 다른 방법은 다른 문서를 참고하도록 한다.&lt;/p&gt;

&lt;p&gt;우선 공개키로 서버에 접근할 수 있어야 한다. 그래야 서버로 로그인할 때 암호를 묻지 않는다. &lt;code&gt;ssh-keygen&lt;/code&gt;로 만든 키가 이미 있으면 다음처럼 한다. 리눅스에서는 이 방법이 잘 될 테고 다른 OS라면 수동으로 이 작업을 해야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh-copy-id -i ~/.ssh/id_rsa gitolite@gitserver&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 Gitolite 계정의 암호를 물어보고서 이 공개키로 접근할 수 있도록 설정할 것이다. 이것은 설치 스크립트를 실행하는 데 꼭 &lt;strong&gt;필요하다&lt;/strong&gt;. 그러니까 명령어를 실행할 때 암호를 물어보는지 다시 한번 확인해봐야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh gitolite@gitserver pwd
/home/gitolite&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 프로젝트 사이트에서 Gitolite를 Clone하고 &amp;#8220;easy install&amp;#8221; 스크립트를 실행한다(세 번째 인자는 gitolite-admin 저장소에서 사용할 사용자 이름이다):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git://GitHub.com/sitaramc/gitolite
$ cd gitolite/src
$ ./gl-easy-install -q gitolite gitserver sitaram&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 다 됐다. Gitolite를 서버에 설치했고 홈 디렉토리에 &lt;code&gt;gitolite-admin&lt;/code&gt;라는 저장소를 만들었다. 이 저장소를 수정하고 Push해서 gitolite 서버를 관리할 수 있다.&lt;/p&gt;

&lt;p&gt;마지막 명령에는 중요한 정보가 많이 들어 있다. 이 명령을 처음 실행하면 키쌍이(keypair) 새로 만들어진다. 암호가 필요하면 입력하고 필요 없으면 그냥 엔터를 친다. 왜 키를 하나 더 만드는지, 그것을 어떻게 사용하는지는 Gitolite의 &amp;#8220;ssh troubleshooing&amp;#8221; 문서를 참고하라(이 문서가 필요할 때가 있다).&lt;/p&gt;

&lt;p&gt;서버에는 기본적으로 &lt;code&gt;gitolite-admin&lt;/code&gt;과 &lt;code&gt;testing&lt;/code&gt; 저장소가 생성되고 필요하면 이 저장소를 다음과 같이 Clone한다(&lt;em&gt;authorized_keys&lt;/em&gt; 파일에 공개키가 등록돼서 SSH 접근이 가능한 계정으로 gotolite 계정에 접근하는 것):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone gitolite:gitolite-admin
$ git clone gitolite:testing&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다른 계정으로도 이 저장소를 Clone할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone gitolite@servername:gitolite-admin
$ git clone gitolite@servername:testing&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='__'&gt;자신에게 맞게 설치하기&lt;/h3&gt;

&lt;p&gt;대부분의 사람은 기본설정으로 빠르게 설치하는 것으로 충분하지만, 자신에게 맞게 고쳐서 설치할 수 있다. &lt;code&gt;-q&lt;/code&gt; 인자를 사용하면 설치 단계마다 상세한 정보를 보여주는 verbose 모드로 설치한다. 이 모드에서는 저장소의 경로 같은 것들을 바꿔서 설치할 수 있고 결국엔 서버가 사용하는 rc 파일이 수정된다. rc 파일은 주석이 정말 잘 달렸기 때문에 필요한 것이 있으면 언제든지 쉽게 수정할 수 있다. 이 파일에서 Gitolite의 고급 기능들을 켜고 끄는 등 다양한 설정을 하는 것이다.&lt;/p&gt;

&lt;h3 id='___'&gt;설정 파일과 접근제어 규칙&lt;/h3&gt;

&lt;p&gt;설치가 완료되면 홈 디렉토리에 있는 &lt;code&gt;gitolite-admin&lt;/code&gt; 저장소로 이동해서 저장소의 내용이 어떤 것들인지 한번 살펴보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/gitolite-admin/
$ ls
conf/  keydir/
$ find conf keydir -type f
conf/gitolite.conf
keydir/sitaram.pub
$ cat conf/gitolite.conf
#gitolite conf
# please see conf/example.conf for details on syntax and features

repo gitolite-admin
    RW+                 = sitaram

repo testing
    RW+                 = @all&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;gl-easy-install&lt;/code&gt; 명령을 실행했을 때 주었던 마지막 인자가 기억나는가? 그때 사용했던 sitaram은 &lt;code&gt;gitolite-admin&lt;/code&gt; 저장소에 대한 읽기, 쓰기 권한을 모두 가지고 있고 공개키도 이미 등록돼 있다.&lt;/p&gt;

&lt;p&gt;Gitolite의 설정 파일은 &lt;code&gt;conf/example.conf&lt;/code&gt; 파일 안에 상세히 설명돼 있다. 여기에서는 중요한 부분에 대해서만 다룰 것이다.&lt;/p&gt;

&lt;p&gt;사용자와 저장소의 그룹을 만들 수 있다. 이 그룹은 매크로와 비슷하다. 그룹을 만들 때는 그 그룹이 프로젝트의 그룹인지 사용자의 그룹인지 구분하지 않지만 사용할 때에는 다르다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@oss_repos      = linux perl rakudo git gitolite
@secret_repos   = fenestra pear

@admins         = scott     # Adams, not Chacon, sorry :)
@interns        = ashok     # get the spelling right, Scott!
@engineers      = sitaram dilbert wally alice
@staff          = @admins @engineers @interns&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 ref 단위로 권한을 제어할 수 있다. 다음 예제를 보자. 인턴(interns)들은 int 브랜치에만 Push할 수 있고 engineers는 eng-로 시작하는 많은 브랜치들과 rc 뒤에 숫자가 붙는 태그들을 Push할 수 있다. 그리고 관리자는 모든 ref에 무엇이든지(되돌리기도 포함됨) 할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;repo @oss_repos
    RW  int$                = @interns
    RW  eng-                = @engineers
    RW  refs/tags/rc[0-9]   = @engineers
    RW+                     = @admins&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;RW&lt;/code&gt;나 &lt;code&gt;RW+&lt;/code&gt; 뒤에 나오는 표현식은 정규표현식(regex)이고 의미는 Push하는 ref 이름의 패턴을 나타낸다. 그래서 우리는 refex라고 부른다. 물론 refex는 여기에 보여준 것보다 훨씬 더 강력하다. 하지만, 펄의 정규표현식에 익숙하지 않은 독자도 있으니 여기서 무리할 필요 없다.&lt;/p&gt;

&lt;p&gt;그리고 이미 예상했겠지만 Gitolite는 &lt;code&gt;refs/heads/&lt;/code&gt;라고 시작하지 않는 refex에 대해서는 암묵적으로 &lt;code&gt;refs/heads/&lt;/code&gt;가 생략된 것으로 판단한다.&lt;/p&gt;

&lt;p&gt;특정 저장소의 모든 규칙을 한 곳에 모으지 않아도 괜찮다. 위에 보여준 &lt;code&gt;oss_repos&lt;/code&gt;와 다른 설정이 마구 섞여 있어도 괜찮다. 다음과 같이 아주 제한적이고 특별한 규칙을 아무 데나 추가해도 좋다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;repo gitolite
    RW+                     = sitaram&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 규칙은 &lt;code&gt;gitolite&lt;/code&gt; 저장소를 위해 지금 막 추가한 규칙이다.&lt;/p&gt;

&lt;p&gt;이제는 접근제어 규칙이 실제로 어떻게 적용되는지 궁금할 것이다. 이제부터 그 내용을 살펴보자.&lt;/p&gt;

&lt;p&gt;Gitlolite는 두 단계로 접근을 제어한다. 첫 단계가 저장소 단계인데 접근하는 저장소의 ref 중에서 하나라도 읽고 쓸 수 있으면 실제로 그 저장소 전부에 대한 읽기, 쓰기 권한이 있는 것이다.&lt;/p&gt;

&lt;p&gt;두 번째 단계는 브랜치나 태그 단위로 제어하는 것으로 오직 &amp;#8220;쓰기&amp;#8221; 접근만 제어할 수 있다. 어느 사용자가 특정 ref 이름으로 접근을 시도하면(&lt;code&gt;W&lt;/code&gt;나 &lt;code&gt;+&lt;/code&gt;같은) 설정 파일에 정의된 순서대로 접근 제어 규칙이 적용된다. 그 순서대로 사용자 이름과 ref 이름을 비교하는데 ref 이름의 경우 단순히 문자열을 비교하는 것이 아니라 정규 표현식을 만족하게 하는 것이다. 만족하는 것을 찾으면 정상적으로 Push되지만 찾지 못하면 거절된다.&lt;/p&gt;

&lt;h3 id='deny___'&gt;&amp;#8220;deny&amp;#8221; 규칙을 꼼꼼하게 제어하기&lt;/h3&gt;

&lt;p&gt;지금까지는 &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;RW&lt;/code&gt;, RW+&lt;code&gt; 권한에 대해서만 다뤘다. gitolite는 &amp;quot;deny&amp;quot; 규칙을 위해서 &lt;/code&gt;-&lt;code&gt; 권한도 지원한다. 이것으로 복잡도를 낮출 수 있다. &lt;/code&gt;-&lt;code&gt;로 거절도 할 수 있기 때문에 *규칙의 순서가 중요하다*.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;다시 말해서 engineers가 master와 integ 브랜치 &lt;em&gt;이외의&lt;/em&gt; 모든 브랜치를 되돌릴 수 있게 하고 싶으면 다음과 같이 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    RW  master integ    = @engineers
    -   master integ    = @engineers
    RW+                 = @engineers&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;즉, 접근제어 규칙을 순서대로 찾기 때문에 순서대로 정의해야 한다. 첫 번째 규칙은 master나 integ 브랜치에 대해서 읽기, 쓰기만 허용하고 되돌리기는 허용하지 않는다. master나 integ 브랜치를 되돌리는 Push는 첫 번째 규칙에 어긋나기 때문에 바로 두 번째 규칙으로 넘어간다. 그리고 거기서 거절된다. master나 integ 브랜치 이외의 모든 ref에 대한 모든 Push는 첫 번째와 두 번째 규칙에는 만족하지 않고 마지막 규칙으로 허용된다.&lt;/p&gt;

&lt;h3 id='__push_'&gt;파일 단위로 Push를 제어하기&lt;/h3&gt;

&lt;p&gt;브랜치 단위로 Push를 제어할 수 있지만 수정한 파일단위로도 제어할 수 있다. 예를 들어 Makefile을 보자. Makefile 파일에 의존하는 파일은 매우 많고 보통 &lt;em&gt;꼼꼼하게&lt;/em&gt; 수정하지 않으면 문제가 생긴다. 그래서 아무나 Makefile을 수정하게 둘 수 없다. 그러면 다음과 같이 설정한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;repo foo
    RW                  =   @junior_devs @senior_devs

    RW  NAME/           =   @senior_devs
    -   NAME/Makefile   =   @junior_devs
    RW  NAME/           =   @junior_devs&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 내용은 &lt;code&gt;conf/example.conf&lt;/code&gt;에도 자세히 설명돼 있다.&lt;/p&gt;

&lt;h3 id='personal_'&gt;Personal 브랜치&lt;/h3&gt;

&lt;p&gt;Gitolite는 또 &amp;#8220;Personal 브랜치&amp;#8221;라고 부르는 기능을 지원한다. 이 기능은 실제로 &amp;#8220;Personal 브랜치 네임스페이스&amp;#8221;라고 부르는 것이 더 적절하다. 이 기능은 기업에서 매우 유용하다.&lt;/p&gt;

&lt;p&gt;Git을 사용하다 보면 코드를 공유하려고 &amp;#8220;Pull 해주세요&amp;#8221;라고 말해야 하는 일이 자주 생긴다. 그런데 기업에서는 절대 인증하지 않은 접근을 허용하지도 않는 데다가 아예 다른 사람의 컴퓨터에 접근할 수 없다. 그래서 공유하려면 중앙 서버에 Push하고 나서 Pull해야 한다고 다른 사람에게 말해야만 한다.&lt;/p&gt;

&lt;p&gt;중앙집중식 VCS에서 이렇게 마구 사용하면 브랜치 이름이 충돌할 확률이 높다. 그때마다 관리자는 추가로 권한을 관리해줘야 하기 때문에 관리자의 노력이 쓸데없이 낭비된다.&lt;/p&gt;

&lt;p&gt;Gitolite는 모든 개발자가 &amp;#8220;personal&amp;#8221;이나 &amp;#8220;scratch&amp;#8221; 네임스페이스를 가질 수 있도록 허용한다. 이 네임스페이스는 &lt;code&gt;refs/personal/&amp;lt;devname&amp;gt;/*&lt;/code&gt; 라고 표현한다. 자세한 것은 &lt;code&gt;doc/3-faq-tips-etc.mkd&lt;/code&gt;의 &amp;#8220;Personal 브랜치&amp;#8221; 절을 참고한다.&lt;/p&gt;

&lt;h3 id='_'&gt;&amp;#8220;와일드카드&amp;#8221; 저장소&lt;/h3&gt;

&lt;p&gt;Gitolite는 펄 정규표현식으로 저장소 이름을 표현하기 때문에 와일드카드를 사용할 수 있다. 그래서 &lt;code&gt;assignments/s[0-9][0-9]/a[0-9][0-9]&lt;/code&gt; 같은 정규표현식을 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;rc 파일에 &lt;code&gt;$GL_WILDREPOS = 1&lt;/code&gt;로 설정하면 이 기능을 사용할 수 있다. 게다가 새로운 권한 모드인 &amp;#8220;C&amp;#8221;를 사용할 수 있게 된다. 이것은 해당 사용자가 와일드카드가 있는 정규표현식에 만족하는 저장소를 만들 수 있는 권한을 부여하는 것이다. 사용자가 저장소를 만들면 자동으로 사용자를 소유자로 만든다. 이 소유자는 R과 RW 권한이 필요한 사람들에게 권한을 부여할 수 있다. 이 기능은 &lt;code&gt;doc/4-wildcard-repositories.mkd&lt;/code&gt;에 자세히 설명돼 있다.&lt;/p&gt;

&lt;h3 id='__'&gt;그 밖의 기능들&lt;/h3&gt;

&lt;p&gt;마지막으로 알고 있으면 유용한 것들이 있다. Gitolite에는 많은 기능이 있고 자세한 내용은 &amp;#8220;Faq, Tip, 등등&amp;#8221;의 다른 문서에 잘 설명돼 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;로깅&lt;/strong&gt;: 누군가 성공적으로 접근하면 Gitolite는 무조건 로그를 남긴다. 관리자가 한눈파는 사이에 되돌리기(&lt;code&gt;RW+&lt;/code&gt;) 권한을 가진 망나니가 &amp;#8220;master&amp;#8221; 브랜치를 날려버릴 수도 있다. 이 경우 로그 파일이 구원해줄 것이다. 이 로그 파일을 참고하여 버려진 SHA를 빠르고 쉽게 찾을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Git이 설치된 경로에 자유롭다&lt;/strong&gt;: 이것은 정말 편리하고 유용한 기능이다. Gitolite는 Git을 &lt;code&gt;$PATH&lt;/code&gt; 안에 찾을 수 있도록 설치하지 않아도 된다. 생각하는 것보다 자주 이럴 필요가 있다. 회사나 호스팅 업체는 시스템 전체에 영향이 끼쳐지도록 설치하지 못하게 한다. 그래서 결국엔 계정 디렉토리에 설치해야 한다. 그리고 &lt;em&gt;클라이언트 쪽&lt;/em&gt; 에서 어떤 이유로 표준 위치에 git을 설치하지 못할 수도 있다. Gitolite를 verbose 모드로 설치하면 &amp;#8220;rc&amp;#8221; 파일의 &amp;#8220;$GIT_PATH&amp;#8221;를 수정할 수 있다. 그 외 클라이언트에서 해야 할 일은 전혀 없다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;접근 권한 보여주기&lt;/strong&gt;: 만약 어떤 서버에서 작업을 시작하려고 할 때 필요한 것이 무엇일까? Gitolite는 해당 서버에 대해 접근할 수 있는 저장소가 무엇인지, 어떤 권한을 가졌는지 보여준다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    hello sitaram, the gitolite version here is v1.5.4-19-ga3397d4
    the gitolite config gives you the following access:
         R     anu-wsd
         R     entrans
         R  W  git-notes
         R  W  gitolite
         R  W  gitolite-admin
         R     indic_web_input
         R     shreelipi_converter&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;권한 위임&lt;/strong&gt;: 조직 규모가 크면 저장소에 대한 책임을 여러 사람이 나눠 가지는 게 좋다. 여러 사람이 각자 맡은 바를 관리하도록 할 수 있다. 그래서 주요 관리자의 업무가 줄어들기에 병목현상이 적어진다. 이 기능에 대해서는 &lt;code&gt;doc/&lt;/code&gt; 디렉토리에 포함된 Gitolite 문서를 참고하라.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Gitweb 지원&lt;/strong&gt;: Gitolite는 몇 가지 방법으로 Gitweb을 지원한다. Gitweb을 사용할 저장소가 무엇인지 명시할 수 있다. 그리고 Gitolite 설정 파일에서 &amp;#8220;owner&amp;#8221;와 &amp;#8220;description&amp;#8221; 항목을 Gitweb으로 가져올 수 있다. Gitolite 설정 파일을 HTTP 인증 설정 파일로 컴파일할 수 있고 Gitweb은 이 HTTP 인증 파일로 접근을 제어할 수 있다. 그래서 Gitweb과 Gitolite은 같은 접근 규칙을 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;미러링&lt;/strong&gt;: Gitolite의 미러는 여러 개 만들 수 있어서 주 서버가 다운 돼도 변경하면 된다.&lt;/p&gt;

&lt;h2 id='git_'&gt;Git 데몬&lt;/h2&gt;

&lt;p&gt;공개된 프로젝트는 누가 읽기 접근을 시도하는지 알 필요가 없다. 그래서 HTTP 프로토콜을 사용하거나 Git 프로토콜을 사용해야 한다. Git 프로토콜이 HTTP 프로토콜보다 효율적이기 때문에 속도가 빠르다. 그래서 결국 사용자는 절약할 수 있다.&lt;/p&gt;

&lt;p&gt;다시 강조하지만, 이것은 불특정 다수에게 읽기 접근을 허용할 때에만 유용하다. 만약 서버가 외부에 그냥 노출돼 있다면 우선 방화벽으로 보호하고 프로젝트를 외부에서 접근할 수 있게 만들어야 한다. 그리고 이미 서버를 방화벽으로 보호하고 있어도 사람이나 컴퓨터(CI 서버나 빌드 서버)가 읽기 접근을 할 수 있도록 SSH 키를 일일이 추가하고 싶지 않을 것이다.&lt;/p&gt;

&lt;p&gt;어쨌든 Git 프로토콜은 상대적으로 설치하기 쉽다. 그냥 데몬을 실행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git daemon --reuseaddr --base-path=/opt/git/ /opt/git/&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--reuseaddr&lt;/code&gt;는 서버가 기존의 연결이 타임아웃될 때까지 기다리지 말고 바로 재시작하게 하는 옵션이다. &lt;code&gt;--base-path&lt;/code&gt; 옵션을 사용하면 사람들이 프로젝트를 Clone할 때 전체 경로를 사용하지 않아도 된다. 그리고 마지막에 있는 경로는 노출할 저장소의 위치를 Git 데몬에 알려주는 것이다. 마지막으로 방화벽을 사용하고 있으면 9418 포트를 열어서 지금 작업하는 서버의 숨통을 틔워주어야 한다.&lt;/p&gt;

&lt;p&gt;운영체제에 따라 Git 데몬을 실행시키는 방법은 다르다. 우분투에서는 시작&lt;em&gt;Upstart&lt;/em&gt; 스크립트를 사용한다. 다음과 같이 파일을 만들고:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/etc/event.d/local-git-daemon&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음의 내용을 입력한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;start on startup
stop on shutdown
exec /usr/bin/git daemon \
    --user=git --group=git \
    --reuseaddr \
    --base-path=/opt/git/ \
    /opt/git/
respawn&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;저장소를 읽을 수만 있는 사용자로 데몬을 실행시킬 것을 보안을 위해 강력하게 권고한다. &lt;code&gt;git-ro&lt;/code&gt;라는 계정을 새로 만들고 그 계정으로 데몬을 실행시킨다. 여기에서는 쉽게 설명하려고 그냥 Gitosis를 실행했던 &lt;code&gt;git&lt;/code&gt; 계정으로 실행시킨다.&lt;/p&gt;

&lt;p&gt;서버가 재시작할 때 Git 데몬이 자동으로 실행되고 데몬이 죽어도 자동으로 재시작될 것이다. 서버는 놔두고 Git 데몬만 재시작할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;initctl start local-git-daemon&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다른 시스템에서는 &lt;code&gt;sysvinit&lt;/code&gt; 시스템의 &lt;code&gt;xinetd&lt;/code&gt; 스크립트를 사용하거나 자신만의 방법으로 해야 한다.&lt;/p&gt;

&lt;p&gt;아무나 읽을 수 있다는 것을 Gitosis 서버에 알려주어야 한다. Git 데몬으로 읽기 접근을 허용하는 저장소가 무엇인지 설정에 추가해야 한다. 만약 iphone 프로젝트에 Git 프로토콜을 허용했다면 다음과 같은 것을 &lt;code&gt;gitosis.conf&lt;/code&gt; 파일의 하단에 추가해야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[repo iphone_project]
daemon = yes&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;차례대로 커밋과 Push하고 나면 지금 실행 중인 데몬이 9418 포트로 접근하는 사람에게 서비스하기 시작할 것이다.&lt;/p&gt;

&lt;p&gt;Gitosis 없이도 Git 데몬을 설치할 수 있지만 그럴러면 서비스하고자 하는 프로젝트마다 다음과 같이 &lt;code&gt;git-daemon-export-ok&lt;/code&gt; 파일을 넣어 주어야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /path/to/project.git
$ touch git-daemon-export-ok&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 파일이 있으면 Git 데몬은 인증 없이 프로젝트를 노출하는 것으로 판단한다.&lt;/p&gt;

&lt;p&gt;또한, Gitweb으로 노출하는 프로젝트도 Gitosis로 제어할 수 있다. 먼저 &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; 파일에 다음과 같은 내용을 추가해야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$projects_list = &amp;quot;/home/git/gitosis/projects.list&amp;quot;;
$projectroot = &amp;quot;/home/git/repositories&amp;quot;;
$export_ok = &amp;quot;git-daemon-export-ok&amp;quot;;
@git_base_url_list = (&amp;#39;git://gitserver&amp;#39;);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gitosis 설정 파일에 &lt;code&gt;gitweb&lt;/code&gt; 설정을 넣거나 빼면 사용자는 GitWeb을 통해 프로젝트를 볼 수도 있고 못 볼 수도 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[repo iphone_project]
daemon = yes
gitweb = yes&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 이것을 커밋하고 Push하면 GitWeb을 통해 iphone 프로젝트를 볼 수 있다.&lt;/p&gt;

&lt;h2 id='hosted_git'&gt;Hosted Git&lt;/h2&gt;

&lt;p&gt;Git 서버를 설치하는 등의 일을 하고 싶지 않으면 전문 호스팅 사이트를 이용하면 된다. 호스팅 사이트는 몇 가지 장점이 있다. 설정이 쉬워서 바로 프로젝트를 시작할 수 있을 뿐만 아니라 직접 서버를 관리하고 모니터링하지 않아도 된다. 내부적으로 Git 서버를 직접 설치하고 운영하고 있어도 오픈소스 프로젝트는 호스팅 사이트를 이용하는 것이 좋다. 이렇게 하면 보통 오픈소스 커뮤니티로부터 좀 더 쉽게 도움받을 수 있다.&lt;/p&gt;

&lt;p&gt;요즘은 이용할 수 있는 호스팅 사이트들이 많다. 각각 장단점이 있기 때문에 Git 위키의 GitHosting 페이지에서 최신 정보를 확인해보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://git.or.cz/gitwiki/GitHosting&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 절에서 전부 설명할 수는 없고(나는 그 중 한군데에서 일한다) GitHub에 계정과 프로젝트를 만드는 방법을 설명한다.&lt;/p&gt;

&lt;p&gt;GitHub은 가장 큰 오픈소스 Git 호스팅 사이트이고 공개(Public) 프로젝트와 비공개(Private) 프로젝트에 대한 호스팅 서비스를 제공하는 보기 드문 사이트다. 그래서 상업용 비공개 코드와 공개 코드를 같은 곳에 둘 수 있다. 실제로 이 책도 GitHub에서 비공개로 작성했다.&lt;/p&gt;

&lt;h3 id='github'&gt;GitHub&lt;/h3&gt;

&lt;p&gt;GitHub는 프로젝트 네임스페이스가 다른 코드 호스팅 사이트들과 다르다. GitHub는 프로젝트가 아니라 사용자가 중심이다. GitHub에 &lt;code&gt;grit&lt;/code&gt; 프로젝트를 호스팅한다고 하면 &lt;code&gt;GitHub.com/grit&lt;/code&gt;이 아니라 &lt;code&gt;GitHub.com/schacon/grit&lt;/code&gt;으로 접속해야 한다. 그리고 처음 프로젝트를 시작한 사람이 그 프로젝트를 잊어버려도 누구나 프로젝트를 이어갈 수 있고 프로젝트의 주 저장소라고 해서 특별하지 않다.&lt;/p&gt;

&lt;p&gt;GitHub은 이윤을 목적으로 하는 회사이기 때문에 비공개 저장소를 만들려면 돈을 내야 한다. 하지만, 누구나 손쉽게 무료 계정을 만들어 오픈소스 프로젝트를 시작할 수 있다. 어떻게 사용하는지 간략하게 설명한다.&lt;/p&gt;

&lt;h3 id='_'&gt;계정 설정하기&lt;/h3&gt;

&lt;p&gt;먼저 무료 계정을 하나 만든다. 가격 정책에 대해 알려주며 가입을 시작할 수 있는 &lt;code&gt;http://github.com/plans&lt;/code&gt;에 방문하여 &amp;#8220;Sign up&amp;#8221; 버튼을 클릭한다. 그러면 가입 페이지로 이동한다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0402-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 4-2. GitHub 가격 정책 페이지.&lt;/p&gt;

&lt;p&gt;아직 등록되지 않은 사용자 이름을 입력하고 e-mail 주소와 암호를 입력한다(그림 4-3).&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0403-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 4-3. GitHub 가입 폼.&lt;/p&gt;

&lt;p&gt;그리고 SSH 공개키가 있으면 바로 등록한다. SSH 키를 만드는 방법은 &amp;#8220;초 간단 뚝딱&amp;#8221; 절에서 이미 설명했다. 그 공개키 파일의 내용을 복사해서 SSH 공개키 입력 박스에 붙여 넣는다. &amp;#8220;explain ssh keys&amp;#8221;링크를 클릭하면 key를 생성하는 방법이 자세히 설명돼 있다. 주요 운영체제에서 하는 방법이 모두 설명돼 있다. &amp;#8220;I agree, sign me up&amp;#8221; 버튼을 클릭하면 자신만의 대쉬보드 페이지를 볼 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0404-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 4-4. GitHub 사용자 대쉬보드&lt;/p&gt;

&lt;p&gt;그리고 저장소를 만들자.&lt;/p&gt;

&lt;h3 id='_'&gt;저장소 만들기&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Your Repositories&lt;/code&gt;옆에 있는 &amp;#8220;create a new one&amp;#8221; 링크를 클릭하면 저장소를 만드는 입력 폼을 볼 수 있다(그림 4-5).&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0405-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 4-5. GitHub의 저장소를 생성하는 폼.&lt;/p&gt;

&lt;p&gt;이 폼에 프로젝트 이름과 프로젝트 설명을 적는다. 다 적은 후에 &amp;#8220;Create Repository&amp;#8221; 버튼을 클릭하면 GitHub에 저장소가 생긴다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0406-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 4-6. GitHub 프로젝트 정보&lt;/p&gt;

&lt;p&gt;이 저장소에는 아직 코드가 없어서 GitHub은 프로젝트를 새로 만드는 방법, 이미 있는 Git 프로젝트를 Push하는 법, 공개된 Subversion 저장소에서 프로젝트를 가져오는(Import) 방법 등을 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0407-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 4-7. 새 저장소를 위한 사용설명서&lt;/p&gt;

&lt;p&gt;여기 설명하는 내용은 이미 우리가 배웠다. 프로젝트가 없을 때 다음과 같이 프로젝트를 초기화했었다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git init
$ git add .
$ git commit -m &amp;#39;initial commit&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 이미 로컬에 Git 저장소가 있으면 GitHub 저장소를 원격 저장소로 등록하고 master 브랜치를 Push한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote add origin git@GitHub.com:testinguser/iphone_project.git
$ git push origin master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 프로젝트가 GitHub에서 서비스되게 하였으니 공유하고 싶은 사람에게 URL을 알려 주면 된다. URL은 &lt;code&gt;http://github.com/testinguser/iphone_project&lt;/code&gt;이다. 그리고 이 저장소의 정보를 잘 살펴보면 Git URL이 두 개인 것을 발견할 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0408-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 4-8. 프로젝트의 공개 URL과 비공개 URL.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Public Clone URL&lt;/code&gt;은 말 그대로 누구나 프로젝트를 Clone할 수 있도록 모두에게 읽기 전용으로 공개하는 것이다. 이 URL을 다른 사람에 알려주거나 웹사이트 같은데 공개하는 것을 부담스러워 하지 않아도 된다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Your Clone URL&lt;/code&gt;은 읽고 쓸 수 있는 SSH 기반 URL이다. 사용자 계정에 등록한 공개키와 짝을 이루는 개인키를 통해서만 접속할 수 있다. 다른 사용자로 이 프로젝트에 방문하면 이 URL은 볼 수 없고 공개 URL만 볼 수 있다.&lt;/p&gt;

&lt;h3 id='subversion__import'&gt;Subversion으로부터 코드 가져오기(Import)&lt;/h3&gt;

&lt;p&gt;GitHub는 공개 중인 Subversion 프로젝트를 Git 프로젝트로 만들어 준다. 사용설명서 하단에 있는 &amp;#8220;Subversion에서 Import하기&amp;#8221; 링크를 클릭하면 임포트 폼을 볼 수 있고 거기에 Subversion 프로젝트의 URL을 넣는다(그림 4-9).&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0409-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 4-9. Subversion 프로젝트를 Import하는 화면&lt;/p&gt;

&lt;p&gt;프로젝트가 비표준 방식을 사용하거나 규모가 너무 크고 비공개라면, 이 기능을 사용할 수 없다. 7장에서 수동으로 임포트하는 방법에 대해 좀 더 자세히 배울 수 있다.&lt;/p&gt;

&lt;h3 id='_'&gt;동료 추가하기&lt;/h3&gt;

&lt;p&gt;동료를 추가하자. 먼저 John씨, Josie씨, Jessica씨를 모두 GitHub에 가입시키고 나서 그들을 동료로 추가하고 저장소에 Push할 수 있는 권한을 준다.&lt;/p&gt;

&lt;p&gt;프로젝트 페이지에 있는 Admin 버튼을 클릭해서 관리 페이지로 이동한다(그림 4-10).&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0410-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 4-10. GitHub의 프로젝트 관리 페이지&lt;/p&gt;

&lt;p&gt;다른 사람에게 쓰기 권한을 주려면 “Add another collaborator” 링크를 클릭한다. 그러면 텍스트 박스가 새로 나타나는 데 거기에 사용자 이름을 입력한다. 사용자이름을 입력하기 시작하면 자동으로 시스템에 존재하는 사용자를 찾아서 보여 준다. 원하는 사용자를 찾으면 Add 버튼을 클릭해서 그 사용자를 동료로 만든다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0411-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 4-11. 프로젝트에 동료 추가하기&lt;/p&gt;

&lt;p&gt;추가한 사람은 동료 목록 박스에서 모두 확인할 수 있다(그림 4-12).&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0412-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 4-12. 프로젝트 동료들.&lt;/p&gt;

&lt;p&gt;그리고 만약 다시 혼자 작업하고 싶어지면 &amp;#8220;revoke&amp;#8221; 링크를 클릭하여 쫓아낼 수 있다. 쫓겨나면 더는 Push할 수 없다. 또 나중에 기존 프로젝트를 참조할 수 있도록 동료를 그룹으로 묶을 수 있다.&lt;/p&gt;

&lt;h3 id='_'&gt;내 프로젝트&lt;/h3&gt;

&lt;p&gt;Subversion에서 Import했거나 로컬의 프로젝트를 Push하고 나면 프로젝트 메인 페이지가 그림 4-13같이 바뀐다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0413-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 4-13. GitHub의 프로젝트 메인 페이지&lt;/p&gt;

&lt;p&gt;사람들이 이 프로젝트에 방문하면 이 페이지가 제일 처음 보인다. 이 페이지는 몇 가지 탭으로 구성된다. Commits 탭은 지금까지의 커밋을 &lt;code&gt;git log&lt;/code&gt; 명령을 실행시킨 것처럼 최신 것부터 보여준다. Network 탭은 프로젝트를 복제한 사람들과 기여한 사람들을 모두 보여준다. Downloads 탭에는 바이너리 파일이나 프로젝트의 태그 버전을 압축해서 올릴 수 있다(역주, 지금은 이 탭이 없다. Gist 페이지에서 비슷한 기능을 제공한다). Wiki 탭은 프로젝트에 대한 정보나 문서를 쓰는 곳이다. Graphs 탭은 사람들의 활동을 그림과 통계로 보여준다. 메인 탭인 Source 탭은 프로젝트의 메인 디렉토리를 보여주고 README 파일이 있으면 자동으로 화면에 출력해 준다. 그리고 마지막 커밋 내용도 함께 보여준다.&lt;/p&gt;

&lt;h3 id='_fork'&gt;프로젝트 Fork&lt;/h3&gt;

&lt;p&gt;권한이 없는 프로젝트에 참여하고 싶으면 GitHub는 프로젝트를 Fork하도록 권고한다. 마침 매우 흥미롭게 보이는 프로젝트를 발견했다고 하자. 그 프로젝트를 조금 뜯어고치려면 프로젝트 페이지 상단에 있는 &amp;#8220;fork&amp;#8221; 버튼을 클릭한다. 그러면 GitHub는 접속한 사용자의 계정으로 프로젝트를 Fork해 준다. 사용자는 이 프로젝트에 마음대로 Push할 수 있다.&lt;/p&gt;

&lt;p&gt;굳이 Push할 수 있도록 사람들을 동료로 추가하지 않아도 된다. 사람들은 마음껏 프로젝트를 Fork하고 Push할 수 있다. 그리고 원래 프로젝트의 관리자는 다른 사람의 프로젝트를 원격 저장소로 추가하고 그 작업물을 가져와서 Merge한다.&lt;/p&gt;

&lt;p&gt;프로젝트 페이지에 들어가서 상단의 &amp;#8220;fork&amp;#8221; 버튼을 클릭하여 프로젝트를 복제한다(그림 4-14). 그림 4-14의 예는 mojombo/chronic 프로젝트 페이지이다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0414-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 4-14. 어떤 저장소든지 &amp;#8220;fork&amp;#8221; 버튼을 클릭하면 Push할 수 있는 저장소를 얻을 수 있다.&lt;/p&gt;

&lt;p&gt;클릭하는 순간, 이 프로젝트를 즉시 Fork한다(그림 4-15).&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0415-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 4-15. Fork한 프로젝트&lt;/p&gt;

&lt;h3 id='github_'&gt;GitHub 요약&lt;/h3&gt;

&lt;p&gt;빨리 한번 전체를 훑어보는 것이 중요하기 때문에 여기에서는 GitHub에 대해 이 정도로만 설명했다. 이제 계정과 프로젝트를 만들고 몇 분 만에 Push까지 할 수 있을 것이다. GitHub의 개발자 커뮤니티 규모는 매우 크기 때문에 만약 GitHub에 오픈 소스 프로젝트를 만들면 다른 개발자들이 당신의 프로젝트를 복제하고 당신을 도울 것이다. GitHub는 Git을 빨리 사용해 볼 수 있도록 돕는다.&lt;/p&gt;

&lt;h2 id='id57'&gt;요약&lt;/h2&gt;

&lt;p&gt;원격 저장소를 만들고 다른 사람과 협업하거나 작업물을 공개하는 방법은 여러 가지다.&lt;/p&gt;

&lt;p&gt;서버를 직접 구축하는 것은 할 일이 많은데다가 방화벽도 필요하다. 그리고 이렇게 서버를 만들고 관리하는 일에는 보통 시간이 많이 든다. 호스팅 사이트를 이용하면 쉽게 시작할 수 있다. 하지만, 코드를 타인의 서버에 보관해야 하기 때문에 사용하지 못하게 하는 조직들도 많다.&lt;/p&gt;

&lt;p&gt;우리가 속한 조직이 협업하려면 어떤 방법을 사용할지 고민해 봐야 할 시점이 되었다.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Pro Git - 3. Git 브랜치</title>
   <link href="http://ygpark.github.com/Pro Git/2012/08/29/pro-git-3-branching"/>
   <updated>2012-08-29T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Pro Git/2012/08/29/pro-git-3-branching</id>
   <content type="html">&lt;h1 id='git_'&gt;Git 브랜치&lt;/h1&gt;

&lt;p&gt;버전 관리 시스템은 모두 브랜치를 지원한다. 개발을 하다 보면 코드를 여러 개로 복사해야 하는 일들이 자주 생긴다. 코드를 통째로 복사하고 나서 원래 코드와는 상관없이 독립적으로 개발을 진행한다. 이렇게 독립적으로 개발하는 것이 브랜치다.&lt;/p&gt;

&lt;p&gt;버전 관리 시스템에서 브랜치를 만드는 과정은 보통 고생스럽다. 브랜치를 만들고자 개발자는 수동으로 소스코드 디렉토리를 복사하는 등의 일을 해야 하고 소스코드의 양이 많으면 브랜치를 만드는 시간도 오래 걸린다.&lt;/p&gt;

&lt;p&gt;사람들은 브랜치 모델이 Git의 최고의 장점이라고, Git이 다른 것들과 구분되는 특징이라고 말한다. 당최 어떤 점이 그렇게 특별한 것일까? Git의 브랜치는 매우 가볍다. 순식간에 브랜치를 새로 만들거나 브랜치 사이를 이동할 수 있다. 다른 버전 관리 시스템과는 달리 Git은 브랜치를 만들어 작업하고 나중에 Merge하는 방법을 권장한다. 심지어 하루에 수십 번씩이라고 해도 괜찮다. Git 브랜치에 능숙해지면 개발 방식이 완전히 바뀌고 다른 도구로 대체할 수 없게 된다.&lt;/p&gt;

&lt;h2 id='_'&gt;브랜치란 무엇인가?&lt;/h2&gt;

&lt;p&gt;Git이 브랜치하는 과정을 이해하려면 우선 Git이 데이터를 어떻게 저장하는지 알아야 한다. 1장의 내용을 보면 Git은 데이터를 &lt;code&gt;Change Set&lt;/code&gt;이나 변경사항(Diff)으로 기록하지 않고 일련의 Snapshot으로 기록한다.&lt;/p&gt;

&lt;p&gt;Git에서 커밋하면 Git은 현 Staging Area에 있는 데이터의 Snapshot에 대한 포인터, 저자나 커밋 메시지 같은 메타데이터, 이전 커밋에 대한 포인터 등을 포함하는 커밋 개체(Commit Object)를 저장한다. 이전 커밋 포인터가 있어서 현재 커밋이 무엇을 기준으로 바뀌었는지를 알 수 있다. 최초 커밋을 제외하고 늘 이전 커밋 포인터가 적어도 하나씩 있고 브랜치를 합친 Merge 커밋 같은 경우에는 이전 커밋 포인터가 여러 개 있다.&lt;/p&gt;

&lt;p&gt;예제를 보자. 파일이 3개 있는 디렉토리가 하나 있고 이 파일을 Staging Area에 저장하고 커밋해 보자. 파일을 Stage하면 Git 저장소에 파일을 저장하고(Git은 이것을 Blob이라고 부른다) Staging Area에 해당 파일의 체크섬을 저장한다(1장에서 살펴본 SHA-1을 사용한다).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add README test.rb LICENSE
$ git commit -m &amp;#39;initial commit of my project&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#8216;git commit&amp;#8217;으로 커밋하면 먼저 각 하위 디렉토리의 트리 개체와 체크섬을 만들어 저장소에 저장한다. 그다음에 커밋 개체를 만들고 메타데이터와 프로젝트 루트 디렉토리를 가리키는 포인터의 정보를 커밋 개체에 넣어 저장한다. 그래서 필요하면 Snapshot을 다시 만들어 저장할 수 있다.&lt;/p&gt;

&lt;p&gt;이 작업을 마치고 나면 Git 저장소에는 다섯 개의 데이터 개체가 생긴다. 각 파일에 대한 Blob 세 개, 파일과 디렉토리 구조가 들어 있는 트리 개체 하나, 메타데이터와 루트 트리를 가리키는 포인터가 담긴 커밋 개체 하나이다. 이것을 그림으로 그리면 그림 3-1과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0301-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-1. 저장소의 커밋 데이터.&lt;/p&gt;

&lt;p&gt;다시 파일을 수정하고 커밋을 하면 이전 커밋이 무엇인지도 저장한다. 커밋을 두 번 더 하면 그림 3-2과 같이 저장돼 있을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0302-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-2. Git 커밋의 개체 데이터.&lt;/p&gt;

&lt;p&gt;Git의 브랜치는 커밋 사이를 가볍게 이동할 수 있는 어떤 포인터 같은 것이다. 기본적으로 Git은 master 브랜치를 만든다. 최초로 커밋하면 Git은 master라는 이름의 브랜치를 만들어서 자동으로 가장 마지막 커밋을 가리키게 한다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0303-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-3. 가장 최근 커밋 정보를 가리키는 브랜치.&lt;/p&gt;

&lt;p&gt;브랜치를 하나 새로 만들면 어떨까? 브랜치를 하나 만들어서 놀자. 다음과 같이 &lt;code&gt;git branch&lt;/code&gt; 명령으로 testing 브랜치를 만든다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch testing&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;새로 만든 브랜치도 지금 작업하고 있던 마지막 커밋을 가리킨다(그림 3-4).&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0304-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-3. 커밋 개체를 가리키는 두 브랜치&lt;/p&gt;

&lt;p&gt;지금 작업 중인 브랜치가 무엇인지 Git은 어떻게 파악할까? 다른 버전 관리 시스템과는 달리 Git은 &amp;#8216;HEAD&amp;#8217;라는 특수한 포인터가 있다. 이 포인터는 지금 작업하는 로컬 브랜치를 가리킨다. 브랜치를 새로 만들었지만, Git은 아직 master 브랜치를 가리키고 있다. &lt;code&gt;git branch&lt;/code&gt; 명령은 브랜치를 만들기만 하고 브랜치를 옮기지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0305-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-1. HEAD는 현재 작업 중인 브랜치를 가리킴.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git checkout&lt;/code&gt; 명령으로 새로 만든 브랜치로 이동할 수 있다. testing 브랜치로 이동하려면 다음과 같이 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout testing&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 하면 HEAD는 testing 브랜치를 가리킨다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0306-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-6. HEAD는 옮겨간 다른 브랜치를 가리킨다.&lt;/p&gt;

&lt;p&gt;자, 이제 핵심이 보일 거다! 커밋을 새로 한 번 해보면:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vim test.rb
$ git commit -a -m &amp;#39;made a change&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결과는 그림 3-7과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0307-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-7. HEAD가 새 커밋을 가리키는 testing 브랜치의 모습&lt;/p&gt;

&lt;p&gt;이 부분이 흥미롭다. 새로 커밋해서 testing 브랜치는 앞으로 이동했다. 하지만, master 브랜치는 여전히 이전 커밋을 가리킨다. master 브랜치로 되돌아가면:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결과는 그림 3-8과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0308-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-8. HEAD가 Checkout한 브랜치로 이동함&lt;/p&gt;

&lt;p&gt;방금 실행한 명령이 한 일은 두 가지다. master 브랜치가 가리키는 커밋을 HEAD가 가리키게 하고 Working Directory의 파일도 그 시점으로 되돌려 놓았다. 앞으로 커밋을 하면 다른 브랜치의 작업들과 별개로 진행되기 때문에 testing 브랜치에서 임시로 작업해도 원래 master 브랜치로 돌아와서 하던 일을 계속할 수 있다.&lt;/p&gt;

&lt;p&gt;파일을 수정하고 다시 커밋을 해보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vim test.rb
$ git commit -a -m &amp;#39;made other changes&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;프로젝트 히스토리는 분리돼 진행한다(그림 3-9). 우리는 브랜치를 하나 만들어 그 브랜치에서 일을 좀 하고, 다시 원래 브랜치로 되돌아와서 다른 일을 했다. 각 두 작업 내용은 서로 독립적으로 각 브랜치에 존재한다. 커밋 사이를 자유롭게 이동하다가 때가 되면 두 브랜치를 Merge한다. 간단히 &lt;code&gt;branch&lt;/code&gt;와 &lt;code&gt;checkout&lt;/code&gt; 명령을 써서 말이다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0309-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-9. 브랜치 히스토리가 서로 독립적임&lt;/p&gt;

&lt;p&gt;실제로 Git의 브랜치는 어떤 한 커밋을 가리키는 40글자의 SHA-1 체크섬 파일에 불과하기 때문에 만들기도 지우기도 어렵지 않다. 새로 브랜치를 하나 만드는 것은 41바이트 크기의 파일을(40자와 줄 바꿈 문자) 하나 만드는 것에 불과하다.&lt;/p&gt;

&lt;p&gt;브랜치를 만들려면 프로젝트를 통째로 복사해야 하는 다른 버전 관리 도구와 Git의 차이를 극명하다. 통째로 복사하는 작업은 프로젝트 크기에 따라 다르겠지만 수십 초에서 수십 분까지 걸린다. 그에 비해 Git은 순식간이다. 게다가 커밋을 할 때마다 이전 커밋의 정보를 저장하기 때문에 Merge할 때 어디서부터(Merge Base) 합쳐야 하는지 안다. 이런 특징은 개발자들이 수시로 브랜치를 만들어 사용하게 한다.&lt;/p&gt;

&lt;p&gt;이제 왜 그렇게 브랜치를 수시로 만들고 사용해야 하는지 알아보자.&lt;/p&gt;

&lt;h2 id='_merge_'&gt;브랜치와 Merge의 기초&lt;/h2&gt;

&lt;p&gt;실제 개발과정에서 겪을 만한 예제를 살펴보자. 브랜치와 Merge는 보통 이런 식으로 진행한다:&lt;/p&gt;

&lt;p&gt;1. 작업 중인 웹사이트가 있다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;새로운 이슈를 처리할 새 Branch를 하나 생성.&lt;/li&gt;

&lt;li&gt;새로 만든 Branch에서 작업 중.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이때 중요한 문제가 생겨서 그것을 해결하는 Hotfix를 먼저 만들어야 한다. 그러면 다음과 같이 할 수 있다:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;새로운 이슈를 처리하기 이전의 운영(Production) 브랜치로 복원.&lt;/li&gt;

&lt;li&gt;Hotfix 브랜치를 새로 하나 생성.&lt;/li&gt;

&lt;li&gt;수정한 Hotfix 테스트를 마치고 운영 브랜치로 Merge. 4. 다시 작업하던 브랜치로 옮겨가서 하던 일 진행.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id='_'&gt;브랜치의 기초&lt;/h3&gt;

&lt;p&gt;먼저 커밋을 몇 번 했다고 가정하자.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0310-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-10. 현재 커밋 히스토리&lt;/p&gt;

&lt;p&gt;이슈 관리 시스템에 등록된 53번 이슈를 처리한다고 하면 이 이슈에 집중할 수 있는 브랜치를 새로 하나 만든다. Git은 어떤 이슈 관리 시스템에도 종속돼 있지 않다. 브랜치를 만들면서 Checkout까지 한 번에 하려면 &lt;code&gt;git checkout&lt;/code&gt; 명령에 &lt;code&gt;-b&lt;/code&gt;라는 옵션을 준다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -b iss53
Switched to a new branch &amp;#39;iss53&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 명령은 아래 명령을 줄여놓은 것이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch iss53
$ git checkout iss53&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그림 3-11은 위 명령의 결과를 나타낸다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0311-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-11. 브랜치 포인터를 새로 만듦&lt;/p&gt;

&lt;p&gt;iss53 브랜치를 Checkout했기 때문에(즉, HEAD는 iss53 브랜치를 가리킨다) 뭔가 일을 하고 커밋하면 iss53 브랜치가 앞으로 진행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vim index.html
$ git commit -a -m &amp;#39;added a new footer [issue 53]&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0312-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-12. 진행 중인 iss53 브랜치&lt;/p&gt;

&lt;p&gt;다른 상황을 가정해보자. 만드는 사이트에 문제가 생겨서 즉시 고쳐야 한다. 버그를 해결한 Hotfix에 &amp;#8216;iss53&amp;#8217;이 섞이는 것을 방지하기 위해 &amp;#8216;iss53&amp;#8217;와 관련된 코드를 어딘가에 저장해두고 원래 운영 환경의 소스로 복구해야 한다. Git을 사용하면 이런 노력을 들일 필요 없이 그냥 master 브랜치로 옮기면 된다.&lt;/p&gt;

&lt;p&gt;그렇지만, 브랜치를 이동하려면 해야 할 일이 있다. 아직 커밋하지 않은 파일이 Checkout할 브랜치와 충돌 나면 브랜치를 변경할 수 없다. 브랜치를 변경할 때에는 Working Directory를 정리하는 것이 좋다. 이런 문제를 다루는 방법은(주로, stashing이나 커밋 amending에 대해) 나중에 다룰 것이다. 지금은 작업하던 것을 모두 커밋하고 master 브랜치로 옮긴다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master
Switched to branch &amp;#39;master&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이때 Working Directory는 53번 이슈를 시작하기 이전의 모습으로 되돌려지기 때문에 새로운 문제에 집중할 수 있는 환경이 만들어진다. Git은 자동으로 Working Directory에 파일들을 추가하고, 지우고, 수정해서 Checkout한 브랜치의 Snapshot으로 되돌려 놓는다는 것을 기억해야 한다.&lt;/p&gt;

&lt;p&gt;hotfix라는 브랜치를 만들고 새로운 이슈를 해결할 때까지 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -b &amp;#39;hotfix&amp;#39;
Switched to a new branch &amp;#39;hotfix&amp;#39;
$ vim index.html
$ git commit -a -m &amp;#39;fixed the broken email address&amp;#39;
[hotfix]: created 3a0874c: &amp;#39;fixed the broken email address&amp;#39;
 1 files changed, 0 insertions(+), 1 deletions(-)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0313-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-13. master 브랜치에서 갈라져 나온 hotfix 브랜치&lt;/p&gt;

&lt;p&gt;운영 환경에 적용하려면 문제를 제대로 고쳤는지 테스트하고 master 브랜치에 합쳐야 한다. &lt;code&gt;git merge&lt;/code&gt; 명령으로 다음과 같이 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master
$ git merge hotfix
Updating f42c576..3a0874c
Fast forward
 README |    1 -
 1 files changed, 0 insertions(+), 1 deletions(-)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Merge 메시지에서 &amp;#8216;Fast forward&amp;#8217;가 보이는가? Merge할 브랜치가 가리키고 있던 커밋이 현 브랜치가 가리키는 것보다 &amp;#8216;앞으로 진행한&amp;#8217; 커밋이기 때문에 master 브랜치 포인터는 최신 커밋으로 이동한다. 이런 Merge 방식을 &amp;#8216;Fast forward&amp;#8217;라고 부른다. 다시 말해서 A 브랜치에서 다른 B 브랜치를 Merge할 때 B가 A 이후의 커밋을 가리키고 있으면 A가 그저 B의 커밋을 가리키게 할 뿐이다.&lt;/p&gt;

&lt;p&gt;이제 hotfix는 master 브랜치에 포함됐고 운영환경에 적용할 수 있다(그림 3-14).&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0314-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-14. Merge 후 hotfix 브랜치와 같은 것을 가리키는 master 브랜치&lt;/p&gt;

&lt;p&gt;문제를 급히 해결하고 master 브랜치에 적용하고 나면 다시 일하던 브랜치로 돌아가야 한다. 하지만, 그전에 필요없는 hotfix 브랜치를 삭제한다. &lt;code&gt;git branch&lt;/code&gt; 명령에 &lt;code&gt;-d&lt;/code&gt; 옵션을 주고 브랜치를 삭제한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch -d hotfix
Deleted branch hotfix (3a0874c).&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자 이제 이슈 53번을 처리하던 환경으로 되돌아가서 하던 일을 계속 하자(그림 3-15):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout iss53
Switched to branch &amp;#39;iss53&amp;#39;
$ vim index.html
$ git commit -a -m &amp;#39;finished the new footer [issue 53]&amp;#39;
[iss53]: created ad82d7a: &amp;#39;finished the new footer [issue 53]&amp;#39;
 1 files changed, 1 insertions(+), 0 deletions(-)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0315-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-15. master와 별개로 진행하는 iss53 브랜치&lt;/p&gt;

&lt;p&gt;위에서 작업한 hotfix가 iss53 브랜치에 영향을 끼치지 않는다는 점을 이해하는 것이 중요하다. &lt;code&gt;git merge master&lt;/code&gt; 명령으로 master 브랜치를 iss53 브랜치에 Merge하면 iss53 브랜치에 hotfix가 적용된다. 아니면 iss53 브랜치가 master에 Merge할 수 있는 수준이 될 때까지 기다렸다가 Merge하면 hotfix와 iss53가 합쳐진다.&lt;/p&gt;

&lt;h3 id='merge_'&gt;Merge의 기초&lt;/h3&gt;

&lt;p&gt;53번 이슈를 다 구현하고 master 브랜치에 Merge하는 과정을 살펴보자. master 브랜치에 Merge하는 것은 앞서 살펴본 hotfix 브랜치를 Merge하는 것과 비슷하다. &lt;code&gt;git merge&lt;/code&gt; 명령으로 합칠 브랜치에서 합쳐질 브랜치를 Merge하면 된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master
$ git merge iss53
Merge made by recursive.
 README |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hotfix를 Merge했을 때와 메시지가 다르다. 현 브랜치가 가리키는 커밋이 Merge할 브랜치의 조상이 아니므로 Git은 &amp;#8216;Fast-forward&amp;#8217;로 Merge하지 않는다. 이러면 Git은 각 브랜치가 가리키는 커밋 두 개와 공통 조상 하나를 사용하여 3-way Merge를 한다. 그림 3-16에 이 Merge에서 사용하는 커밋 세 개가 표시된다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0316-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-16. Git은 Merge에 필요한 공통 커밋을 자동으로 찾음&lt;/p&gt;

&lt;p&gt;단순히 브랜치 포인터를 최신 커밋으로 옮기는 게 아니라 3-way Merge의 결과를 별도의 커밋으로 만들고 나서 해당 브랜치가 그 커밋을 가리키도록 이동시킨다(그림 3-17). 그래서 이런 커밋은 부모가 여러 개고 Merge 커밋이라고 부른다.&lt;/p&gt;

&lt;p&gt;Git은 Merge하는데 필요한 최적의 공통 조상을 자동으로 찾는다. 이런 기능도 Git이 다른 버전 관리 시스템보다 나은 점이다. CVS나 Subversion 같은 버전 관리 시스템들은 개발자가 직접 공통 조상을 찾아서 Merge해야 한다. Git은 다른 시스템보다 Merge가 대단히 쉽다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0317-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-17. Git은 Merge할 때 Merge에 대한 정보가 들어 있는 커밋를 하나 만든다.&lt;/p&gt;

&lt;p&gt;iss53 브랜치를 master에 Merge하고 나면 iss53 브랜치는 더는 필요 없다. 다음 명령으로 브랜치를 삭제하고 이슈의 상태를 처리 완료로 표시한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch -d iss53&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='conflict_'&gt;충돌(Conflict)의 기초&lt;/h3&gt;

&lt;p&gt;가끔씩 3-way Merge가 실패할 때도 있다. Merge하는 두 브랜치에서 같은 파일의 한 부분을 동시에 수정하고 Merge하면 Git은 해당 부분을 Merge하지 못한다. 예를 들어, 53번 이슈와 hotfix가 같은 부분을 수정했다면 Git은 Merge하지 못하고 다음과 같은 충돌 메시지를 출력한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git은 Merge하지 못했다. 충돌을 개발자가 해결하지 않는 한 Merge할 수 없다. 일단 충돌이 일어나면 &lt;code&gt;git status&lt;/code&gt; 명령으로 어떤 파일에 충돌이 일어났는지 확인한다:&lt;/p&gt;

&lt;p&gt;Git은 성공적으로 Merge된 새 커밋을 만들어낼 수 없다. 변경사항의 충돌을 개발자가 해결하지 않는 한 Merge 과정을 진행할 수 없다. Merge 충돌이 일어났을 때 Git이 어떤 파일을 Merge 할 수 없었는지 살펴보려면 &lt;code&gt;git status&lt;/code&gt; 명령을 이용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[master*]$ git status
index.html: needs merge
# On branch master
# Changed but not updated:
#   (use &amp;#39;git add &amp;lt;file&amp;gt;...&amp;#39; to update what will be committed)
#   (use &amp;#39;git checkout -- &amp;lt;file&amp;gt;...&amp;#39; to discard changes in working directory)
#
#	unmerged:   index.html
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;충돌이 일어난 파일은 unmerged 상태로 표시된다. Git은 충돌이 난 부분을 표준 형식에 따라 표시해준다. 그러면 개발자는 해당 부분을 수동으로 해결한다. 충돌 난 부분은 다음과 같이 표시된다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD:index.html
&amp;lt;div id=&amp;#39;footer&amp;#39;&amp;gt;contact : email.support@github.com&amp;lt;/div&amp;gt;
=======
&amp;lt;div id=&amp;#39;footer&amp;#39;&amp;gt;
  please contact us at support@github.com
&amp;lt;/div&amp;gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; iss53:index.html&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;=======&lt;/code&gt; 위쪽의 내용은 HEAD 버전(merge 명령을 실행할 때 작업하던 master 브랜치)의 내용이고 아래쪽은 iss53 브랜치의 내용이다. 충돌을 해결하려면 위쪽이나 아래쪽 내용 중에서 고르거나 직접 새로 작성하여 Merge한다. 다음은 아예 새로 작성하여 충돌을 해결하는 예제다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;#39;footer&amp;#39;&amp;gt;
please contact us at email.support@github.com
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;충돌한 양쪽에서 조금씩 가져와서 새로 수정했다. 그리고 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 가 포함된 행을 삭제하였다. 이렇게 충돌한 부분을 해결하고 &lt;code&gt;git add&lt;/code&gt; 명령으로 다시 Git에 저장한다. 충돌을 쉽게 해결하기 위해 다른 Merge 도구도 이용할 수 있는데, &lt;code&gt;git mergetool&lt;/code&gt; 명령으로 실행한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git mergetool
merge tool candidates: kdiff3 tkdiff xxdiff meld gvimdiff opendiff emerge vimdiff
Merging the files: index.html

Normal merge conflict for &amp;#39;index.html&amp;#39;:
  {local}: modified
  {remote}: modified
Hit return to start merge resolution tool (opendiff):&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;내가 Mac을 사용해서 Git은 &lt;code&gt;opendiff&lt;/code&gt;를 실행해준다. 기본 도구 말고 사용할 수 있는 다른 Merge 도구도 있는데, &amp;#8216;merge tool candidates&amp;#8217; 부분에 보여준다. 여기에 표시된 도구 중 하나를 고를 수 있다. Merge 도구를 변경하는 방법은 7장에서 다룬다.&lt;/p&gt;

&lt;p&gt;Merge 도구를 종료하면 Git은 잘 Merge했는지 물어본다. 잘 마쳤다고 입력하면 자동으로 &lt;code&gt;git add&lt;/code&gt;를 수행해서 해당 파일을 Staging Area에 저장해준다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git status&lt;/code&gt; 명령으로 충돌이 해결된 상태인지 다시 한번 확인해볼 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git status
# On branch master
# Changes to be committed:
#   (use &amp;#39;git reset HEAD &amp;lt;file&amp;gt;...&amp;#39; to unstage)
#
#	modified:   index.html
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;충돌을 해결하고 나서 해당 파일이 Staging Area에 저장됐는지 확인했으면 &lt;code&gt;git commit&lt;/code&gt; 명령으로 Merge 한 것을 커밋한다. 충돌을 해결하고 Merge하는 것이면 커밋 메시지는 아래와 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Merge branch &amp;#39;iss53&amp;#39;

Conflicts:
  index.html
#
# It looks like you may be committing a MERGE.
# If this is not correct, please remove the file
# .git/MERGE_HEAD
# and try again.
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;어떻게 충돌을 해결했고 확신이 부족한 부분은 무엇을 어떻게 했는지 자세하게 기록한다. 자세한 기록은 나중에 이 Merge 커밋을 이해하는데 도움을 줄 것이다.&lt;/p&gt;

&lt;h2 id='_'&gt;브랜치 관리&lt;/h2&gt;

&lt;p&gt;지금까지 브랜치를 만들고, Merge하고, 삭제하는 방법에 대해서 살펴봤다. 브랜치를 관리하는 데 필요한 다른 명령들도 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git branch&lt;/code&gt; 명령은 단순히 브랜치를 만들고 삭제해 주기만 하는 것이 아니다. 아무런 옵션 없이 실행하면 브랜치의 목록을 보여준다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch
  iss53
* master
  testing&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt; 기호가 붙어 있는 master브랜치는 현재 Checkout해서 작업하는 브랜치를 나타낸다. 즉, 지금 수정한 내용에 대해서 커밋하면 master 브랜치에 커밋되고 포인터가 앞으로 한 단계 나아간다. &lt;code&gt;git branch -v&lt;/code&gt; 명령을 실행하면 각 브랜치에서 마지막 커밋 메시지도 함께 보여준다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch -v
  iss53   93b412c fix javascript issue
* master  7a98805 Merge branch &amp;#39;iss53&amp;#39;
  testing 782fd34 add scott to the author list in the readmes&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;각 브랜치가 지금 어떤 상태인지 확인하기에 좋은 옵션들이 있다. 현재 Checkout한 브랜치를 기준으로 Merge된 브랜치인지 그렇지 않은지 필터링해 볼 수 있다. &lt;code&gt;--merged&lt;/code&gt;와 &lt;code&gt;--no-merged&lt;/code&gt; 옵션을 사용하여 해당 목록을 볼 수 있는데, Git 1.5.6 이후 버전부터 사용할 수 있다. &lt;code&gt;git branch --merged&lt;/code&gt; 명령으로 이미 Merge한 브랜치 목록을 확인한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch --merged
  iss53
* master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;iss53 브랜치는 앞에서 이미 Merge했기 때문에 목록에 나타난다. &lt;code&gt;*&lt;/code&gt; 기호가 붙어 있지 않은 브랜치는 &lt;code&gt;git branch -d&lt;/code&gt; 명령으로 삭제해도 되는 브랜치다. 이미 다른 브랜치와 Merge 했기 때문에 삭제해도 정보를 잃지 않는다.&lt;/p&gt;

&lt;p&gt;반대로 현재 Checkout한 브랜치에 Merge하지 않은 브랜치를 살펴보려면 &lt;code&gt;git branch --no-merged&lt;/code&gt; 명령을 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch --no-merged
  testing&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위에서 나타나지 않던 다른 브랜치가 보인다. 아직 Merge하지 않은 커밋을 담고 있기 때문에 &lt;code&gt;git branch -d&lt;/code&gt; 명령으로 삭제되지 않는다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch -d testing
error: The branch &amp;#39;testing&amp;#39; is not an ancestor of your current HEAD.
If you are sure you want to delete it, run &amp;#39;git branch -D testing&amp;#39;.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Merge하지 않은 브랜치를 강제로 삭제하려면 &lt;code&gt;-D&lt;/code&gt; 옵션으로 삭제할 수 있다.&lt;/p&gt;

&lt;h2 id='_workflow'&gt;브랜치 Workflow&lt;/h2&gt;

&lt;p&gt;브랜치를 만들고 Merge하는 것을 어디에 써먹어야 할까? 이 절에서는 Git의 브랜치가 유용한 몇 가지 Workflow를 살펴본다. 개발 과정에 여기서 설명하는 Workflow를 적용하면 도움이 될 것이다.&lt;/p&gt;

&lt;h3 id='_longrunning_'&gt;긴 호흡(Long-Running) 브랜치&lt;/h3&gt;

&lt;p&gt;Git은 꼼꼼하게 3-way Merge를 사용하기 때문에 장기간에 걸쳐서 한 브랜치를 다른 브랜치와 여러 번 Merge하는 것도 어렵지 않다. 그래서 개발 과정에서 필요한 용도에 따라 브랜치를 만들어 두고 계속 사용할 수 있다. 그리고 정기적으로 브랜치를 다른 브랜치로 Merge한다:&lt;/p&gt;

&lt;p&gt;이런 접근법에 따라서 Git 개발자가 많이 선호하는 Workflow가 하나 있다. 배포했거나 배포할 코드들만 master 브랜치에 Merge해서 안정 버전의 코드만 master 브랜치에 두고 개발하고 안정화하기 위해 develop이나 next라는 브랜치를 추가로 만들어 사용한다. 이 브랜치는 언젠가 안정 상태가 되겠지만, 항상 안정 상태를 유지해야 하는 것이 아니다. 테스트를 거쳐서 안정적이라고 판단되면 master 브랜치에 Merge한다. 토픽 브랜치(앞서 살펴본 iss53 브랜치 같은 짧은 호흡 브랜치)에도 적용할 수 있는데, 해당 토픽을 처리하고 테스트해서 버그도 없고 안정적이면 그때 Merge한다.&lt;/p&gt;

&lt;p&gt;사실 우리가 얘기하는 것은 커밋을 가리키는 포인터에 대한 얘기다. 개발 브랜치는 공격적으로 히스토리를 만들어 나아가고 안정 브랜치는 이미 만든 히스토리를 뒤따르며 나아간다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0318-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-18. 안정적인 브랜치일수록 커밋 히스토리가 뒤쳐진다.&lt;/p&gt;

&lt;p&gt;실험실에서 충분히 테스트하고 실전에 배치하는 과정으로 보면 이해하기 쉽다(그림 3-19).&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0319-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-19. 각 브랜치를 하나의 실험실로 생각하면 쉽다.&lt;/p&gt;

&lt;p&gt;코드를 여러 단계로 나누어 안정성을 높여가며 운영할 수 있다. 큰 규모의 프로젝트라면 proposed 혹은 pu(proposed updates)라는 이름의 브랜치를 두어 next나 master 브랜치에 아직 Merge할 준비가 되지 않은 것을 일단 Merge시킨다.&lt;/p&gt;

&lt;p&gt;중요한 개념은 브랜치를 이용해 여러 단계에 걸쳐서 안정화하면서 충분히 안정화가 됐을 때 안정 브랜치로 Merge할 수 있다는 점이다. 다시 말해서 반드시 긴 호흡의 브랜치를 여러 개 만들어야 하는 것은 아니지만 정말 유용하다. 특히 규모가 크고 복잡한 프로젝트일수록 그 유용성이 발휘된다.&lt;/p&gt;

&lt;h3 id='_'&gt;토픽 브랜치&lt;/h3&gt;

&lt;p&gt;토픽 브랜치는 프로젝트 크기에 상관없이 유용하다. 토픽 브랜치는 어떤 한 가지 주제나 작업을 위해 만든 짧은 호흡의 브랜치다. 다른 버전 관리 시스템에서 이런 브랜치를 본 적이 없을 것이다. Git이 아닌 다른 버전 관리 도구에서는 브랜치를 하나 만드는 데 큰 비용이 든다. Git에서는 매우 일상적으로 브랜치를 만들고 Merge하고 삭제한다.&lt;/p&gt;

&lt;p&gt;앞서 사용했었던 iss53이나 hotfix 브랜치가 토픽 브랜치다. 우리는 브랜치를 새로 만들고 어느 정도 커밋하고 나서 다시 master 브랜치에 Merge하고 브랜치도 삭제해 보았다. 보통 주제별로 브랜치를 만들고 각각은 독립돼 있기 때문에 매우 쉽게 컨텍스트 사이를 옮겨 다닐 수 있다. 묶음별로 나눠서 일하면 내용별로 검토하기에도, 테스트하기에도 더 편하다. 각 작업을 하루든 한 달이든 유지하다가 master 브랜치에 Merge할 시점이 되면 순서에 관계없이 그때 Merge하면 된다.&lt;/p&gt;

&lt;p&gt;master 브랜치를 checkout한 상태에서 어떤 작업을 한다고 해보자. 한 이슈를 처리하기 위해서 iss91라는 브랜치를 만들고 해당 작업을 한다. 어쩌면 같은 이슈를 다른 방법으로 해결해볼 수도 있다. iss91v2라는 브랜치를 만들고 다른 방법을 시도해 본다. 확신할 수 없는 아이디어를 적용해보기 위해 다시 master 브랜치로 되돌아가서 dumbidea 브랜치를 하나 더 만든다. 지금까지 말했던 커밋 히스토리는 그림 3-20과 같을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0320-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-20. 여러 토픽 브랜치에 대한 커밋 히스토리&lt;/p&gt;

&lt;p&gt;이슈를 처리했던 방법 중 두 번째 방법인 iss91v2 브랜치가 괜찮아서 적용하기로 결정을 내렸다. 그리고 아이디어를 확신할 수 없었던 dumbidea 브랜치를 같이 일하는 다른 개발자에게 보여줬더니 썩 괜찮다는 반응을 얻었다. iss91 브랜치는 (C5, C6 커밋도 함께) 버리고 다른 두 브랜치를 Merge하면 그림 3-21과 같이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0321-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-21. dumbidea와 iss91v2 브랜치를 Merge하고 난 후의 모습&lt;/p&gt;

&lt;p&gt;지금까지 했던 작업은 전부 로컬에서만 처리된다는 것을 꼭 기억해야 한다. 로컬 저장소에서만 브랜치를 만들고 Merge했으며 서버와 통신을 주고받는 일은 없었다.&lt;/p&gt;

&lt;h2 id='_'&gt;원격 브랜치&lt;/h2&gt;

&lt;p&gt;원격 브랜치란 원격 저장소에 있는 브랜치를 말한다. 사실 원격 브랜치도 로컬에 있지만 멋대로 옮기거나 할 수 없고 원격 저장소와 통신하면 자동으로 업데이트된다. 원격 브랜치는 원격 저장소에서 마지막으로 데이터를 가져온 시점의 브랜치 상태를 알려주는 책갈피라고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;원격 브랜치의 이름은 (remote)/(branch) 형식으로 되어 있다. 예를 들어 원격 저장소 origin의 master 브랜치를 보고 싶다면 origin/master라는 이름으로 브랜치를 확인하면 된다. 다른 팀원과 함께 어떤 이슈를 구현할 때 그 팀원이 iss53 브랜치를 서버로 Push했고 당신도 로컬에 iss53 브랜치가 있다고 가정하자. 이때 서버가 가리키는 iss53 브랜치는 로컬에서 origin/iss53이 가리키는 커밋이다.&lt;/p&gt;

&lt;p&gt;다소 헷갈릴 수 있으니 예제를 좀 더 살펴보자. &lt;code&gt;git.ourcompany.com&lt;/code&gt; 이라는 Git 서버가 있고 이 서버의 저장소를 하나 Clone하면 Git은 자동으로 origin이라는 이름을 붙인다. origin으로부터 저장소 데이터를 모두 내려받고 나서 master 브랜치를 가리키는 포인터를 만든다. 이 포인터는 origin/master라고 부르고 멋대로 조종할 수 없다. 그리고 Git은 로컬의 master 브랜치가 origin/master를 가리키게 한다. 이제 이 master 브랜치에서 작업을 시작할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0322-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-22. 저장소를 Clone하면 로컬 master 브랜치, 원격 저장소의 master 브랜치를 가리키는 origin/master 브랜치가 생김&lt;/p&gt;

&lt;p&gt;로컬 저장소에서 어떤 작업을 하고 있는데 동시에 다른 팀원이 &lt;code&gt;git.ourcompany.com&lt;/code&gt; 서버에 Push하고 master 브랜치를 업데이트한다. 그러면 이제 팀원 간의 히스토리는 서로 달라진다. 또한, 서버 저장소로부터 어떤 데이터도 주고받지 않으면 origin/master 포인터는 항상 그대로다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0323-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-24. 로컬과 서버의 커밋 히스토리는 독립적임.&lt;/p&gt;

&lt;p&gt;원격 서버로부터 저장소 정보를 동기화하려면 &lt;code&gt;git fetch origin&lt;/code&gt; 명령을 사용한다. 명령을 실행하면 우선 origin 서버의 주소 정보(이 예에서는 &lt;code&gt;git.ourcompany.com&lt;/code&gt;)를 찾아서, 현재 로컬의 저장소가 갖고 있지 않은 새로운 정보가 있다면 모두 내려받고, 받은 데이터를 로컬 저장소에 업데이트하고 나서, origin/master 포인터의 위치를 최신 커밋으로 이동시킨다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0324-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-24. Git의 Fetch 명령은 원격 브랜치 정보를 업데이트한다.&lt;/p&gt;

&lt;p&gt;원격 저장소를 여러 개 운영하는 상황을 이해할 수 있도록 개발용으로 사용할 Git 저장소를 팀 내부에 하나 추가해 보자.&lt;/p&gt;

&lt;p&gt;이 저장소의 주소가 &lt;code&gt;git.team1.ourcompany.com&lt;/code&gt; 이면 2장에서 살펴본 &lt;code&gt;git remote add&lt;/code&gt; 명령으로 현재 작업 중인 프로젝트에 팀의 저장소를 추가한다. 긴 서버 주소 대신 사용할 이름을 teamone으로 짓는다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0325-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-25. 서버를 원격 저장소로 추가하기&lt;/p&gt;

&lt;p&gt;서버를 추가하고 나면 &lt;code&gt;git fetch teamone&lt;/code&gt; 명령으로 teamone 서버의 데이터를 내려받는다. 명령을 실행해도 teamone 서버의 데이터는 모두 origin 서버에도 있는 것들이라서 아무것도 내려받지 않는다. 하지만, 이 명령을 실행하면 teamone/master 브랜치의 포인터가 temone의 master 브랜치와 가리키는 것을 가리키게 한다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0326-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-26. 로컬 저장소에 만들어진 teamone의 master 브랜치를 가리키는 포인터&lt;/p&gt;

&lt;h3 id='push'&gt;Push하기&lt;/h3&gt;

&lt;p&gt;로컬의 브랜치를 서버로 전송하려면 쓰기 권한이 있는 원격 저장소에 Push해야 한다. 로컬 저장소의 브랜치는 자동으로 원격 저장소로 전송되지 않는다. 명시적으로 브랜치를 Push해야 정보가 전송된다. 따라서 원격 저장소에 전송하지 않고 로컬 브랜치에만 두는 비공개 브랜치를 만들 수 있다. 또 다른 사람과 협업하기 위해 토픽 브랜치만 전송할 수도 있다.&lt;/p&gt;

&lt;p&gt;serverfix라는 브랜치를 다른 사람과 공유할 때에도 브랜치를 처음 Push하는 것과 같은 방법으로 Push한다. 다음과 같이 &lt;code&gt;git push (remote) (branch)&lt;/code&gt; 명령을 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin serverfix
Counting objects: 20, done.
Compressing objects: 100% (14/14), done.
Writing objects: 100% (15/15), 1.74 KiB, done.
Total 15 (delta 5), reused 0 (delta 0)
To git@github.com:schacon/simplegit.git
 * [new branch]      serverfix -&amp;gt; serverfix&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 메시지에는 숨겨진 내용이 많다.&lt;/p&gt;

&lt;p&gt;Git은 serverfix라는 브랜치 이름을 &lt;code&gt;refs/heads/serverfix:refs/heads/serverfix&lt;/code&gt;로 확장한다. 이것은 serverfix라는 로컬 브랜치를 서버로 Push하는데 리모트의 serverfix 브랜치로 업데이트한다는 것을 의미한다. 나중에 9장에서 &lt;code&gt;refs/heads/&lt;/code&gt;의 뜻을 자세히 알아볼 것이기 때문에 일단 넘어가도록 한다. &lt;code&gt;git push origin serverfix:serverfix&lt;/code&gt;라고 Push하는 것도 같은 의미인데 이것은 &amp;#8216;로컬의 serverfix 브랜치를 원격 저장소의 serverfix 브랜치로 Push하라&amp;#8217;라는 뜻이다. 로컬 브랜치의 이름과 원격 서버의 브랜치 이름이 다를 때 필요하다. 원격 저장소에 serverfix라는 이름 대신 다른 이름을 사용하려면 &lt;code&gt;git push origin serverfix:awesomebranch&lt;/code&gt;처럼 사용한다.&lt;/p&gt;

&lt;p&gt;나중에 누군가 저장소를 Fetch하고 나서 서버에 있는 serverfix 브랜치에 접근할 때 origin/serverfix라는 이름으로 접근할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch origin
remote: Counting objects: 20, done.
remote: Compressing objects: 100% (14/14), done.
remote: Total 15 (delta 5), reused 0 (delta 0)
Unpacking objects: 100% (15/15), done.
From git@github.com:schacon/simplegit
 * [new branch]      serverfix    -&amp;gt; origin/serverfix&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 짚고 넘어가야 할 게 있다. Fetch 명령으로 원격 브랜치를 내려받는다고 해서 로컬 저장소에 수정할 수 있는 브랜치가 새로 생기는 것이 아니다. 다시 말해서 serverfix라는 브랜치가 생기는 것이 아니라 그저 수정 못 하는 origin/serverfix 브랜치 포인터가 생기는 것이다.&lt;/p&gt;

&lt;p&gt;새로 받은 브랜치의 내용을 Merge하려면 &lt;code&gt;git merge origin/serverfix&lt;/code&gt; 명령을 사용한다. Merge하지 않고 원격 브랜치에서 시작하는 새 브랜치를 만들려면 아래와 같은 명령을 사용한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -b serverfix origin/serverfix
Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.
Switched to a new branch &amp;#39;serverfix&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그러면 origin/serverfix에서 시작하고 수정할 수 있는 serverfix라는 로컬 브랜치가 만들어진다.&lt;/p&gt;

&lt;h3 id='_tracking'&gt;브랜치 추적(Tracking)&lt;/h3&gt;

&lt;p&gt;원격 브랜치를 로컬 브랜치로 Checkout하면 자동으로 추적 브랜치(Tracking Branch)가 만들어진다. 추적 브랜치는 원격 브랜치와 직접적인 연결고리가 있는 로컬 브랜치이다. 추적 브랜치에서 &lt;code&gt;git push&lt;/code&gt; 명령을 내려도 Git은 연결고리가 있어서 어떤 원격 저장소에 Push해야 하는지 알 수 있다. 또한 &lt;code&gt;git pull&lt;/code&gt; 명령을 내리면 원격 저장소로부터 데이터를 내려받아 연결된 원격 브랜치와 자동으로 Merge한다.&lt;/p&gt;

&lt;p&gt;서버로부터 저장소를 Clone해올 때도 Git은 자동으로 master 브랜치를 origin/master 브랜치의 추적 브랜치로 만든다. 그래서 &lt;code&gt;git push&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt; 명령이 추가적인 인자 없이도 동작할 수 있다. 추적 브랜치를 직접 만들 수 있는데 origin/master뿐만 아니라 다른 저장소의 다른 브랜치도 추적하게 할 수 있다. &lt;code&gt;git checkout -b [branch] [remotename]/[branch]&lt;/code&gt; 명령으로 간단히 추적 브랜치를 만들 수 있다. Git 1.6.2 버전 이상을 사용하는 경우에는 &amp;#8211;track 옵션도 사용할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.
Switched to a new branch &amp;#39;serverfix&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;원격 브랜치와 다른 이름으로 브랜치를 만들려면 로컬 브랜치의 이름을 아래와 같이 다르게 지정한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -b sf origin/serverfix
Branch sf set up to track remote branch refs/remotes/origin/serverfix.
Switched to a new branch &amp;#39;sf&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 sf 브랜치에서 Push나 Pull하면 자동으로 origin/serverfix에 데이터를 보내거나 가져온다.&lt;/p&gt;

&lt;h3 id='__'&gt;원격 브랜치 삭제&lt;/h3&gt;

&lt;p&gt;동료와 협업하기 위해 원격 브랜치를 만들었다가 작업을 마치고 master 브랜치로 Merge했다. 협업하는 데 사용했던 그 원격 브랜치는 이제 안정화됐으므로 삭제할 수 있다. &lt;code&gt;git push [remotename] :[branch]&lt;/code&gt;라고 실행해서 삭제할 수 있는데 이 명령은 좀 특이하게 생겼다. serverfix라는 원격 브랜치를 삭제하려면 다음과 같이 실행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin :serverfix
To git@github.com:schacon/simplegit.git
 - [deleted]         serverfix&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위 명령을 실행하고 나면 서버의 브랜치는 삭제된다. 이 명령을 잊어버릴 경우를 대비해서 페이지 귀퉁이를 접어놓고 필요할 때 펴보는 게 좋을지도 모르겠다. 이 명령은 앞서 살펴본 &lt;code&gt;git push [remotename] [localbranch]:[remotebranch]&lt;/code&gt; 형식으로 기억하는 것이 좋다. &lt;span&gt;localbranch&lt;/span&gt; 부분에 비워 둔 채로 실행하면 &amp;#8216;로컬에서 빈 내용을 원격의 &lt;span&gt;remotebranch&lt;/span&gt;에 채워 넣어라&amp;#8217; 라는 뜻이 되기 때문이다.&lt;/p&gt;

&lt;h2 id='rebase'&gt;Rebase하기&lt;/h2&gt;

&lt;p&gt;Git에서 한 브랜치에서 다른 브랜치로 합치는 방법은 두 가지가 있다. 하나는 Merge이고 다른 하나는 Rebase다. 이 절에서는 Rebase가 무엇인지, 어떻게 사용하는지, 좋은 점은 뭐고, 어떤 상황에서 사용하지 말아야 하는지 알아볼 것이다.&lt;/p&gt;

&lt;h3 id='rebase_'&gt;Rebase의 기초&lt;/h3&gt;

&lt;p&gt;앞의 Merge 절에서 살펴본 예제로 다시 돌아가 보자(그림 3-27). 두 개의 나누어진 브랜치의 모습을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0327-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-27. 두 개의 브랜치로 나누어진 커밋 히스토리&lt;/p&gt;

&lt;p&gt;이 두 브랜치를 합치는 가장 쉬운 방법은 앞에서 살펴본 대로 Merge 명령을 사용하는 것이다. 두 브랜치의 마지막 커밋 두 개(C3, C4)와 공통 조상(C2)을 사용하는 3-way Merge로 그림 3-28처럼 새로운 커밋을 만들어 낸다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0328-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-28. 나뉜 브랜치를 Merge하기&lt;/p&gt;

&lt;p&gt;비슷한 결과를 만드는 다른 방식으로, C3에서 변경된 사항을 패치(Patch)로 만들고 이를 다시 C4에 적용시키는 방법이 있다. Git에서는 이런 방식을 &lt;em&gt;Rebase&lt;/em&gt; 라고 한다. Rebase 명령으로 한 브랜치에서 변경된 사항을 다른 브랜치에 적용할 수 있다.&lt;/p&gt;

&lt;p&gt;위의 예제는 다음과 같은 명령으로 Rebase한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실제로 일어나는 일을 설명하자면 일단 두 브랜치가 나뉘기 전인 공통 커밋으로 이동하고 나서 그 커밋부터 지금 Checkout한 브랜치가 가리키는 커밋까지 diff를 차례로 만들어 어딘가에 임시로 저장해 놓는다. Rebase할 브랜치(역주 - experiment)가 합칠 브랜치(역주 - master)가 가리키는 커밋을 가리키게 하고 아까 저장해 놓았던 변경사항을 차례대로 적용한다. 그림 3-29는 이러한 과정을 나타내고 있다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0329-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-29. C3의 변경사항을 C4에 적용하는 Rebase 과정&lt;/p&gt;

&lt;p&gt;그리고 나서 master 브랜치를 Fast-forward 시킨다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0330-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-30. master 브랜치를 Fast-forward시키기&lt;/p&gt;

&lt;p&gt;C3&amp;#8217;로 표시된 커밋에서의 내용은 Merge 예제에서 살펴본 C5 커밋에서의 내용과 같을 것이다. Merge이든 Rebase든 둘 다 합치는 관점에서는 서로 다를 게 없다. 하지만, Rebase가 좀 더 깨끗한 히스토리를 만든다. Rebase한 브랜치의 Log를 살펴보면 히스토리가 선형적이다. 일을 병렬로 동시에 진행해도 Rebase하고 나면 모든 작업이 차례대로 수행된 것처럼 보인다.&lt;/p&gt;

&lt;p&gt;Rebase는 보통 원격 브랜치에 커밋을 깔끔하게 적용하고 싶을 때 사용한다. 아마 이렇게 Rebase하는 원격 브랜치는 직접 관리하는 것이 아니라 그냥 참여하는 브랜치일 것이다. 메인 프로젝트에 패치를 보낼 준비가 되면 하는 것이 Rebase이니까 브랜치에서 하던 일을 완전히 마치고 origin/master로 Rebase한다. 프로젝트 관리자는 어떠한 통합작업도 필요 없다. 그냥 master 브랜치를 Fast-forward 시키면 된다.&lt;/p&gt;

&lt;p&gt;Rebase를 하든지, Merge를 하든지 최종 결과물은 같고 커밋 히스토리만 다르다는 것이 중요하다. Rebase의 경우는 브랜치의 변경사항을 순서대로 다른 브랜치에 적용하면서 합치고 Merge의 경우는 두 브랜치의 최종결과만을 가지고 합친다.&lt;/p&gt;

&lt;h3 id='rebase'&gt;Rebase질&lt;/h3&gt;

&lt;p&gt;Rebase는 단순히 브랜치를 합치는 것만 아니라 다른 용도로도 사용할 수 있다. 그림 3-31과 같은 히스토리가 있다고 하자. server 브랜치를 만들어서 서버 기능을 추가하고 그 브랜치에서 다시 client 브랜치를 만들어 클라이언트 기능을 추가한다. 마지막으로 server 브랜치로 돌아가서 몇 가지 기능을 더 추가한다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0331-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-31. 다른 토픽 브랜치에서 갈라져 나온 토픽 브랜치.&lt;/p&gt;

&lt;p&gt;이때 테스트가 덜 된 server 브랜치는 그대로 두고 client 브랜치만 master로 합치려는 상황을 생각해보자. server와는 아무 관련이 없는 client 커밋은 C8, C9이다. 이 두 커밋을 master 브랜치에 적용하기 위해서 &lt;code&gt;--onto&lt;/code&gt; 옵션을 사용하여 아래와 같은 명령을 실행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase --onto master server client&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 client 브랜치를 Checkout하고 server와 client의 공통조상 이후의 패치를 만들어 master에 적용한다. 조금 복잡하긴 해도 꽤 쓸모 있다. 그림 3-32를 보자.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0332-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-32. 다른 토픽 브랜치에서 갈라져 나온 토픽 브랜치를 Rebase하기.&lt;/p&gt;

&lt;p&gt;이제 master 브랜치로 돌아가서 Fast-forward 시킬 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master
$ git merge client&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0333-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-33. master 브랜치를 client 브랜치 위치로 진행 시키기.&lt;/p&gt;

&lt;p&gt;server 브랜치의 일이 다 끝나면 &lt;code&gt;git rebase [basebranch] [topicbranch]&lt;/code&gt;라는 명령으로 Checkout하지 않고 바로 server 브랜치를 master 브랜치로 rebase할 수 있다. 이 명령은 토픽(server) 브랜치를 Checkout하고 베이스(master) 브랜치에 Rebase한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase master server&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;server 브랜치의 수정사항을 master 브랜치에 적용했다. 그 결과는 그림 3-34와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0334-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-34. master 브랜치에 server 브랜치의 수정 사항을 적용&lt;/p&gt;

&lt;p&gt;그리고 나서 master 브랜치를 Fast-forward 시킨다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master
$ git merge server&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;모든 것이 master 브랜치에 통합됐기 때문에 더 필요하지 않다면 client나 server 브랜치를 삭제해도 된다. 브랜치를 삭제해도 커밋 히스토리는 그림 3-35와 같이 여전히 남아 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch -d client
$ git branch -d server&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0335-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-35. 최종 커밋 히스토리.&lt;/p&gt;

&lt;h3 id='rebase_'&gt;Rebase의 위험성&lt;/h3&gt;

&lt;p&gt;Rebase가 장점이 많은 기능이지만 단점이 없는 것은 아니니 조심해야 한다. 그 주의사항은 다음 한 문장으로 표현할 수 있다:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이미 공개 저장소에 Push한 커밋을 Rebase하지 마라&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 지침만 지키면 Rebase를 하는 데 문제 될 게 없다. 하지만, 이 주의사항을 지키지 않으면 사람들에게 욕을 먹을 것이다(역주 - 아마도 가카의 호연지기가 필요해질 것이다).&lt;/p&gt;

&lt;p&gt;Rebase는 기존의 커밋을 그대로 사용하는 것이 아니라 내용은 같지만 다른 커밋을 새로 만든다. 새 커밋을 서버에 Push하고 동료 중 누군가가 그 커밋을 Pull해서 작업을 한다고 하자. 그런데 그 커밋을 &lt;code&gt;git rebase&lt;/code&gt;로 바꿔서 Push해버리면 동료가 다시 Push했을 때 동료는 다시 Merge해야 한다. 그리고 동료가 다시 Merge한 내용을 Pull하면 내 코드는 정말 엉망이 된다.&lt;/p&gt;

&lt;p&gt;이미 공개 저장소에 Push한 커밋을 Rebase하면 어떤 결과가 초래되는지 예제를 통해 알아보자. 중앙 저장소에서 Clone하고 일부 수정을 하면 커밋 히스토리는 그림 3-36과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0336-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-36. 저장소를 Clone하고 일부 수정함.&lt;/p&gt;

&lt;p&gt;이제 팀원 중 누군가 커밋, Merge하고 나서 서버에 Push 한다. 이 원격 브랜치를 Fetch, Merge하면 그림 3-47과 같이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0337-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-37. Fetch한 후 Merge함.&lt;/p&gt;

&lt;p&gt;그런데 Push했던 팀원은 Merge한 일을 되돌리고 다시 Rebase한다. 서버의 히스토리를 새로 덮어씌우려면 &lt;code&gt;git push --force&lt;/code&gt; 명령을 사용해야 한다. 이후에 저장소에서 Fetch하고 나면 아래 그림과 같은 상태가 된다:&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0338-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-38. 한 팀원이 다른 팀원이 의존하는 커밋을 없애고 Rebase한 커밋을 다시 Push함.&lt;/p&gt;

&lt;p&gt;기존 커밋이 사라졌기 때문에 이미 처리한 일이라고 해도 다시 Merge해야 한다. Rebase는 커밋의 SHA-1 해시를 바꾸기 때문에 Git은 새로운 커밋으로 생각한다. 사실 C4는 이미 히스토리에 적용되어 있지만, Git은 모른다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0339-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 3-39. 같은 Merge를 다시 한다.&lt;/p&gt;

&lt;p&gt;다른 개발자와 계속 같이 일하려면 이런 Merge도 해야만 한다. Merge하면 C4와 C4&amp;#8217; 커밋 둘 다 히스토리에 남게 된다. 실제 내용과 메시지가 같지만 SHA-1 해시 값이 전혀 다르다. &lt;code&gt;git log&lt;/code&gt;로 히스토리를 확인해보면 저자, 커밋 날짜, 메시지가 같은 커밋이 두 개 있을 것이다. 이렇게 되면 혼란스럽다. 게다가 이 히스토리를 서버에 Push하면 같은 커밋이 두 개 있기 때문에 다른 사람들도 혼란스러워한다.&lt;/p&gt;

&lt;p&gt;Push하기 전에 정리하려고 Rebase하는 것은 괜찮다. 또 절대 공개하지 않고 혼자 Rebase하는 경우도 괜찮다. 하지만, 이미 공개하여 사람들이 사용하는 커밋을 Rebase하면 틀림없이 문제가 생길 것이다.&lt;/p&gt;

&lt;h2 id='id45'&gt;요약&lt;/h2&gt;

&lt;p&gt;우리는 이 장에서 Git으로 브랜치를 만들고 Merge 기능의 기본적인 명령을 다루었다. 이제 브랜치를 만들고 옮겨다니고 Merge하는 것에 익숙해졌을 것으로 생각한다. 브랜치를 Push하여 공유하거나 Push하기 전에 브랜치를 Rebase하는 것 정도는 어렵지 않게 할 수 있을 것이다.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Pro Git - 2. Git의 기초</title>
   <link href="http://ygpark.github.com/Pro Git/2012/08/29/pro-git-2-git-basics"/>
   <updated>2012-08-29T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Pro Git/2012/08/29/pro-git-2-git-basics</id>
   <content type="html">&lt;h1 id='git_'&gt;Git의 기초&lt;/h1&gt;

&lt;p&gt;Git을 사용하는 방법을 알고 싶은데 단 한 챕터밖에 읽을 시간이 없을 때 2장이 딱 맞다. Git을 사용하면서 자주 사용하는 명령어들은 모두 2장에 등장한다. 2장을 다 읽으면 저장소를 만들고 설정하는 방법, 파일을 추적하거나(Track) 추적을 그만두는 방법, 변경 내용을 Stage하고 커밋할 수 있는 방법을 알 수 있다. 우리는 또 특정 파일이나 파일의 패턴을 무시하도록 Git을 설정하는 방법, 실수를 쉽고 빠르게 만회하는 방법, 프로젝트의 히스토리를 조회하고 커밋을 서로 비교하는 방법, 원격 저장소에 Push하고 Pull하는 방법을 살펴볼 것이다.&lt;/p&gt;

&lt;h2 id='git__'&gt;Git 저장소 만들기&lt;/h2&gt;

&lt;p&gt;보통 프로젝트의 Git 저장소를 만드는 방법은 두 가지다. 하나는 기존에 있는 프로젝트를 Git 저장소로 만드는 방법이고 하나는 다른 서버에 있는 저장소를 Clone하는 것이다.&lt;/p&gt;

&lt;h3 id='_____'&gt;이미 있는 디렉토리에서 새 저장소 만들기&lt;/h3&gt;

&lt;p&gt;이미 있는 프로젝트를 추적하고 싶을 때, 프로젝트의 디렉토리로 이동해서 다음과 같은 명령을 실행한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git init&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 &lt;code&gt;.git&lt;/code&gt;이라는 하위디렉토리를 만든다. &lt;code&gt;.git&lt;/code&gt; 디렉토리에는 저장소를 이루는 뼈대가 되는 파일(Skeleton)이 들어 있다(&lt;code&gt;.git&lt;/code&gt; 디렉토리가 막 만들어진 직후 어떤 파일이 포함되는지에 대한 자세한 내용은 9장에서 다룬다). 하지만, 위 명령만으로는 아직 Git은 프로젝트의 어떤 파일도 추적하지 않는다.&lt;/p&gt;

&lt;p&gt;그리고 파일들의 버전을 관리하려면 Git이 파일을 관리하도록 저장소에 추가하고 최초로 커밋한다. &lt;code&gt;git add&lt;/code&gt; 명령으로 여러 파일을 추가하고 커밋한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add *.c
$ git add README
$ git commit -m &amp;#39;initial project version&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1분도 되지 않는 짧은 시간에 위의 명령어들을 실행하여 Git 저장소를 만들었고 파일을 추적하게 하였다.&lt;/p&gt;

&lt;h3 id='___clone'&gt;이미 있는 저장소를 Clone하기&lt;/h3&gt;

&lt;p&gt;다른 프로젝트에 참여하거나(Contribute) Git 저장소를 복사하고 싶을 때 &lt;code&gt;git clone&lt;/code&gt; 명령을 사용한다. 이미 Subversion 같은 VCS에 익숙하면 &lt;code&gt;checkout&lt;/code&gt;이 아니라 &lt;code&gt;clone&lt;/code&gt; 이라는 점이 눈에 띌 것이다. Subversion과 git의 가장 큰 차이점은 서버에 있는 모든 데이터를 복사한다는 것이다. &lt;code&gt;git clone&lt;/code&gt;을 실행하면 프로젝트 히스토리를 전부 받아온다. 실제로 서버의 디스크가 망가져도 클라이언트들의 저장소 중에서 아무거나 하나 가져다가 복구할 수 있다(서버에 특화된 설정은 복구하지 못하지만 모든 데이터는 복구된다 - 4장에서 좀 더 자세히 다룬다).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git clone [url]&lt;/code&gt;로 저장소를 Clone한다. 예를 들어, Ruby용 Git 라이브러리인 Grit을 Clone하려면 다음과 같이 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git://github.com/schacon/grit.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 &amp;#8220;grit&amp;#8221;이라는 디렉토리를 만들고 그 안에 &lt;code&gt;.git&lt;/code&gt; 디렉토리를 만든다. 그리고 저장소의 데이터도 모두 가져오고 자동으로 가장 최신 버전을 Checkout한다. &lt;code&gt;grit&lt;/code&gt; 디렉토리로 이동하면 Checkout으로 생성된 파일을 볼 수 있고 당장 하고자 하는 일을 바로 시작할 수 있다. 다음과 같은 명령을 사용하여 저장소를 Clone하면 &amp;#8220;grit&amp;#8221;이 아니라 다른 이름으로 Clone할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git://github.com/schacon/grit.git mygrit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;디렉토리 이름이 &lt;code&gt;mygrit&lt;/code&gt;이라는 것만 빼면 이 명령의 결과와 앞선 명령의 결과는 같다.&lt;/p&gt;

&lt;p&gt;Git은 다양한 프로토콜을 지원한다. 이제까지는 &lt;code&gt;git://&lt;/code&gt; 프로토콜을 사용했지만 &lt;code&gt;http(s)://&lt;/code&gt;를 사용할 수도 있고 &lt;code&gt;user@server:/path.git&lt;/code&gt;처럼 SSH 프로토콜을 사용할 수도 있다. 자세한 내용은 4장에서 다룬다. 4장에서는 각 프로토콜의 장단점도 알아보고 Git 저장소에 접근하는 방법들을 알아본다.&lt;/p&gt;

&lt;h2 id='__'&gt;수정하고 저장소에 저장하기&lt;/h2&gt;

&lt;p&gt;Git 저장소를 하나 만들고 일할 수 있도록 Checkout했다. 이제는 파일을 수정하고 파일의 Snapshot을 커밋해 보자. 파일들을 수정하다가 저장하고 싶으면 Snapshot을 커밋한다.&lt;/p&gt;

&lt;p&gt;작업 디렉토리의 모든 파일은 크게 Tracked(관리대상임)와 Untracked(관리대상이 아님)로 나눈다. Tracked 파일은 이미 Snapshot에 포함돼 있던 파일이다. Tracked 파일들은 또 Unmodified(수정하지 않음)와 Modified(수정함) 그리고 Staged(커밋을 하면 현재 수정 사항을 저장소에 기록함) 상태 중 하나이다. 그리고 나머지 파일들은 모두 Untracked 파일이다. Untracked 파일은 작업 디렉토리에 있는 모든 파일이 Snapshot에 포함돼 있는 것은 아니고 Staging Area에 있는 것도 아니다. 처음 저장소를 Clone하고 나면 모든 파일은 Tracked이면서 Unmodified 상태이다. Git은 저장소를 Clone하면 자동으로 파일을 Checkout하고 아직 아무것도 편집하지 않은 상태다.&lt;/p&gt;

&lt;p&gt;마지막 커밋 이후 아직 아무것도 수정하지 않은 상태에서 어떤 파일이 수정되면 Git은 그 즉시 파일을 Modified 상태로 인식한다. 그리고 이 수정한 파일을 Stage하고 Staged 상태인 파일들을 커밋한다. 이 라이프사이클을 그림 2-1처럼 계속 반복한다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0201-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;Figure 2-1. 파일의 라이프사이클&lt;/p&gt;

&lt;h3 id='__'&gt;파일의 상태 확인하기&lt;/h3&gt;

&lt;p&gt;파일의 상태를 확인하려면 보통 &lt;code&gt;git status&lt;/code&gt; 명령을 사용한다. Clone한 후에 바로 이 명령을 실행하면 다음과 같은 메시지를 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git status
# On branch master
nothing to commit (working directory clean)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 내용은 파일을 하나도 수정하지 않았다는 것을 말해준다. 즉, Tracked와 Modified 상태의 파일이 없다. Untracked 파일은 아직 없어서 목록에 나타나지 않는다. 그리고 현재 작업 중인 브랜치를 알려준다. 기본 브랜치가 master이기 때문에 현재 master로 나오는 것이다. 브랜치 관련 내용은 차차 알아가자. 다음 장에서 브랜치와 레퍼런스에 대해 자세히 다룬다.&lt;/p&gt;

&lt;p&gt;프로젝트에 README 파일을 만들어보자. README 파일은 새로 만든 파일이기 때문에 &lt;code&gt;git status&lt;/code&gt;를 실행하면 Untracked에 들어 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vim README
$ git status
# On branch master
# Untracked files:
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to include in what will be committed)
#
#	README
nothing added to commit but untracked files present (use &amp;quot;git add&amp;quot; to track)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;README 파일은 &lt;code&gt;Untracked files&lt;/code&gt; 부분에 속해 있는데 이것은 README 파일이 Untracked 상태라는 것을 말한다. Git은 Untracked 파일을 이전 Snapshot(커밋)에는 없는 파일이라고 본다. Git은 파일이 Tracked 상태가 되기 전까지는 절대 그 파일들을 커밋하지 않는다. 그래서 일하는 동안 생성된 파일인 바이너리 파일 같은 것을 커밋하는 실수는 하지 않게 된다. README파일을 포함해 직접 Tracked 상태로 만들어 보자.&lt;/p&gt;

&lt;h3 id='__'&gt;새 파일을 추적하기&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;git add&lt;/code&gt; 명령을 사용하여 새로운 파일을 추적할 수 있다. 다음 명령을 실행하면 Git은 README 파일을 추적한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add README&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git status&lt;/code&gt; 명령을 다시 실행하면 README 파일이 Tracked 상태이면서 Staged 상태라는 것을 확인할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#	new file:   README
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#8216;Changes to be committed&amp;#8217; 에 들어 있는 파일은 Staged 상태라는 것을 의미한다. 커밋하면 &lt;code&gt;git add&lt;/code&gt;를 실행한 시점의 파일이 커밋되어 저장소 히스토리에 남는다. 우선 &lt;code&gt;git init&lt;/code&gt; 명령을 실행하고 나서 &lt;code&gt;git add&lt;/code&gt; 명령을 실행하면 Git은 앞으로 작업 디렉토리에 있는 파일들을 추적한다. 파일의 경로를 전부 적어주지 않아도 &lt;code&gt;git add&lt;/code&gt; 명령이 알아서 찾는다. 디렉토리를 추가하면 디렉토리 하위에 있는 파일들을 모두 추가한다.&lt;/p&gt;

&lt;h3 id='modified___stage'&gt;Modified 상태의 파일을 Stage하기&lt;/h3&gt;

&lt;p&gt;이미 Tracked 상태인 파일을 수정하는 법을 알아보자. &lt;code&gt;benchmarks.rb&lt;/code&gt;라는 파일을 수정하고 나서 &lt;code&gt;git status&lt;/code&gt; 명령을 다시 실행하면 결과는 다음과 같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#	new file:   README
#
# Changed but not updated:
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
#
#	modified:   benchmarks.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 &lt;code&gt;benchmarks.rb&lt;/code&gt; 파일은 &lt;code&gt;Changed but not updated&lt;/code&gt;에 있다. 이것은 수정한 파일이 Tracked 상태이지만 아직 Staged 상태는 아니라는 것이다. Staged 상태로 만들려면 &lt;code&gt;git add&lt;/code&gt; 명령을 실행해야 한다. &lt;code&gt;git add&lt;/code&gt;는 파일을 새로 추적할 때도 사용하고 수정한 파일을 Staged 상태로 만드는데에도 사용한다. &lt;code&gt;git add&lt;/code&gt;를 실행하여 benchmarks.rb 파일을 Staged 상태로 만들고 &lt;code&gt;git status&lt;/code&gt; 명령으로 결과를 확인해보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add benchmarks.rb
$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#	new file:   README
#	modified:   benchmarks.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;두 파일 모두 Staged 상태이므로 다음 커밋에 포함된다. 하지만, 아직 더 수정해야 한다는 것을 알게 되어 바로 커밋하지 못하는 상황이 되었다고 하자. 이 상황에서 benchmark.rb 파일을 열고 수정한다. 이제 아마 당신은 커밋할 준비가 다 됐다고 생각할 것이다. 하지만, Git에게는 그렇지 않다. &lt;code&gt;git status&lt;/code&gt; 명령으로 파일의 상태를 다시 확인해보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vim benchmarks.rb
$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#	new file:   README
#	modified:   benchmarks.rb
#
# Changed but not updated:
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
#
#	modified:   benchmarks.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;헉! benchmarks.rb가 Staged 상태이면서 동시에 Unstaged 상태로 나온다. 어떻게 이런 일이 가능할까? &lt;code&gt;git add&lt;/code&gt; 명령을 실행하면 Git은 파일을 바로 Staged 상태로 만든다. 지금 이 시점에서 커밋을 하면 &lt;code&gt;git commit&lt;/code&gt; 명령을 실행하는 시점의 버전이 커밋되는 것이 아니라 마지막으로 &lt;code&gt;git add&lt;/code&gt; 명령을 실행했을 때의 버전이 커밋된다. 그러니까 &lt;code&gt;git add&lt;/code&gt; 명령을 실행 후에 또 파일을 수정하면 &lt;code&gt;git add&lt;/code&gt; 명령을 다시 실행하여 최신 버전을 Staged 상태로 만들어야 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add benchmarks.rb
$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#	new file:   README
#	modified:   benchmarks.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='_'&gt;파일 무시하기&lt;/h3&gt;

&lt;p&gt;어떤 파일들은 Git이 자동으로 추가하지도 Untracked 파일이라고 보여줄 필요가 없다. 보통 로그 파일이나 빌드 시스템이 자동으로 생성한 파일들이 그렇다. 그런 파일을 무시하려면 &lt;code&gt;.gitignore&lt;/code&gt; 파일을 만들고 그 안에 무시할 파일 패턴을 적는다. 다음은 &lt;code&gt;.gitignore&lt;/code&gt; 파일의 예이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat .gitignore
*.[oa]
*~&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;첫번째 줄은 확장자가 &lt;code&gt;.o&lt;/code&gt; 나 &lt;code&gt;.a&lt;/code&gt;인 파일을 Git이 무시하라는 것이고 둘째 줄은 &lt;code&gt;~&lt;/code&gt;로 끝나는 모든 파일을 무시하라는 것이다. &lt;code&gt;.o&lt;/code&gt;와 &lt;code&gt;.a&lt;/code&gt;는 각각 빌드 시스템이 만들어내는 오브젝트와 아카이브 파일이고 &lt;code&gt;~&lt;/code&gt;로 끝나는 파일은 Emacs나 VI 같은 텍스트 편집기들이 임시로 만들어내는 파일이다. 또 log, tmp, pid 같은 디렉토리나, 자동으로 생성하는 문서 같은 것들도 추가할 수 있다. &lt;code&gt;.gitingnore&lt;/code&gt; 파일은 보통 처음에 만들어 두는 것이 편리하다. 그래서 Git 저장소에 커밋하고 싶지 않은 파일을 실수로 커밋하는 일을 방지한다.&lt;/p&gt;

&lt;p&gt;.gitignore 파일에 입력하는 패턴은 다음의 규칙을 따른다:&lt;/p&gt;

&lt;p&gt;* 아무것도 없는 줄이나, &lt;code&gt;#&lt;/code&gt;로 시작하는 줄은 무시한다. * 표준 Glob 패턴을 사용한다. * 디렉토리는 슬래시(&lt;code&gt;/&lt;/code&gt;)를 끝에 사용하는 것으로 표현한다. * 느낌표(&lt;code&gt;!&lt;/code&gt;)로 시작하는 패턴은 해당 패턴의 파일을 무시하지 않는다.&lt;/p&gt;

&lt;p&gt;Glob 패턴은 정규표현식을 단순하게 만든 것으로 생각하면 되고 보통 쉘에서 많이 사용한다. 애스터리스크(&lt;code&gt;*&lt;/code&gt;)는 문자가 하나도 없거나 하나 이상을 의미하고, &lt;code&gt;[abc]&lt;/code&gt;는 중괄호 안에 있는 문자 중 하나를 의미한다(그러니까 이 경우에는 a, b, c). 물음표(&lt;code&gt;?&lt;/code&gt;)는 문자 하나를 말하고, &lt;code&gt;[0-9]&lt;/code&gt;처럼 중괄호 안의 캐릭터 사이에 하이픈(&lt;code&gt;-&lt;/code&gt;)을 사용하면 그 캐릭터 사이에 있는 문자 하나를 말한다.&lt;/p&gt;

&lt;p&gt;다음은 .gitignore 파일의 예이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# a comment - 이 줄은 무시한다.
*.a       # 확장자가 .a인 파일 무시
!lib.a    # 윗 줄에서 확장자가 .a인 파일은 무시하게 했지만 lib.a는 무시하지 않는다.
/TODO     # 루트 디렉토리에 있는 TODO파일은 무시하고 subdir/ROOT처럼 하위디렉토리에 있는 파일은 무시하지 않는다.
build/    # build/ 디렉토리에 있는 모든 파일은 무시한다.
doc/*.txt # `doc/notes.txt`같은 파일은 무시하고 doc/server/arch.txt같은 파일은 무시하지 않는다.&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='staged_unstaged____'&gt;Staged와 Unstaged 상태의 변경 내용을 보기&lt;/h3&gt;

&lt;p&gt;단순히 파일이 변경됐다는 사실이 아니라 어떤 내용이 변경됐는지 살펴보기엔 &lt;code&gt;git status&lt;/code&gt; 명령은 부족해서 &lt;code&gt;git diff&lt;/code&gt; 명령을 사용해야 한다. 일반적으로 우리는 &amp;#8216;수정했지만, 아직 Staged 파일이 아닌것?&amp;#8217;과 &amp;#8216;어떤 파일이 Staged 상태인지?&amp;#8217;가 궁금하기 때문에 &lt;code&gt;git status&lt;/code&gt; 명령으로도 충분하다. &lt;code&gt;git diff&lt;/code&gt;는 Patch처럼 어떤 라인을 추가했고 삭제했는지 알아야 할 때에 사용한다. &lt;code&gt;git diff&lt;/code&gt;는 나중에 더 자세히 다룬다.&lt;/p&gt;

&lt;p&gt;README 파일을 수정하고 Staged 상태로 만들어 보자. benchmarks.rb 파일은 그냥 수정만 해둔다. 이 상태에서 &lt;code&gt;git status&lt;/code&gt; 명령을 실행하면 다음과 같은 메시지를 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#	new file:   README
#
# Changed but not updated:
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
#
#	modified:   benchmarks.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git diff&lt;/code&gt; 명령을 실행하면 수정했지만 아직 staged 상태가 아닌 파일을 비교해 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff
diff --git a/benchmarks.rb b/benchmarks.rb
index 3cb747f..da65585 100644
--- a/benchmarks.rb
+++ b/benchmarks.rb
@@ -36,6 +36,10 @@ def main
           @commit.parents[0].parents[0].parents[0]
         end

+        run_code(x, &amp;#39;commits 1&amp;#39;) do
+          git.commits.size
+        end
+
         run_code(x, &amp;#39;commits 2&amp;#39;) do
           log = git.commits(&amp;#39;master&amp;#39;, 15)
           log.size&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 작업 디렉토리에 있는 것과 Staging Area에 있는 것을 비교한다. 그래서 수정하고 아직 Staged 상태가 아닌 것들을 보여준다.&lt;/p&gt;

&lt;p&gt;만약 커밋하려고 Staging Area에 넣은 파일의 변경 부분을 보고 싶으면 &lt;code&gt;git diff --cached&lt;/code&gt; 옵션을 사용한다(Git 버전 1.6.1부터는 좀 더 기억하기 쉽게 &lt;code&gt;git diff --staged&lt;/code&gt;로도 사용할 수 있다). 이 명령은 Staging Area와 저장소에 커밋한 것을 비교한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff --cached
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README2
@@ -0,0 +1,5 @@
+grit
+ by Tom Preston-Werner, Chris Wanstrath
+ http://github.com/mojombo/grit
+
+Grit is a Ruby library for extracting information from a Git repository&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;꼭 잊지 말아야 할 것이 있는데 &lt;code&gt;git diff&lt;/code&gt; 명령은 마지막으로 커밋한 후에 수정한 것을 보여주지 않는다. &lt;code&gt;git diff&lt;/code&gt;는 Unstaged 상태인 것들만 보여준다. 이 부분은 조금 헷갈릴 수도 있는데, 수정한 파일을 모두 Staging Area에 넣었다면 &lt;code&gt;git diff&lt;/code&gt; 명령은 아무것도 출력하지 않는다.&lt;/p&gt;

&lt;p&gt;benchmarks.rb 파일을 Stage한 후 다시 수정해도 &lt;code&gt;git diff&lt;/code&gt; 명령을 사용할 수 있다. 이 경우 Staged 상태인 것과 Unstaged 상태인 것을 비교한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add benchmarks.rb
$ echo &amp;#39;# test line&amp;#39; &amp;gt;&amp;gt; benchmarks.rb
$ git status
# On branch master
#
# Changes to be committed:
#
#	modified:   benchmarks.rb
#
# Changed but not updated:
#
#	modified:   benchmarks.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git diff&lt;/code&gt; 명령으로 Unstaged 상태인 변경 부분을 확인해 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff
diff --git a/benchmarks.rb b/benchmarks.rb
index e445e28..86b2f7c 100644
--- a/benchmarks.rb
+++ b/benchmarks.rb
@@ -127,3 +127,4 @@ end
 main()

 ##pp Grit::GitRuby.cache_client.stats
+# test line&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Staged 상태인 파일은 &lt;code&gt;git diff --cached&lt;/code&gt; 옵션으로 확인한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff --cached
diff --git a/benchmarks.rb b/benchmarks.rb
index 3cb747f..e445e28 100644
--- a/benchmarks.rb
+++ b/benchmarks.rb
@@ -36,6 +36,10 @@ def main
          @commit.parents[0].parents[0].parents[0]
        end

+        run_code(x, &amp;#39;commits 1&amp;#39;) do
+          git.commits.size
+        end
+
        run_code(x, &amp;#39;commits 2&amp;#39;) do
          log = git.commits(&amp;#39;master&amp;#39;, 15)
          log.size&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='_'&gt;변경사항 커밋하기&lt;/h3&gt;

&lt;p&gt;수정한 것을 커밋하기 위해 Staging Area에 파일을 정리했다. Unstaged 상태의 파일은 커밋되지 않는다는 것을 기억해야 한다. Git은 생성하거나 수정하고 나서 &lt;code&gt;git add&lt;/code&gt; 명령으로 추가하지 않은 파일은 커밋하지 않는다. 그 파일은 여전히 Modified 상태로 남아 있다.&lt;/p&gt;

&lt;p&gt;커밋하기 전에 &lt;code&gt;git status&lt;/code&gt; 명령으로 모든 것이 Staged 상태인지 확인할 수 있다. 그리고 &lt;code&gt;git commit&lt;/code&gt;을 실행하여 커밋한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git 설정에 지정된 편집기가 다음과 같이 실행되고, 다음과 같은 텍스트가 자동으로 포함된다(아래 예제는 Vim 편집기의 화면이다). 이 편집기는 쉘의 $EDITOR 환경 변수에 등록된 편집기이고 보통은 Vim이나 Emacs을 사용한다. 또 1장에서 설명했듯이 &lt;code&gt;git config --global core.editor&lt;/code&gt; 명령으로 어떤 편집기를 사용할지 설정할 수 있다:&lt;/p&gt;

&lt;p&gt;편집기는 아래와 같은 내용을 표시한다(아래 예제는 Vim 편집기의 경우):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Please enter the commit message for your changes. Lines starting
# with &amp;#39;#&amp;#39; will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#       new file:   README
#       modified:   benchmarks.rb
~
~
~
&amp;quot;.git/COMMIT_EDITMSG&amp;quot; 10L, 283C&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자동으로 생성되는 커밋 메시지는 첫 줄은 비어 있고 둘째 줄부터 &lt;code&gt;git status&lt;/code&gt; 명령의 결과가 채워진다. 커밋한 내용을 쉽게 기억할 수 있도록 이 메시지를 포함할 수도 있고 메시지를 전부 지우고 새로 작성할 수 있다(수정한 내용을 좀 더 구체적으로 남겨 둘 수 있다. &lt;code&gt;git commit&lt;/code&gt;에 -v 옵션을 추가하면 편집기에 diff 메시지도 추가된다).&lt;/p&gt;

&lt;p&gt;메시지를 인라인으로 첨부할 수도 있다. &lt;code&gt;commit&lt;/code&gt; 명령을 실행할 때 다음과 같이 &lt;code&gt;-m&lt;/code&gt; 옵션을 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit -m &amp;quot;Story 182: Fix benchmarks for speed&amp;quot;
[master]: created 463dc4f: &amp;quot;Fix benchmarks for speed&amp;quot;
 2 files changed, 3 insertions(+), 0 deletions(-)
 create mode 100644 README&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;commit&lt;/code&gt; 명령은 몇 가지 정보를 출력하는데 위 예제는 master 브랜치에 커밋했고 체크섬은 &lt;code&gt;463dc4f&lt;/code&gt;이라고 알려준다. 그리고 수정한 파일이 몇 개이고 삭제됐거나 추가된 줄이 몇 줄인지 알려준다.&lt;/p&gt;

&lt;p&gt;Git은 Staging Area에 속한 Snapshot을 커밋한다는 것을 기억해야 한다. 수정은 했지만, 아직 Staging Area에 넣지 않은 것들은 다음에 커밋할 수 있다. 커밋할 때마다 프로젝트의 Snapshot을 기록하기 때문에 나중에 Snapshot끼리 비교하거나 예전 Snapshot으로 되돌릴 수 있다.&lt;/p&gt;

&lt;h3 id='staging_area_'&gt;Staging Area 생략하기&lt;/h3&gt;

&lt;p&gt;Staging Area는 커밋할 파일들을 정리한다는 점에서 매우 유용하지만 복잡하기만 하고 필요하지 않은 때도 있다. 아주 쉽게 Staging Area를 생략할 수 있다. &lt;code&gt;git commit&lt;/code&gt; 명령을 실행할 때 &lt;code&gt;-a&lt;/code&gt; 옵션을 추가하면 Git은 Tracked 상태의 파일이라면 자동으로 Staging Area에 넣는다. 그래서 &lt;code&gt;git add&lt;/code&gt; 명령을 실행하는 수고를 덜 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git status
# On branch master
#
# Changed but not updated:
#
#	modified:   benchmarks.rb
#
$ git commit -a -m &amp;#39;added new benchmarks&amp;#39;
[master 83e38c7] added new benchmarks
 1 files changed, 5 insertions(+), 0 deletions(-)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 예제에서는 커밋하기 전에 &lt;code&gt;git add&lt;/code&gt; 명령으로 benchmarks.rb 파일을 추가하지 않았다는 점을 눈여겨보자.&lt;/p&gt;

&lt;h3 id='_'&gt;파일을 삭제하기&lt;/h3&gt;

&lt;p&gt;Git에서 파일을 제거하려면 &lt;code&gt;git rm&lt;/code&gt; 명령으로 Tracked 상태의 파일을 삭제한 후에(정확하게는 Staging Area에서 삭제하는 것) 커밋해야 한다. 이 명령은 작업 디렉토리에 있는 파일도 삭제하기 때문에 실제로 지워진다.&lt;/p&gt;

&lt;p&gt;만약 Git없이 그냥 파일을 삭제하고 &lt;code&gt;git status&lt;/code&gt; 명령으로 상태를 확인하면 &lt;code&gt;Changed but not updated&lt;/code&gt;(즉, Unstaged) 에 속해 있는 것을 확인할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm grit.gemspec
$ git status
# On branch master
#
# Changed but not updated:
#   (use &amp;quot;git add/rm &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
#
#       deleted:    grit.gemspec
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 &lt;code&gt;git rm&lt;/code&gt; 명령을 실행하면 삭제한 파일은 staged 상태가 된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rm grit.gemspec
rm &amp;#39;grit.gemspec&amp;#39;
$ git status
# On branch master
#
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#       deleted:    grit.gemspec
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;커밋하면 파일은 삭제되고 Git은 이 파일을 더는 추적하지 않는다. 이미 파일을 수정했거나 Index에(역주, Staging Area을 Git Index라고도 부른다) 추가했다면 &lt;code&gt;-f&lt;/code&gt;옵션을 주어 강제로 삭제해야 한다. 이 점은 실수로 데이터를 삭제하지 못하도록 하는 안전장치다. 한 번도 커밋한적 없는 데이터는 Git으로 복구할 수 없다.&lt;/p&gt;

&lt;p&gt;또 Staging Area에서만 제거하고 작업 디렉토리에 있는 파일은 지우지 않고 남겨둘 수 있다. 다시 말해서 하드디스크에 있는 파일은 그대로 두고 Git만 더는 추적하지 않게 한다. 이것은 &lt;code&gt;.gitingnore&lt;/code&gt; 파일에 추가하는 것을 빼먹었거나 대용량 로그 파일이나 컴파일된 파일인 &lt;code&gt;.a&lt;/code&gt; 파일 같은 것을 실수로 추가했을 때 쓴다. &lt;code&gt;--cached&lt;/code&gt; 옵션을 사용하여 명령을 실행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rm --cached readme.txt&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여러 개의 파일이나 디렉토리를 한꺼번에 삭제할 수도 있다. 다음과 같이 &lt;code&gt;git rm&lt;/code&gt; 명령에 file-glob 패턴을 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rm log/\*.log&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt;앞에 &lt;code&gt;\&lt;/code&gt;을 사용한 것을 기억하자. 쉘의 확장자도 그렇지만 Git의 파일 확장자에서도 &lt;code&gt;\&lt;/code&gt;는 필요하다. 이 명령은 &lt;code&gt;log/&lt;/code&gt; 디렉토리에 있는 &lt;code&gt;.log&lt;/code&gt; 파일을 모두 삭제한다. 다음의 예제처럼 할 수도 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rm \*~&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 &lt;code&gt;~&lt;/code&gt;로 끝나는 파일을 모두 삭제한다.&lt;/p&gt;

&lt;h3 id='__'&gt;파일 이름 변경하기&lt;/h3&gt;

&lt;p&gt;Git은 다른 VCS 시스템과는 달리 파일 이름의 변경이나 파일의 이동을 명시적으로 관리하지 않는다. 다시 말해서 파일 이름이 변경됐다는 별도의 정보를 저장하지 않는다. Git은 똑똑해서 굳이 파일 이름이 변경되었다는 것을 추적하지 않아도 아는 방법이 있다. 이제 Git이 파일의 이름이 변경된 것을 어떻게 알아내는지 살펴본다.&lt;/p&gt;

&lt;p&gt;이렇게 말해도 Git에 &lt;code&gt;mv&lt;/code&gt; 명령이 있는 게 좀 이상하겠지만, 다음과 같이 파일이름을 변경할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git mv file_from file_to&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;잘 동작한다. 이 명령을 실행하고 Git의 상태를 확인해보면 Git은 이름이 바뀐 사실을 알고 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git mv README.txt README
$ git status
# On branch master
# Your branch is ahead of &amp;#39;origin/master&amp;#39; by 1 commit.
#
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#       renamed:    README.txt -&amp;gt; README
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;사실 &lt;code&gt;git mv&lt;/code&gt; 명령은 다음의 명령어들을 수행한 것과 완전히 똑같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mv README.txt README
$ git rm README.txt
$ git add README&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git mv&lt;/code&gt;는 일종의 단축 명령어이다. 이 명령으로 파일이름을 바꿔도 되고 &lt;code&gt;mv&lt;/code&gt; 명령으로 파일이름을 직접 바꿔도 된다. 단지 Git의 &lt;code&gt;mv&lt;/code&gt;명령은 편리하게 명령을 세 번 실행해주는 것뿐이다. 어떤 도구로 이름을 바꿔도 상관없다. 중요한 것은 이름을 변경하고 나서 꼭 rm/add 명령을 실행해야 한다는 것뿐이다.&lt;/p&gt;

&lt;h2 id='__'&gt;커밋 히스토리 조회하기&lt;/h2&gt;

&lt;p&gt;새로 저장소를 만들어서 몇 번 커밋을 했을 수도 있고, 커밋 히스토리가 있는 저장소를 Clone했을 수도 있다. 어쨌든 가끔 저장소의 히스토리를 보고 싶을 때가 있다. Git에는 히스토리를 조회하는 명령어인 &lt;code&gt;git log&lt;/code&gt;가 있다.&lt;/p&gt;

&lt;p&gt;이 예제에서는 simplegit 이라는 매우 단순한 프로젝트를 사용한다. simplegit은 Git을 설명하는데 자주 사용하는 예제다. 다음과 같이 이 프로젝트를 Clone한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone git://github.com/schacon/simplegit-progit.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 프로젝트 디렉토리에서 &lt;code&gt;git log&lt;/code&gt; 명령을 실행하면 다음과 같이 출력된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test code

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;특별한 인자 없이 &lt;code&gt;git log&lt;/code&gt; 명령을 실행하면 저장소의 커밋 히스토리를 시간순으로 보여준다. 즉, 가장 최근의 커밋이 가장 먼저 나온다. 그리고 이어서 각 커밋의 SHA-1 체크섬, 저자 이름, 저자 이메일, 커밋한 날짜, 커밋 메시지를 보여준다.&lt;/p&gt;

&lt;p&gt;원하는 히스토리를 검색할 수 있도록 &lt;code&gt;git log&lt;/code&gt; 명령은 매우 다양한 옵션을 지원한다. 여기에서는 자주 사용하는 옵션을 설명한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-p&lt;/code&gt;가 가장 유용한 옵션 중 하나다. &lt;code&gt;-p&lt;/code&gt;는 각 커밋의 diff 결과를 보여준다. 게다가 &lt;code&gt;-2&lt;/code&gt;는 최근 두 개의 결과만 보여주는 옵션이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log -p -2
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

diff --git a/Rakefile b/Rakefile
index a874b73..8f94139 100644
--- a/Rakefile
+++ b/Rakefile
@@ -5,7 +5,7 @@ require &amp;#39;rake/gempackagetask&amp;#39;
 spec = Gem::Specification.new do |s|
-    s.version   =   &amp;quot;0.1.0&amp;quot;
+    s.version   =   &amp;quot;0.1.1&amp;quot;
     s.author    =   &amp;quot;Scott Chacon&amp;quot;

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test code

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index a0a60ae..47c6340 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -18,8 +18,3 @@ class SimpleGit
     end

 end
-
-if $0 == __FILE__
-  git = SimpleGit.new
-  puts git.show
-end
\ No newline at end of file&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 옵션은 직접 diff를 실행한 것과 같은 결과를 출력하기 때문에 동료가 무엇을 커밋했는지 리뷰하고 빨리 조회하는데 유용하다.&lt;/p&gt;

&lt;p&gt;또 &lt;code&gt;git log&lt;/code&gt; 명령에는 히스토리의 통계를 보여주는 옵션도 있다. &lt;code&gt;--stat&lt;/code&gt; 옵션으로 각 커밋의 통계 정보를 조회할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --stat
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

 Rakefile |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test code

 lib/simplegit.rb |    5 -----
 1 files changed, 0 insertions(+), 5 deletions(-)

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit

 README           |    6 ++++++
 Rakefile         |   23 +++++++++++++++++++++++
 lib/simplegit.rb |   25 +++++++++++++++++++++++++
 3 files changed, 54 insertions(+), 0 deletions(-)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 결과에서 &lt;code&gt;--stat&lt;/code&gt; 옵션은 어떤 파일이 수정됐는지, 얼마나 많은 파일이 변경됐는지, 또 얼마나 많은 줄을 추가하거나 삭제했는지 보여준다. 요약정보는 가장 뒤쪽에 보여준다.&lt;/p&gt;

&lt;p&gt;다른 또 유용한 옵션은 &lt;code&gt;--pretty&lt;/code&gt; 옵션이다. 이 옵션을 통해 log의 내용을 보여줄 때 기본 형식 이외에 여러 가지 중에 하나를 선택할 수 있다. &lt;code&gt;oneline&lt;/code&gt; 옵션은 각 커밋을 한 줄로 보여준다. 이 옵션은 많은 커밋을 한 번에 조회할 때 유용하다. 추가로 &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;full&lt;/code&gt;, &lt;code&gt;fuller&lt;/code&gt; 옵션도 있는데 이것들은 정보를 조금씩 가감해서 보여준다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --pretty=oneline
ca82a6dff817ec66f44342007202690a93763949 changed the version number
085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test code
a11bef06a3f659402fe7563abf99ad00de2209e6 first commit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;가장 재밌는 옵션은 &lt;code&gt;format&lt;/code&gt; 옵션이다. 나만의 형식으로 결과를 출력하고 싶을 때 사용한다. 특히 결과를 다른 프로그램으로 파싱하고자 할 때 유용하다. 이 옵션을 사용하면 형식을 정확하게 일치시킬 수 있기 때문에 Git을 새 버전으로 바꿔도 결과의 형식이 바뀌지 않는다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --pretty=format:&amp;quot;%h - %an, %ar : %s&amp;quot;
ca82a6d - Scott Chacon, 11 months ago : changed the version number
085bb3b - Scott Chacon, 11 months ago : removed unnecessary test code
a11bef0 - Scott Chacon, 11 months ago : first commit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;표 2-1 형식에서 사용하는 유용한 옵션들.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Option	Description of Output
%H	Commit hash
%h	Abbreviated commit hash
%T	Tree hash
%t	Abbreviated tree hash
%P	Parent hashes
%p	Abbreviated parent hashes
%an	Author name
%ae	Author e-mail
%ad	Author date (format respects the –date= option)
%ar	Author date, relative
%cn	Committer name
%ce	Committer email
%cd	Committer date
%cr	Committer date, relative
%s	Subject&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;저자(Author)&lt;/em&gt; 와 &lt;em&gt;커미터(Committer)&lt;/em&gt; 를 구분하는 것이 조금 이상해 보일 수 있다. 저자는 원래 작업을 수행한 원작자이고 커밋터는 마지막으로 이 작업을 적용한 사람이다. 만약 당신이 어떤 프로젝트에 패치를 보냈고 그 프로젝트의 담당자가 패치를 적용했다면 두 명의 정보를 모두 알 필요가 있다. 그래서 이 경우 당신이 저자고 그 담당자가 커미터다. 5장에서 이 주제에 대해 자세히 다룰 것이다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;oneline&lt;/code&gt;과 &lt;code&gt;format&lt;/code&gt; 옵션은 &lt;code&gt;--graph&lt;/code&gt; 옵션과 함께 사용할 때 더 빛난다. 이 명령은 브랜치와 머지 히스토리를 보여주는 아스키 그래프를 출력한다. 이 명령을 Grit 프로젝트 저장소에서 사용해보면 다음과 같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --pretty=format:&amp;quot;%h %s&amp;quot; --graph
* 2d3acf9 ignore errors from SIGCHLD on trap
*  5e3ee11 Merge branch &amp;#39;master&amp;#39; of git://github.com/dustin/grit
|\
| * 420eac9 Added a method for getting the current branch.
* | 30e367c timeout code and tests
* | 5a09431 add timeout protection to grit
* | e1193f8 support for heads with slashes in them
|/
* d6016bc require time for xmlschema
*  11d191e Merge branch &amp;#39;defunkt&amp;#39; into local&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git log&lt;/code&gt; 명령의 기본적인 옵션과 출력물의 형식에 관련된 옵션을 살펴보았다. &lt;code&gt;git log&lt;/code&gt; 명령은 앞서 살펴본 것보다 더 많은 옵션을 지원한다. 표 2-2 는 지금 설명한 것과 함께 유용하게 사용할 수 있는 옵션들이다. 각 옵션으로 어떻게 &lt;code&gt;log&lt;/code&gt; 명령을 제어할 수 있는지 보여준다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;옵션  설명
-p	각 커밋에 적용된 패치를 보여준다.
--stat	각 커밋에서 수정된 파일의 통계정보를 보여준다.
--shortstat	 `--stat` 명령의 결과 중에서 수정한 파일, 추가된 줄, 삭제된 줄만 보여준다.
--name-only	 커밋 정보중에서 수정된 파일의 목록만 보여준다.
--name-status	 수정된 파일의 목록을 보여줄 뿐만 아니라 파일을 추가한 것인지, 수정한 것인지, 삭제한 것인지도 보여준다.
--abbrev-commit	 40자 짜리 SHA-1 체크섬을 전부 보여주는 것이 아니라 처음 몇 자만 보여준다.
--relative-date	 정확한 시간을 보여주는 것이 아니라 `2 주전`처럼 상대적인 형식으로 보여준다.
--graph	브랜치와 머지 히스토리 정보까지 아스키 그래프로 보여준다.
--pretty	지정한 형식으로 보여준다. 이 옵션에는 oneline, short, full, fuller, format이 있다. format은 원하는 형식으로 출력하고자 할 때 사용한다.&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='_'&gt;조회 제한조건&lt;/h3&gt;

&lt;p&gt;출력 형식과 관련된 옵션들을 살펴봤지만 &lt;code&gt;git log&lt;/code&gt; 명령은 조회 범위를 제한하는 옵션들도 있다. 히스토리 전부가 아니라 부분만 조회한다. 이미 최근 두 개만 조회하는 &lt;code&gt;-2&lt;/code&gt; 옵션은 살펴봤다. 실제 사용법은 &lt;code&gt;-&amp;lt;n&amp;gt;&lt;/code&gt;이고 n은 최근 n개의 커밋을 의미한다. 하지만, 현실에서는 종종 다른 조건으로 조회해야 한다. 그리고 Git은 모든 결과를 한 번에 한 페이지씩만 보여주기 때문에 더욱 필요하다.&lt;/p&gt;

&lt;p&gt;그래서 &lt;code&gt;--since&lt;/code&gt;나 &lt;code&gt;--until&lt;/code&gt;같은 시간을 기준으로 조회하는 옵션이 유용하다. 지난 2주 동안 만들어진 커밋들만 조회하는 명령은 다음과 같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --since=2.weeks&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 옵션은 다양한 형식을 지원한다. &lt;code&gt;2008-01-15&lt;/code&gt;같이 정확한 날짜도 사용할 수 있고 &lt;code&gt;2 years 1 day 3 minutes ago&lt;/code&gt;같이 상대적인 기간을 사용할 수도 있다.&lt;/p&gt;

&lt;p&gt;또 다른 기준도 있다. &lt;code&gt;--author&lt;/code&gt; 옵션으로 저자를 지정하여 검색할 수도 있고 &lt;code&gt;--grep&lt;/code&gt; 옵션으로 커밋 메시지에서 키워드를 검색할 수도 있다(author와 grep 옵션을 나눠서 지정하고 싶지 않으면 &lt;code&gt;--all-match&lt;/code&gt; 옵션으로 한 번에 검색할 수 있다).&lt;/p&gt;

&lt;p&gt;마지막으로 파일 경로로 검색하는 옵션이 있는데 이것도 정말 유용하다. 디렉토리나 파일 이름을 사용하여 그 파일이 변경된 log의 결과를 검색할 수 있다. 이 옵션은 &lt;code&gt;--&lt;/code&gt;와 함께 경로 이름들을 사용하는데 명령어 끝 부분에 쓴다(역주, &lt;code&gt;git log -- path1 path2&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;표 2-3은 조회 범위를 제한하는 옵션들이다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;옵션	설명
-(n)	최근 n 개의 커밋만 조회한다.
--since, --after	명시한 날짜 이후의 커밋만 검색한다.
--until, --before	명시한 날짜 이전의 커밋만 조회한다.
--author	입력한 저자의 커밋만 보여준다.
--committer	입력한 커미터의 커밋만 보여준다.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음의 예제는 2008년 10월에 Junio Hamano가 커밋한 히스토리를 조회하는 것이다. 그 중에서 테스트 파일을 수정한 커밋 중에서 머지 커밋이 아닌 것들만 조회한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --pretty=&amp;quot;%h - %s&amp;quot; --author=gitster --since=&amp;quot;2008-10-01&amp;quot; \
   --before=&amp;quot;2008-11-01&amp;quot; --no-merges -- t/
5610e3b - Fix testcase failure when extended attribute
acd3b9e - Enhance hold_lock_file_for_{update,append}()
f563754 - demonstrate breakage of detached checkout wi
d1a43f2 - reset --hard/read-tree --reset -u: remove un
51a94af - Fix &amp;quot;checkout --track -b newbranch&amp;quot; on detac
b0ad11e - pull: allow &amp;quot;git pull origin $something:$cur&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;총 2만여 개의 커밋 히스토리에서 이 명령의 검색 조건에 만족하는 것은 단 6개였다.&lt;/p&gt;

&lt;h3 id='gui____'&gt;GUI 도구를 사용하여 히스토리를 시각화하기&lt;/h3&gt;

&lt;p&gt;GUI 도구로 커밋 히스토리를 시각화하고 싶다면 gitk를 사용할 수 있다. gitk는 Tcl/Tk 프로그램이고 &lt;code&gt;git log&lt;/code&gt; 명령을 시각화해주는 도구다. gitk는 &lt;code&gt;git log&lt;/code&gt; 명령이 지원하는 필터링 옵션을 거의 모두 지원한다. 프로젝트 디렉토리에서 gitk를 실행하면 그림 2-2처럼 보일 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img alt='' src='/images/progit/18333fig0202-tn.png' /&gt;&lt;/p&gt;

&lt;p&gt;그림 2-2. gitk의 히스토리&lt;/p&gt;

&lt;p&gt;위쪽 반을 차지하는 윈도우에서는 히스토리를 그래프로 예쁘게 보여준다. 아래쪽 반을 차지하는 윈도우는 diff 결과를 보여주는데 위쪽 윈도우에서 선택한 커밋에 대한 diff 결과를 보여준다.&lt;/p&gt;

&lt;h2 id='undo'&gt;되돌리기(Undo)&lt;/h2&gt;

&lt;p&gt;일을 하다보면 모든 단계에서 어떤 것은 되돌리고 싶을 때가 있다. 이번에는 우리가 한 일을 되돌리는 방법을 살펴볼 것이다. 한 번 되돌리면 복구할 수 없어서 주의해야 한다. Git을 사용하면 우리가 한 실수를 복구하지 못할 것은 거의 없지만 되돌리기는 복구할 수 없다.&lt;/p&gt;

&lt;h3 id='_'&gt;커밋 수정하기&lt;/h3&gt;

&lt;p&gt;종종 완료한 커밋을 수정해야 할 때가 있다. 너무 일찍 커밋했거나 어떤 파일을 빼먹었을 때 그리고 커밋 메시지를 잘못 적었을 때 하게 된다. 다시 커밋하고 싶으면 &lt;code&gt;--amend&lt;/code&gt; 옵션을 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit --amend&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 Staging Area를 사용하여 커밋한다. 만약 마지막으로 커밋하고 나서 수정한 것이 없다면(커밋하자마자 바로 이 명령을 실행하는 경우) 조금 전에 한 커밋과 모든 것이 같을 것이다. 커밋 메시지만 수정할 때 이렇다.&lt;/p&gt;

&lt;p&gt;편집기가 실행되면 이전 커밋 메시지가 이미 포함돼 있다. 메시지를 수정하지 않고 그대로 커밋해도 기존의 커밋을 덮어쓴다.&lt;/p&gt;

&lt;p&gt;예를 들어 커밋을 했는데 Stage하는 것을 깜빡하고 빠트린 파일이 있으면 다음과 같이 고칠 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit -m &amp;#39;initial commit&amp;#39;
$ git add forgotten_file
$ git commit --amend&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여기서 실행한 명령어 3개는 모두 하나의 커밋으로 기록된다. 두 번째 커밋은 첫 번째 커밋을 덮어쓴다.&lt;/p&gt;

&lt;h3 id='__unstage_'&gt;파일 상태를 Unstage로 변경하기&lt;/h3&gt;

&lt;p&gt;다음은 Staging Area와 작업 디렉토리 사이를 넘나드는 방법을 설명한다. 파일의 상태를 변경하는 데 사용하는 명령으로 수정사항을 되돌리려면 상당히 중요한 부분이다. 예를 들어 파일을 두 개 수정했는데 따로따로 커밋하려고 했지만, 실수로 &lt;code&gt;git add *&lt;/code&gt; 라고 실행해 버렸다. 두 파일 모두 Staging Area에 들어 있다. 이제 둘 중 하나를 어떻게 꺼낼까? 우선 &lt;code&gt;git status&lt;/code&gt; 명령으로 확인해보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add .
$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#       modified:   README.txt
#       modified:   benchmarks.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Changes to be commited&lt;/code&gt; 밑에 &lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;...&lt;/code&gt;이라는 문장을 볼 수 있다. 이 명령으로 Unstage 상태로 변경할 수 있다. benchmarks.rb 파일을 Unstage 상태로 변경해보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git reset HEAD benchmarks.rb
benchmarks.rb: locally modified
$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#       modified:   README.txt
#
# Changed but not updated:
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
#   (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)
#
#       modified:   benchmarks.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령이 조금 어색하긴 하지만 일단 동작은 잘 수행되었다. benchmarks.rb 파일은 Unstage 상태가 됐다.&lt;/p&gt;

&lt;h3 id='modified__'&gt;Modified 파일 되돌리기&lt;/h3&gt;

&lt;p&gt;어떻게 해야 benchmarks.rb 파일을 수정하고 나서 다시 되돌릴 수 있을까? 그러니까 최근 커밋된 버전으로(아니면 처음 Clone했을 때처럼 작업 디렉토리에 처음 Checkout 한 그 내용으로) 되돌리는 방법이 무얼까? &lt;code&gt;git status&lt;/code&gt; 명령이 친절하게 알려준다. 바로 위에 있는 예제에서 Unstaged 부분을 보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Changed but not updated:
#   (use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to update what will be committed)
#   (use &amp;quot;git checkout -- &amp;lt;file&amp;gt;...&amp;quot; to discard changes in working directory)
#
#       modified:   benchmarks.rb
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 메시지는 수정한 파일을 되돌리는 방법을 꽤 정확하게 알려준다(적어도 Git 1.6.1이후 버전부터는 그렇다. 만약 예전 것을 아직 사용하고 있으면 업그레드하는 것이 좋다. 편의성이 많이 개선됐다). 알려주는 대로 한 번 해보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -- benchmarks.rb
$ git status
# On branch master
# Changes to be committed:
#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)
#
#       modified:   README.txt
#&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;정상적으로 복원된 것을 알 수 있다. 하지만 명령은 꽤 위험한 명령이라는 것을 알아야 한다. 수정 이전의 파일로 덮어썼기 때문에 수정했던 내용은 전부 사라졌다. 수정한 내용이 진짜 마음에 들지 않을 때에만 사용하자. 정말 이렇게 삭제해야 한다면 Stashing과 Branch를 사용하자. 다음 장에서 다룰 것들이다. 이 방법이 훨씬 낫다.&lt;/p&gt;

&lt;p&gt;Git으로 커밋한 모든 것은 언제나 복구할 수 있다. 삭제한 브랜치에 있었던 것도 &lt;code&gt;--amend&lt;/code&gt; 옵션으로 다시 커밋한 것도 복구할 수 있다(자세한 것은 9장에서 다룬다). 하지만, 커밋하지 않고 잃어버린 것은 절대로 되돌릴 수 없다.&lt;/p&gt;

&lt;h2 id='_'&gt;원격 저장소&lt;/h2&gt;

&lt;p&gt;원격 저장소를 관리할 줄 알아야 다른 사람과 함께 일할 수 있다. 원격 저장소는 인터넷이나 네트워크 어딘가에 있는 저장소를 말한다. 저장소는 여러 개가 있을 수 있는데 어떤 저장소는 읽고 쓰기 모두 할 수 있고 어떤 저장소는 읽기 권한만 있을 수도 있다. 간단히 말해서 다른 사람들과 함께 일한다는 것은 원격 저장소를 관리하고 데이터를 Push하고 Pull하는 것이다.&lt;/p&gt;

&lt;p&gt;그리고 저장소를 추가, 삭제하는 것뿐만 아니라 브랜치들을 관리하고 추적할지 말지 등을 결정하는 일이 저장소를 관리하는 일이다. 이번에는 원격 저장소를 관리하는 방법에 대해 설명한다.&lt;/p&gt;

&lt;h3 id='__'&gt;원격 저장소 확인하기&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;git remote&lt;/code&gt; 명령으로 현재 프로젝트에 등록된 원격 저장소들을 확인할 수 있다. 이 명령은 원격 저장소의 단축 이름들을 보여준다. 저장소를 Clone한 경우는 origin이라는 원격 저장소가 자동으로 등록되기 때문에 origin이라는 이름을 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git://github.com/schacon/ticgit.git
Initialized empty Git repository in /private/tmp/ticgit/.git/
remote: Counting objects: 595, done.
remote: Compressing objects: 100% (269/269), done.
remote: Total 595 (delta 255), reused 589 (delta 253)
Receiving objects: 100% (595/595), 73.31 KiB | 1 KiB/s, done.
Resolving deltas: 100% (255/255), done.
$ cd ticgit
$ git remote
origin&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-v&lt;/code&gt;옵션을 주어 단축이름과 URL을 함께 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote -v
origin	git://github.com/schacon/ticgit.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;원격 저장소가 여러 개 있다면 이 명령은 전부 보여준다. 내 Grit 저장소에서 실행하면 다음과 같이 출력한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd grit
$ git remote -v
bakkdoor  git://github.com/bakkdoor/grit.git
cho45     git://github.com/cho45/grit.git
defunkt   git://github.com/defunkt/grit.git
koke      git://github.com/koke/grit.git
origin    git@github.com:mojombo/grit.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 원격 저장소가 여러 개가 등록되어 있으면 다른 사람이 기여한 내용(Contributions)을 쉽게 가져올 수 있다. 그리고 origin만 SSH URL이기 때문에 나는 origin에만 Push할 수 있다(4장에서 좀 더 자세히 다룰 것이다).&lt;/p&gt;

&lt;h3 id='__'&gt;원격 저장소 추가하기&lt;/h3&gt;

&lt;p&gt;이전 절에서도 원격 저장소를 추가하는 것에 대해 설명했었지만 수박 겉핧기식으로 살펴봤을 뿐이었다. 여기에서는 원격 저장소를 추가하는 방법을 자세하게 설명한다. 쉽게 새 원격 저장소를 추가할 수 있는데 &lt;code&gt;git remote add [단축이름] [url]&lt;/code&gt; 명령을 실행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote
origin
$ git remote add pb git://github.com/paulboone/ticgit.git
$ git remote -v
origin	git://github.com/schacon/ticgit.git
pb	git://github.com/paulboone/ticgit.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 URL 대신에 스트링 pb를 사용할 수 있다. 예를 들어 로컬 저장소에는 없지만 Paul의 저장소에 있는 것을 가져오려면 다음과 같이 실행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch pb
remote: Counting objects: 58, done.
remote: Compressing objects: 100% (41/41), done.
remote: Total 44 (delta 24), reused 1 (delta 0)
Unpacking objects: 100% (44/44), done.
From git://github.com/paulboone/ticgit
 * [new branch]      master     -&amp;gt; pb/master
 * [new branch]      ticgit     -&amp;gt; pb/ticgit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;로컬에서 &lt;code&gt;pb/master&lt;/code&gt;가 Paul의 master 브랜치이다. 이것을 로컬 브랜치중 하나에 머지시킬 수도 있고 체크아웃하여 자세한 브랜치 내용을 확인할 수 있다.&lt;/p&gt;

&lt;h3 id='__pull__fetch_'&gt;원격 저장소를 Pull 하거나 Fetch 하기&lt;/h3&gt;

&lt;p&gt;앞서 설명했듯이 원격 저장소에서 데이터를 가져오려면 간단히 다음과 같이 실행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch [remote-name]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 로컬에는 없지만, 원격 저장소에는 있는 데이터를 모두 가져온다. 그리고 나면 원격 저장소의 모든 브랜치를 로컬에서 접근할 수 있어서 언제든지 머지를 하거나 내용을 살펴볼 수 있다(우리는 3장에서 브랜치를 사용하는 방법에 대해 좀 더 자세히 설명할 것이다).&lt;/p&gt;

&lt;p&gt;저장소를 Clone하면 명령은 자동으로 원격 저장소를 origin이라는 이름으로 추가한다. 그래서 나중에 &lt;code&gt;git fetch origin&lt;/code&gt;을 실행하면 Clone한 이후에(혹은 마지막으로 가져온 이후에) 수정된 것들을 모두 가져온다. &lt;code&gt;fetch&lt;/code&gt; 명령은 원격 저장소의 데이터를 모두 로컬로 가져오지만, 자동으로 머지하지 않는다. 그래서 당신이 로컬에서 하던 작업을 정리하고 나서 수동으로 머지해야 한다.&lt;/p&gt;

&lt;p&gt;그냥 쉽게 &lt;code&gt;git pull&lt;/code&gt; 명령으로 원격 저장소 브랜치에서 데이터를 가져올 뿐만 아니라 자동으로 로컬 브랜치와 머지시킬 수 있다. 먼저 &lt;code&gt;git clone&lt;/code&gt; 명령은 자동으로 로컬의 master 브랜치가 원격 저장소의 master 브랜치를 추적하도록 한다(물론 원격 저장소에 master 브랜치가 있다고 가정에서). 그리고 &lt;code&gt;git pull&lt;/code&gt; 명령은 Clone한 서버에서 데이터를 가져오고 그 데이터를 자동으로 현재 작업하는 코드와 머지시킨다.&lt;/p&gt;

&lt;h3 id='__push'&gt;원격 저장소에 Push하기&lt;/h3&gt;

&lt;p&gt;프로젝트를 공유하고 싶을 때 원격 저장소에 Push할 수 있다. 이 명령은 &lt;code&gt;git push [원격 저장소 이름] [브랜치 이름]&lt;/code&gt;으로 단순하다. master 브랜치를 &lt;code&gt;origin&lt;/code&gt; 서버에 Push하려면(다시 말하지만 Clone하면 보통 자동으로 origin 이름이 생성된다) 다음과 같이 서버에 Push한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 Clone한 원격 저장소에 쓰기 권한이 있고, Clone하고 난 이후 아무도 원격 저장소에 Push하지 않았을 때만 사용할 수 있다. 다시 말해서 Clone한 사람이 여러 명 있을 때, 다른 사람이 Push한 후에 Push하려고 하면 Push할 수 없다. 먼저 다른 사람이 작업한 것을 가져와서 머지한 후에 Push할 수 있다. 3장에서 서버에 Push하는 방법에 대해 자세히 설명할 것이다.&lt;/p&gt;

&lt;h3 id='__'&gt;원격 저장소 살펴보기&lt;/h3&gt;

&lt;p&gt;(역주, 이 절은 최신 버전의 Git이 출력하는 메시지와 조금 다르다.)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git remote show [원격 저장소 이름]&lt;/code&gt; 명령으로 원격 저장소의 구체적인 정보를 확인할 수 있다. &lt;code&gt;origin&lt;/code&gt; 같은 단축이름으로 이 명령을 실행하면 다음과 같은 정보를 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote show origin
* remote origin
  URL: git://github.com/schacon/ticgit.git
  Remote branch merged with &amp;#39;git pull&amp;#39; while on branch master
    master
  Tracked remote branches
    master
    ticgit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;원격 저장소의 URL과 추적하는 브랜치를 출력한다. 이 명령은 &lt;code&gt;git pull&lt;/code&gt; 명령을 실행할 때 master 브랜치와 머지할 브랜치가 무엇인지 보여 준다. &lt;code&gt;git pull&lt;/code&gt; 명령은 원격 저장소 브랜치의 데이터를 모두 가져오고 나서 자동으로 머지할 것이다. 그리고 가져온 모든 원격 저장소 정보도 출력한다.&lt;/p&gt;

&lt;p&gt;좀 더 Git을 열심히 사용하게 되면 &lt;code&gt;git remote show&lt;/code&gt; 명령은 더 많은 정보를 보여줄 것이다. 여러분도 언젠가는 다음과 같은 메시지(역주, 다수의 브랜치를 사용하는 메시지)를 볼 날이 올 것이다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote show origin
* remote origin
  URL: git@github.com:defunkt/github.git
  Remote branch merged with &amp;#39;git pull&amp;#39; while on branch issues
    issues
  Remote branch merged with &amp;#39;git pull&amp;#39; while on branch master
    master
  New remote branches (next fetch will store in remotes/origin)
    caching
  Stale tracking branches (use &amp;#39;git remote prune&amp;#39;)
    libwalker
    walker2
  Tracked remote branches
    acl
    apiv2
    dashboard2
    issues
    master
    postgres
  Local branch pushed with &amp;#39;git push&amp;#39;
    master:master&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;브랜치명을 생략하고 &lt;code&gt;git push&lt;/code&gt; 명령을 실행할 때 어떤 브랜치가 어떤 브랜치로 Push되는지 보여준다. 또 아직 로컬로 가져오지 않은 원격 저장소의 브랜치는 어떤 것들이 있는지, 서버에서는 삭제됐지만 아직 가지고 있는 브랜치는 어떤 것인지, &lt;code&gt;git pull&lt;/code&gt; 명령을 실행했을 때 자동으로 머지할 브랜치는 어떤 것이 있는지 보여준다.&lt;/p&gt;

&lt;h3 id='______'&gt;원격 저장소 이름을 바꾸거나 원격 저장소를 삭제하기&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;git remote rename&lt;/code&gt; 명령으로 원격 저장소의 이름을 변경할 수 있다. 예를 들어 &lt;code&gt;pb&lt;/code&gt;를 &lt;code&gt;paul&lt;/code&gt;로 변경하려면 &lt;code&gt;git remote rename&lt;/code&gt; 명령을 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote rename pb paul
$ git remote
origin
paul&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;원격 저장소의 브랜치 이름도 바뀐다. 여태까지 &lt;code&gt;pb/master&lt;/code&gt;로 원격 저장소 브랜치를 사용했으면 이제는 &lt;code&gt;paul/master&lt;/code&gt;라고 사용해야 한다.&lt;/p&gt;

&lt;p&gt;원격 저장소를 삭제해야 한다면 &lt;code&gt;git remote rm&lt;/code&gt; 명령을 사용한다. 서버 정보가 바뀌었을 때, 더는 특별한 미러가 필요하지 않을 때, 기여자가 더는 활동하지 않고 있을 때 필요하다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git remote rm paul
$ git remote
origin&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='tagtag'&gt;Tag(Tag)&lt;/h2&gt;

&lt;p&gt;다른 VCS처럼 Git도 Tag를 지원한다. 사람들은 보통 릴리즈할 때 사용한다(v1.0, 등등). 이번에는 Tag를 조회하고 생성하는 법과 Tag의 종류를 설명한다.&lt;/p&gt;

&lt;h3 id='tag_'&gt;Tag 조회하기&lt;/h3&gt;

&lt;p&gt;우선 &lt;code&gt;git tag&lt;/code&gt; 명령으로 이미 만들어져 있어 사용할 수 있는 Tag가 있는지 확인할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag
v0.1
v1.3&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 명령은 알파벳 순서로 Tag들을 보여준다. 사실 순서는 별로 중요한 게 아니다.&lt;/p&gt;

&lt;p&gt;검색 패턴을 사용하여 Tag를 검색할 수 있다. Git 소스 저장소는 240여 개의 Tag가 있다. 만약 1.4.2 버전의 Tag들만 검색하고 싶으면 다음과 같이 실행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag -l &amp;#39;v1.4.2.*&amp;#39;
v1.4.2.1
v1.4.2.2
v1.4.2.3
v1.4.2.4&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='tag_'&gt;Tag 붙이기&lt;/h3&gt;

&lt;p&gt;Git의 Tag는 Lightweight Tag와 Annotated Tag로 두 종류가 있다. Lightweight Tag는 브랜치와 비슷한데 브랜치처럼 가리키는 지점을 최신 커밋으로 이동시키지 않는다. 단순히 특정 커밋에 대한 포인터일 뿐이다. 한편, Annotated Tag는 Git 데이터베이스에 Tag를 만든 사람의 이름, 이메일과 Tag를 만든 날짜, 그리고 Tag 메시지도 저장한다. 또 GPG(GNU Privacy Guard)로 서명할 수도 있다. 이 모든 정보를 저장해둬야 할 때에만 Annotated Tag를 추천한다. 그냥 다른 정보를 저장하지 않는 단순한 Tag가 필요하다면 Lightweight Tag를 사용하는 것이 좋다.&lt;/p&gt;

&lt;h3 id='annotated_tag'&gt;Annotated Tag&lt;/h3&gt;

&lt;p&gt;Annotated Tag를 만드는 방법은 간단하다. &lt;code&gt;tag&lt;/code&gt; 명령을 실행할 때 &lt;code&gt;-a&lt;/code&gt; 옵션을 추가한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag -a v1.4 -m &amp;#39;my version 1.4&amp;#39;
$ git tag
v0.1
v1.3
v1.4&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-m&lt;/code&gt; 옵션으로 Tag를 저장할 때 메시지를 함께 저장할 수 있다. 명령을 실행할 때 메시지를 입력하지 않으면 Git은 편집기를 실행시킨다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git show&lt;/code&gt; 명령으로 Tag 정보와 커밋 정보를 모두 확인할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git show v1.4
tag v1.4
Tagger: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Mon Feb 9 14:45:11 2009 -0800

my version 1.4
commit 15027957951b64cf874c3557a0f3547bd83b3ff6
Merge: 4a447f7... a6b4c97...
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sun Feb 8 19:02:46 2009 -0800

    Merge branch &amp;#39;experiment&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;커밋 정보를 보여주기 전에 먼저 Tag를 만든 사람이 누구인지, 언제 Tag를 만들었는지, 그리고 Tag 메시지가 무엇인지 보여준다.&lt;/p&gt;

&lt;h3 id='tag_'&gt;Tag에 서명하기&lt;/h3&gt;

&lt;p&gt;GPG 개인키가 있으면 Tag에 서명할 수 있다. 이때에는 &lt;code&gt;-a&lt;/code&gt;옵션 대신 &lt;code&gt;-s&lt;/code&gt;를 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag -s v1.5 -m &amp;#39;my signed 1.5 tag&amp;#39;
You need a passphrase to unlock the secret key for
user: &amp;quot;Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;&amp;quot;
1024-bit DSA key, ID F721C45A, created 2009-02-09&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 Tag에 &lt;code&gt;git show&lt;/code&gt;를 실행하면 GPG 서명도 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git show v1.5
tag v1.5
Tagger: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Mon Feb 9 15:22:20 2009 -0800

my signed 1.5 tag
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.8 (Darwin)

iEYEABECAAYFAkmQurIACgkQON3DxfchxFr5cACeIMN+ZxLKggJQf0QYiQBwgySN
Ki0An2JeAVUCAiJ7Ox6ZEtK+NvZAj82/
=WryJ
-----END PGP SIGNATURE-----
commit 15027957951b64cf874c3557a0f3547bd83b3ff6
Merge: 4a447f7... a6b4c97...
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sun Feb 8 19:02:46 2009 -0800

    Merge branch &amp;#39;experiment&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;잠시 후 서명한 Tag를 검증하는 방법도 설명할 것이다.&lt;/p&gt;

&lt;h3 id='lightweight_tag'&gt;Lightweight Tag&lt;/h3&gt;

&lt;p&gt;Lightweight Tag는 기본적으로 파일에 커밋 체크섬을 저장하는 것뿐이다. 다른 정보는 저장하지 않는다. Lightweight Tag를 만들 때에는 &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, &lt;code&gt;-m&lt;/code&gt; 옵션을 사용하지 않는다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag v1.4-lw
$ git tag
v0.1
v1.3
v1.4
v1.4-lw
v1.5&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 Tag에 &lt;code&gt;git show&lt;/code&gt;를 실행하면 별도의 Tag 정보를 확인할 수 없다. 이 명령은 단순히 커밋 정보만을 보여준다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git show v1.4-lw
commit 15027957951b64cf874c3557a0f3547bd83b3ff6
Merge: 4a447f7... a6b4c97...
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sun Feb 8 19:02:46 2009 -0800

    Merge branch &amp;#39;experiment&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='tag_'&gt;Tag 검증하기&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;git tag -v [Tag 이름]&lt;/code&gt; 명령으로 서명한 Tag를 검증한다. 이 명령은 GPG를 사용하여 서명을 검증한다. 그래서 서명자의 GPG 공개키가 필요하다. 이 공개키가 Keyring에 있어야만 이 명령이 성공적으로 실행된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag -v v1.4.2.1
object 883653babd8ee7ea23e6a5c392bb739348b1eb61
type commit
tag v1.4.2.1
tagger Junio C Hamano &amp;lt;junkio@cox.net&amp;gt; 1158138501 -0700

GIT 1.4.2.1

Minor fixes since 1.4.2, including git-mv and git-http with alternates.
gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
gpg: Good signature from &amp;quot;Junio C Hamano &amp;lt;junkio@cox.net&amp;gt;&amp;quot;
gpg:                 aka &amp;quot;[jpeg image of size 1513]&amp;quot;
Primary key fingerprint: 3565 2A26 2040 E066 C9A7  4A7D C0C6 D9A4 F311 9B9A&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 서명자의 공개키가 없으면 다음과 같은 메시지를 출력한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
gpg: Can&amp;#39;t check signature: public key not found
error: could not verify the tag &amp;#39;v1.4.2.1&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='_tag'&gt;나중에 Tag하기&lt;/h3&gt;

&lt;p&gt;예전 커밋에 대해서도 Tag할 수 있다. 커밋 히스토리는 다음과 같고:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --pretty=oneline
15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &amp;#39;experiment&amp;#39;
a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support
0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &amp;#39;experiment&amp;#39;
0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function
4682c3261057305bdd616e23b64b0857d832627b added a todo file
166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo
8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;프로젝트에 &amp;#8220;updated rakefile&amp;#8221; 커밋을 v1.2로 Tag하지 못했다고 해도 지금 Tag를 붙일 수 있다. 특정 커밋에 Tag하기 위해서 명령의 끝에 커밋 체크섬을 명시한다(긴 체크섬을 전부 사용할 필요는 없다):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag -a v1.2 9fceb02&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 다음과 같이 만든 Tag를 확인한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git tag
v0.1
v1.2
v1.3
v1.4
v1.4-lw
v1.5

$ git show v1.2
tag v1.2
Tagger: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Mon Feb 9 15:32:16 2009 -0800

version 1.2
commit 9fceb02d0ae598e95dc970b74767f19372d61af8
Author: Magnus Chacon &amp;lt;mchacon@gee-mail.com&amp;gt;
Date:   Sun Apr 27 20:43:35 2008 -0700

    updated rakefile
...&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='tag_'&gt;Tag 공유하기&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;git push&lt;/code&gt; 명령은 자동으로 원격 서버에 Tag를 전송하지 않는다. Tag를 만들었으면 서버에 별도로 Push해야 한다. 브랜치를 공유하는 것과 같은 방법으로 할 수 있다. &lt;code&gt;git push origin [Tag 이름]&lt;/code&gt;을 실행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin v1.5
Counting objects: 50, done.
Compressing objects: 100% (38/38), done.
Writing objects: 100% (44/44), 4.56 KiB, done.
Total 44 (delta 18), reused 8 (delta 1)
To git@github.com:schacon/simplegit.git
* [new tag]         v1.5 -&amp;gt; v1.5&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;만약 한 번에 Tag를 여러 개 Push하고 싶으면 &lt;code&gt;--tags&lt;/code&gt; 옵션을 추가하여 &lt;code&gt;git push&lt;/code&gt;명령을 실행한다. 이 명령으로 원격 서버에 없는 Tag를 모두 전송할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin --tags
Counting objects: 50, done.
Compressing objects: 100% (38/38), done.
Writing objects: 100% (44/44), 4.56 KiB, done.
Total 44 (delta 18), reused 8 (delta 1)
To git@github.com:schacon/simplegit.git
 * [new tag]         v0.1 -&amp;gt; v0.1
 * [new tag]         v1.2 -&amp;gt; v1.2
 * [new tag]         v1.4 -&amp;gt; v1.4
 * [new tag]         v1.4-lw -&amp;gt; v1.4-lw
 * [new tag]         v1.5 -&amp;gt; v1.5&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;누군가 저장소에서 Clone하거나 Pull을 하면 모든 Tag 정보도 함께 전송된다.&lt;/p&gt;

&lt;h2 id='_'&gt;팁과 트릭&lt;/h2&gt;

&lt;p&gt;Git의 기초를 마치기 전에 Git을 좀 더 쉽고 편안하게 쓸 수 있게 만들어 줄 몇 가지 팁과 트릭도 설명한다. 이런 팁 없이 Git을 사용하는 사람들도 많다. 우리는 이 책에서 더는 이런 팁을 거론하지 않을 것이고 당신이 이런 팁을 알고 있다고 가정할 것이다. 그래서 알고 있는 것이 좋다.&lt;/p&gt;

&lt;h3 id='id43'&gt;자동완성&lt;/h3&gt;

&lt;p&gt;Bash 쉘을 쓰고 있다면 멋진 자동완성(Auto-completion) 기능을 사용할 수 있다. Git의 소스코드를 다운받아 &lt;code&gt;contrib/completion&lt;/code&gt; 디렉토리를 살펴보면 &lt;code&gt;git-completion.bash&lt;/code&gt;라는 파일이 있을 것이다. 그 파일을 홈 디렉토리에 카피하고 &lt;code&gt;.bashrc&lt;/code&gt; 파일에 다음과 같은 내용을 추가하자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source ~/.git-completion.bash&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;또 모든 사용자가 사용할 수 있게 설정할 수 있다. Mac 시스템이라면 이 스크립트를 &lt;code&gt;/opt/local/etc/bash_completion.d&lt;/code&gt; 디렉토리에 복사하고 리눅스라면 &lt;code&gt;/etc/bash_completion.d/&lt;/code&gt;에 복사한다. 이 디렉토리는 Bash가 자동완성을 지원하기 위해 사용하는 디렉토리다.&lt;/p&gt;

&lt;p&gt;윈도우에 msysGit을 설치해서 Git Bash를 사용하는 경우에는 자동완성이 미리 설정되어 있다.&lt;/p&gt;

&lt;p&gt;Git 명령을 입력할 때 &lt;code&gt;&amp;lt;Tab&amp;gt;&lt;/code&gt; 키를 누르면 Git이 제안하는 명령들이 출력된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git co&amp;lt;tab&amp;gt;&amp;lt;tab&amp;gt;
commit config&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이 경우 &lt;code&gt;git co&lt;/code&gt;를 입력하고 Tab 키를 두번 누르면 commit과 config를 제안한다. 이 때 &lt;code&gt;m&amp;lt;tab&amp;gt;&lt;/code&gt;을 입력하면 자동으로 &lt;code&gt;git commit&lt;/code&gt;명령을 완성한다.&lt;/p&gt;

&lt;p&gt;옵션에도 이 기능이 되고 더 유용하다. 예를 들어 &lt;code&gt;git log&lt;/code&gt;명령을 실행하는데 옵션이 전혀 기억나지 않는다면 다음과 같이 입력하고 Tap 키를 누르면 다음과 같은 옵션을 제안한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log --s&amp;lt;tab&amp;gt;
--shortstat  --since=  --src-prefix=  --stat   --summary&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이건 상당히 멋진 팁이다. 아마 문서를 찾아보는 등의 시간을 절약해 줄 것이다.&lt;/p&gt;

&lt;h3 id='git_alias'&gt;Git Alias&lt;/h3&gt;

&lt;p&gt;명령을 완벽하게 입력하지 않으면 Git은 알아듣지 못한다. Git의 명령을 전부 입력하는 것이 귀찮다면 &lt;code&gt;git config&lt;/code&gt;를 사용하여 각 명령의 Alias을 쉽게 만들 수 있다. 다음은 Alias을 만드는 예이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 &lt;code&gt;git commit&lt;/code&gt; 대신 &lt;code&gt;git ci&lt;/code&gt;만으로도 커밋할 수 있다. Git을 계속 사용한다면 다른 명령어도 자주 사용하게 될 것이다. 자주 사용하는 명령은 Alias을 만들어 편하게 사용한다.&lt;/p&gt;

&lt;p&gt;이미 있는 명령을 편리하고 새로운 명령으로 만들어 사용할 수 있다. 예를 들어 파일을 Unstage 상태로 변경하는 명령을 만들어서 불편함을 덜 수 있다. 다음과 같이 &lt;code&gt;unstage&lt;/code&gt; 라는 Alias을 만든다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global alias.unstage &amp;#39;reset HEAD --&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음 두 명령은 동일하게 동작한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git unstage fileA
$ git reset HEAD fileA&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;한결 간결해졌다. 추가로 &lt;code&gt;last&lt;/code&gt; 명령을 만들어 보자:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global alias.last &amp;#39;log -1 HEAD&amp;#39;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 최근 커밋을 좀 더 쉽게 확인할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git last
commit 66938dae3329c7aebe598c2246a8e6af90d04646
Author: Josh Goebel &amp;lt;dreamer3@example.com&amp;gt;
Date:   Tue Aug 26 19:48:51 2008 +0800

    test for current head

    Signed-off-by: Scott Chacon &amp;lt;schacon@example.com&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이것으로 쉽게 새로운 명령을 만들 수 있다. 그리고 Git의 명령어뿐만 아니라 외부 명령어도 실행할 수 있다. &lt;code&gt;!&lt;/code&gt;를 제일 앞에 추가하면 외부 명령을 실행한다. 다음은 &lt;code&gt;git visual&lt;/code&gt;이라고 입력하면 &lt;code&gt;gitk&lt;/code&gt;가 실행된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global alias.visual &amp;quot;!gitk&amp;quot;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='id44'&gt;요약&lt;/h2&gt;

&lt;p&gt;이제 우리는 로컬에서 사용할 수 있는 Git 명령에 대한 기본 지식은 갖추었다. 저장소를 만들고 Clone하는 방법, 수정하고 나서 Stage하고 커밋하는 방법, 저장소의 히스토리를 조회하는 방법 등을 살펴보았다. 이어지는 장에서는 Git의 가장 강력한 기능인 브랜치 모델을 살펴볼 것이다.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Pro Git - 1. 소개</title>
   <link href="http://ygpark.github.com/Pro Git/2012/08/29/pro-git-1-introduction"/>
   <updated>2012-08-29T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Pro Git/2012/08/29/pro-git-1-introduction</id>
   <content type="html">&lt;h1 id='id40'&gt;시작하기&lt;/h1&gt;

&lt;p&gt;이 장에서는 처음 접하는 사람들에게 Git을 설명한다. 먼저 버전 관리 도구에 대한 이해를, 그리고 Git을 설치하는 방법을, 마지막으로 Git 서버를 설정하고 사용하는 방법을 설명한다. 이 장을 다 읽고 나면 Git의 탄생 배경, Git을 사용하는 이유, Git을 설정하고 사용하는 방법을 터득할 것이다.&lt;/p&gt;

&lt;h2 id='_'&gt;버전 관리란?&lt;/h2&gt;

&lt;p&gt;버전 관리는 무엇이고, 우리는 왜 이것을 알아야 할까? 버전 관리는 파일들의 변화를 시간에 따라 기록하는 것이다. 이 책에 있는 모든 예제는 모두 버전 관리 시스템을 사용한다. 실제로 컴퓨터에서 사용하는 거의 모든 파일의 버전을 관리할 수 있다.&lt;/p&gt;

&lt;p&gt;그래픽 디자이너나 웹 디자이너도 이미지나 레이아웃의 모든 버전(변경 이력 혹은 수정 내용)을 관리하기 위해 버전 관리 시스템 (VCS - Version Control System)을 사용하는 것이 현명하다. VCS를 사용하면 각 파일을 이전 상태로 되돌릴 수 있고, 프로젝트를 통째로 이전 상태로 되돌릴 수 있고, 시간에 따라 수정 내용을 비교해 볼 수 있고, 누가 문제를 일으켰는지도 추적할 수 있고, 누가 언제 만들어낸 이슈인지도 알 수 있다. VCS를 사용하면 파일을 잃어버리거나 잘못 고쳤을 때도 쉽게 복구할 수 있다. 이런 모든 장점을 큰 노력 없이 이용할 수 있다.&lt;/p&gt;

&lt;h3 id='___'&gt;로컬 버전 관리 시스템&lt;/h3&gt;

&lt;p&gt;많은 사람은 버전을 관리하기 위해 Directory로 파일을 복사하는 방법을 쓴다(똑똑한 사람이라면 Directory 이름으로 시간을 쓸 거다). 이 방법은 간단하므로 자주 사용한다. 그렇지만, 정말 뭔가가 잘못되기 쉽다. 작업하는 Directory를 지워버리거나, 실수로 파일을 잘못 고칠 수도 있고, 잘못 복사할 수도 있다.&lt;/p&gt;

&lt;p&gt;이런 이유로 프로그래머들은 오래전에 로컬 VCS를 만들었다. 그 VCS는 관리 중인 파일의 변경 정보를 저장하려고 아주 간단한 데이터베이스를 사용했다.&lt;/p&gt;

&lt;p&gt;Insert 18333fig0101.png 그림 1-1. 로컬 버전 관리 다이어그램.&lt;/p&gt;

&lt;p&gt;많이 쓰는 VCS 도구 중에 rcs라고 부르는 것이 있는데 오늘날까지도 아직 많은 회사가 사용하고 있다. Mac OS X 운영체제에서도 개발 도구를 설치하면 RCS가 함께 설치된다. RCS는 기본적으로 Patch Set(파일에서 변경되는 부분)을 관리한다. 이 Patch Set은 특별한 형식의 파일로 저장한다. 그리고 일련의 Patch Set을 적용해서 모든 파일을 특정 시점으로 되돌릴 수 있다.&lt;/p&gt;

&lt;h3 id='____centralized_vcs'&gt;중앙집중식 버전 관리 시스템 (Centralized VCS)&lt;/h3&gt;

&lt;p&gt;프로젝트를 진행하다 보면 다른 개발자와 함께 작업해야 하는 경우가 많다. 이럴 때 생기는 문제를 해결하기 위해 CVCS(Centralized Version Control System)가 개발됐다. CVS, Subversion, Perforce 같은 시스템은 모든 파일을 관리하는 서버가 별도로 있고 많은 클라이언트가 중앙 서버에서 파일을 받아서 사용(Checkout)한다. 수년 동안 이러한 시스템들이 많은 사랑을 받았다.&lt;/p&gt;

&lt;p&gt;Insert 18333fig0102.png 그림 1-2. 중앙집중식 버전 관리 (CVCS) 다이어그램.&lt;/p&gt;

&lt;p&gt;CVCS 환경은 로컬 VCS비해 장점이 많다. 프로젝트에 참여한 사람이면 누가 무엇을 하고 있는지 알 수 있다. 관리자는 누가 무엇을 할 수 있는지 꼼꼼하게 관리할 수 있다. 모든 클라이언트의 로컬 데이터페이스를 관리하는 것보다 CVS 하나를 관리하기가 훨씬 쉽다.&lt;/p&gt;

&lt;p&gt;그러나 CVCS 환경은 몇 가지 치명적인 결점이 있다. 가장 대표적인 것이 중앙 서버에 발생한 문제다. 만약 서버가 한 시간 동안 다운되면 그동안 아무도 다른 사람과 협업할 수 없고 사람들이 하는 일을 백업할 방법도 없다. 그리고 중앙 데이터베이스가 있는 하드디스크에 문제가 생기면 프로젝트의 모든 히스토리를 잃는다. 물론 사람마다 하나씩 가진 Snapshot은 괜찮다. 로컬 VCS 시스템도 이와 비슷한 결점이 있고 이런 문제가 발생하면 모든 것을 잃는다.&lt;/p&gt;

&lt;h3 id='___distributed_vcs'&gt;분산형 버전 관리 시스템(Distributed VCS)&lt;/h3&gt;

&lt;p&gt;분산형 버전 관리 시스템(DVCS)을 설명할 차례다. Git, Mecurial, Bazaar, Dearcs 같은 DVCS에서는 클라이언트가 파일의 마지막 Snapshot을 Checkout 하지 않는다. 그냥 저장소를 전부 복제한다. 서버에 문제가 생기면 이 복제물로 다시 작업을 시작할 수 있다. 클라이언트 중에서 아무거나 골라도 서버를 복원할 수 있다. 모든 Checkout은 모든 데이터를 가진 진정한 백업이다.&lt;/p&gt;

&lt;p&gt;Insert 18333fig0103.png 그림 1-3. 분산형 버전 관리 시스템(DVCS) 다이어그램.&lt;/p&gt;

&lt;p&gt;게다가 대부분의 DVCS 환경에서는 원격 저장소가 존재할 수 있다. 원격 저장소가 많다고 해도 문제없다. 그래서 사람들은 동시에 다양한 그룹과 다양한 방법으로 협업할 수 있다. 계층 모델 같은 중앙집중식 시스템으로는 할 수 없는 몇 가지 워크플로우도 사용할 수 있다.&lt;/p&gt;

&lt;h2 id='__git_'&gt;짧게 보는 Git의 역사&lt;/h2&gt;

&lt;p&gt;인생을 살다 보면 여러 가지 일들이 벌어지듯이 Git의 삶 또한 창조적인 파괴와 모순 속에서 시작되었다. 리눅스 커널은 굉장히 규모가 큰 오픈소스 프로젝트다. 리눅스 커널의 일생에서 대부분 시절은 패치와 단순 파일(Archived file)로만 관리했다. 2002년에 드디어 리눅스 커널은 BitKeeper라고 불리는 상용 DVCS를 사용하기 시작했다.&lt;/p&gt;

&lt;p&gt;2005년에 커뮤니티가 만드는 리눅스 커널과 이익을 추구하는 회사가 개발한 BitKeeper의 관계는 틀어졌다. BitKeeper의 무료 사용이 제고된 것이다. 이 사건은 리눅스 개발 커뮤니티(특히 리눅스 창시자 리누스 토발즈)가 자체 도구를 만드는 계기가 됐다. Git은 BitKeeper를 사용하면서 배운 교훈을 기초로 다음과 같은 목표를 세웠다:&lt;/p&gt;

&lt;p&gt;* 빠른 속도 * 단순한 구조 * 비선형적인 개발(수천 개의 동시 다발적인 브랜치) * 완벽한 분산 * 리눅스 커널 같은 대형 프로젝트에도 유용할 것(속도나 데이터 크기 면에서)&lt;/p&gt;

&lt;p&gt;Git은 2005년 탄생하고 나서 아직도 초기 목표를 그대로 유지하고 있으면서도 사용하기 쉽게 진화하고 성숙했다. Git은 미친 듯이 빨라서 대형 프로젝트에 사용하기도 좋다. Git은 동시다발적인 브랜치에도 끄떡없는 슈퍼 울트라 브랜칭 시스템이다 (3장 참고).&lt;/p&gt;

&lt;h2 id='git_'&gt;Git 기초&lt;/h2&gt;

&lt;p&gt;Git의 핵심은 뭘까? 이 질문은 Git을 이해하는데 굉장히 중요하다. Git이 무엇이고 어떻게 동작하는지 이해한다면 쉽게 Git을 효과적으로 사용할 수 있다. Git을 배우려면 Subversion이나 Perforce 같은 다른 VCS를 사용하던 경험을 지워버려야 한다. Git은 미묘하게 달라서 다른 VCS에서 쓰던 개념으로는 헷갈릴 거다. 사용자 인터페이스는 매우 비슷하지만, 정보를 취급하는 방식이 다르다. 이런 차이점들을 이해하면 Git을 사용하는 것이 어렵지 않다.&lt;/p&gt;

&lt;h3 id='__snapshot'&gt;차이점이 아니라 Snapshot&lt;/h3&gt;

&lt;p&gt;Subversion과 Subversion 비슷한 놈들과 Git의 가장 큰 차이점은 데이터를 다루는 방법에 있다. 큰 틀에서 봤을 때 대부분의 VCS 시스템이 관리하는 정보는 파일들의 목록이다. CVS, Subversion, Perforce, Bazaar 등의 시스템은 파일의 집합으로 정보를 관리한다. 각 파일의 변화를 그림 1-4처럼 시간순으로 관리한다.&lt;/p&gt;

&lt;p&gt;Insert 18333fig0104.png 그림 1-4. 각 파일에 대한 변화(차이점)를 저장하는 시스템들.&lt;/p&gt;

&lt;p&gt;Git은 이런 식으로 데이터를 저장하지도 취급하지도 않는다. 대신 Git의 데이터는 파일 시스템의 Snapshot이라 할 수 있으며 크기가 아주 작다. Git은 Commit 하거나 프로젝트의 상태를 저장할 때마다 파일이 존재하는 그 순간을 중요하게 여긴다. 파일이 달라지지 않았으면 Git은 성능을 위해서 파일을 저장하지 않는다. 단지 이전 상태의 파일에 대한 링크만 저장한다. Git은 그림 1-5처럼 동작한다.&lt;/p&gt;

&lt;p&gt;Insert 18333fig0105.png 그림 1-5. Git은 시간순으로 프로젝트의 Snapshot을 저장한다.&lt;/p&gt;

&lt;p&gt;이것이 Git이 다른 VCS와 구분되는 점이다. Git은 이전 버전을 복사하는 다른 버전 관리 시스템들을 바보로 만들었다. Git은 강력한 도구를 지원하는 작은 파일시스템이다. Git은 단순한 VCS가 아니다. 이제 3장에서 설명할 Git 브랜치를 사용하면 얻게 되는 이득이 무엇인지 설명한다.&lt;/p&gt;

&lt;h3 id='____'&gt;거의 모든 명령을 로컬에서 실행&lt;/h3&gt;

&lt;p&gt;거의 모든 명령이 로컬 파일과 데이터만 사용하기 때문에 네트워크에 있는 다른 컴퓨터는 필요 없다. 대부분의 명령어가 네트워크의 속도에 영향을 받는 CVCS에 익숙하다면 Git이 매우 놀라울 것이다. Git의 이런 특징에서 나오는 미칠듯한 속도는 오직 Git느님만이 구사할 수 있는 초인적인 능력이다. 프로젝트의 모든 히스토리가 로컬 디스크에 있기 때문에 모든 명령을 순식간에 실행된다.&lt;/p&gt;

&lt;p&gt;예를 들어 프로젝트의 히스토리를 조회하려 할 때 Git은 서버가 필요 없다. 그냥 로컬 데이터베이스에서 히스토리를 읽어서 보여 준다. 그래서 눈 깜짝할 사이에 히스토리를 조회할 수 있다. 어떤 파일의 현재 버전과 한 달 전의 상태를 비교해보고 싶을 때도 Git은 그냥 한 달 전의 파일과 지금의 파일을 로컬에서 찾는다. 파일을 비교하기 위해 원격에 있는 서버에 접근하고 나서 예전 버전을 가져올 필요가 없다.&lt;/p&gt;

&lt;p&gt;즉 오프라인 상태에서도 비교할 수 있다. 비행기나 기차 등에서 작업하고 네트워크에 접속하고 있지 않아도 Commit 할 수 있다. 다른 VCS 시스템에서는 불가능한 일이다. Perforce는 서버에 연결할 수 없을 때 할 수 있는 일이 별로 없다. Subversion이나 CVS에서도 마찬가지다. 데이터베이스에 접근할 수 없어서 파일을 편집할 수는 있지만, Commit 할 수 없다. 매우 사소해 보이지만 실제로 이 상황에 부닥쳐보면 느껴지는 차이가 매우 크다.&lt;/p&gt;

&lt;h3 id='git_'&gt;Git의 무결성&lt;/h3&gt;

&lt;p&gt;Git은 모든 데이터를 저장하기 전에 체크섬(Checksum 또는 Hash)을 구하고 그 체크섬으로 데이터를 관리한다. 체크섬 없이 어떠한 파일이나 Directory도 변경할 수 없다. 체크섬은 Git에서 사용하는 가장 기본적인(Atomic) 데이터 단위이자 Git의 기본 철학이다. Git 없이는 체크섬을 다룰 수 없어서 파일의 상태도 알 수 없고 데이터를 잃어버릴 수도 없다.&lt;/p&gt;

&lt;p&gt;Git은 SHA-1 Hash를 사용하여 체크섬을 만든다. 만든 체크섬은 40자 길이의 16진수 문자열이다. 파일의 내용이나 Directory 구조를 이용하여 체크섬을 구한다. SHA-1은 아래처럼 생겼다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;24b9da6552252987aa493b52f8696cd6d3b00373&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git은 모든 것을 Hash로 식별하기 때문에 이런 값은 보일 것이다. 실제로 Git은 파일을 이름으로 저장하지 않고 해당 파일의 Hash로 저장한다.&lt;/p&gt;

&lt;h3 id='git___'&gt;Git은 데이터를 추가할 뿐&lt;/h3&gt;

&lt;p&gt;Git으로 무얼 하든 데이터가 추가된다. 되돌리거나 데이터를 삭제할 방법이 없다. 다른 VCS처럼 Git도 Commit 하지 않으면 변경사항을 잃어버릴 수 있다. 하지만, 일단 Snapshot을 Commit하고 나면 데이터를 잃어버리기 어렵다.&lt;/p&gt;

&lt;p&gt;Git을 사용하면 프로젝트가 심각하게 망가질 걱정 없이 매우 즐겁게 여러 가지 실험을 해 볼 수 있다. Git이 데이터를 어떻게 저장하고 손실을 복구할 수 있는지 좀 더 알아보려면 9장 &amp;#8216;Maintenance and Data Recovery&amp;#8217;를 살펴본다.&lt;/p&gt;

&lt;h3 id='__'&gt;세 가지 상태&lt;/h3&gt;

&lt;p&gt;이 부분은 중요하기에 집중해서 읽어야 한다. Git을 공부하기 위해 반드시 짚고 넘어가야 할 부분이다. Git은 파일을 Commited, Modified, Staged 이렇게 세 가지 상태로 관리한다. Commited란 데이터가 로컬 데이터베이스에 안전하게 저장됐다는 것을 의미한다. Modified는 수정한 파일을 아직 로컬 데이터베이스에 Commit 하지 않은 것을 말한다. Staged란 현재 수정한 파일을 곧 Commit 할 것이라고 표시한 상태를 의미한다.&lt;/p&gt;

&lt;p&gt;이 세 가지 상태는 Git 프로젝트의 세 가지 단계와 연결돼 있다. Git Directory, Working Directory, Staging Area 이 세 가지 단계를 이해하고 넘어가자.&lt;/p&gt;

&lt;p&gt;Insert 18333fig0106.png 그림 1-5. Working Directory, Staging Area, Git Directory&lt;/p&gt;

&lt;p&gt;Git Directory는 Git이 프로젝트의 메타데이터와 객체 데이터베이스를 저장하는 곳을 말한다. Git Directory가 Git의 핵심이다. 다른 컴퓨터에 있는 저장소를 Clone 할 때 Git Directory가 만들어진다.&lt;/p&gt;

&lt;p&gt;Working Directory는 프로젝트의 특정 버전을 Checkout 한 것이다. Git Directory는 지금 작업하는 디스크에 있고 그 Directory에 압축된 데이터베이스에서 파일을 가져와서 Working Directory를 만든다.&lt;/p&gt;

&lt;p&gt;Staging Area는 Git Directory에 있다. 단순한 파일이고 곧 Commit 할 파일에 대한 정보를 저장한다. 인덱스처럼 단순히 Staging Area는 파일을 가리키는 것에 불과하다.&lt;/p&gt;

&lt;p&gt;Git으로 하는 일은 기본적으로 다음과 같다:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Working Directory에서 파일을 수정한다.&lt;/li&gt;

&lt;li&gt;Staging Area에 파일을 Stage 해서 Commit 할 Snapshot을 만든다.&lt;/li&gt;

&lt;li&gt;Staging Area에 있는 파일들을 Commit 해서 Git Directory에 영구적인 Snapshot으로 저장한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;해당 작업이 독립적인 의미가 되면 Commit 한다. 파일을 수정하고 Staging Area에 추가했다면 단지 Staged 상태만 된 것이다. Checkout 한 후에 파일을 수정하고 Staged 상태로 만들지 않았다면 그냥 Modified 상태이다. 2장에서 이 상태들에 대해서 좀 더 배울 것이다. 2장에서는 이 상태들의 활용법과 Staged 단계를 사용하지 않는 방법도 배운다.&lt;/p&gt;

&lt;p&gt;Git directory에 있는 파일들은 Committed 상태이다. 파일을 수정하고 Staging Area에 추가했다면 Staged이다. 그리고 Checkout하고 나서 수정했지만, 아직 Staging Area에 추가하지 않았으면 Modified이다. 2장에서 이 상태에 대해 좀 더 자세히 배운다. 특히 Staging Area를 어떻게 이용하는지 혹은 아예 생략하는 방법도 설명한다.&lt;/p&gt;

&lt;h2 id='git_'&gt;Git 설치&lt;/h2&gt;

&lt;p&gt;Git을 사용해 보려면 우선 설치해야 한다. 다양한 방법으로 Git을 설치할 수 있지만 가장 일반적인 방법은 두 가지가 있다. 하나는 소스코드로 컴파일하여 설치하는 방법이고 다른 하나는 각 운영체제(혹은 Platform)의 패키지를 사용하여 설치하는 방법이다.&lt;/p&gt;

&lt;h3 id='_'&gt;소스코드로 설치하기&lt;/h3&gt;

&lt;p&gt;소스코드로 설치하면 Git의 가장 최신 버전을 설치할 수 있기 때문에 컴파일하여 설치할 시간이 있으면 소스코드로 Git을 설치하는 것이 좋다. Git은 계속 UI를 개선하고 있기 때문에 최신 버전을 사용하면 좋은 기능을 빨리 사용할 수 있다. 리눅스 패키지는 보통 최신 버전이 아니고 예전 버전이다. 그래서 Backport를 사용하거나 소스코드로 설치하는 것도 좋은 대안이다.&lt;/p&gt;

&lt;p&gt;Git을 설치하려면 다음과 같은 라이브러리들이 필요하다. Git은 curl, zlib, openssl, expat, libiconv를 필요로 한다. 예를 들어 Fedora처럼 yum을 가지는 시스템을 사용하고 있거나 apt-get이 있는 데비안류 시스템을 사용하면 다음의 명령어를 실행하여 의존 패키지를 설치할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yum install curl-devel expat-devel gettext-devel \
  openssl-devel zlib-devel

$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \
  libz-dev libssl-dev&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;필요한 라이브러리를 모두 설치하고 다음 단계를 진행한다. Git 웹 사이트에서 최신 Snapshot을 가져온다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://git-scm.com/download&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 컴파일하고 설치한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tar -zxf git-1.7.2.2.tar.gz
$ cd git-1.7.2.2
$ make prefix=/usr/local all
$ sudo make prefix=/usr/local install&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;설치한 다음부터는 Git을 사용하여 Git 소스코드를 갱신할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git://git.kernel.org/pub/scm/git/git.git&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='_'&gt;리눅스에 설치&lt;/h3&gt;

&lt;p&gt;리눅스에서 패키지로 Git을 설치할 때에는 보통 각 배포판에서 사용하는 패키지 관리도구를 사용하여 설치한다. Fedora에서는 다음과 같이 한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yum install git-core&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ubuntu같은 데비안류 배포판에서는 apt-get을 사용한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install git-core&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='mac_'&gt;Mac에 설치하기&lt;/h3&gt;

&lt;p&gt;Mac에 Git을 쉽게 설치하는 방법은 두 가지가 있다. GUI 인스톨러를 사용하기가 가장 쉽다. Google Code 페이지에서 내려받는다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://code.google.com/p/git-osx-installer&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Insert 18333fig0107.png 그림 1-7. OS X Git 인스톨러.&lt;/p&gt;

&lt;p&gt;MacPorts(&lt;code&gt;http://www.macports.org&lt;/code&gt;)를 사용하는 방법도 있다. MacPorts가 설치돼 있으면 다음과 같이 Git을 설치한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo port install git-core +svn +doc +bash_completion +gitweb&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 설치는 했다. 만약 Subversion 저장소를 Git과 함께 사용해야 하면 svn도 필요하다.&lt;/p&gt;

&lt;h3 id='_'&gt;윈도우에 설치&lt;/h3&gt;

&lt;p&gt;Git을 윈도우에 설치하기도 쉽다. 그저 구글 코드 페이지에서 msysGit 인스톨러를 내려받고 실행하면 된다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://code.google.com/p/msysgit&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;설치가 완료되면 CLI 프로그램과 GUI 프로그램을 둘 다 사용할 수 있다. CLI 프로그램에는 SSH 클라이언트가 포함돼 있기 때문에 유용하다.&lt;/p&gt;

&lt;h2 id='git__'&gt;Git 최초 설정&lt;/h2&gt;

&lt;p&gt;Git을 설치하고 나면 Git의 사용 환경을 적절히 설정해 주어야 한다. 한 번만 설정하면 된다. 설정한 내용은 Git을 업그레이드해도 유지된다. 또한, 명령어로 언제든지 다시 바꿀 수 있다.&lt;/p&gt;

&lt;p&gt;Git은 &amp;#8216;git config&amp;#8217;라는 도구로 설정 내용을 확인하고 변경할 수 있다. Git은 이 설정에 따라 동작한다. 이 설정 파일은 세 가지나 된다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/etc/gitconfig&lt;/code&gt; 파일: 시스템의 모든 사용자와 모든 저장소에 적용되는 설정이다. &lt;code&gt;git config --system&lt;/code&gt; 옵션으로 이 파일을 읽고 쓸 수 있다.&lt;/li&gt;

&lt;li&gt;&lt;code&gt;~/.gitconfig&lt;/code&gt; 파일: 특정 사용자에게만 적용되는 설정이다. &lt;code&gt;git config --global&lt;/code&gt; 옵션으로 이 파일을 읽고 쓸 수 있다.&lt;/li&gt;

&lt;li&gt;&lt;code&gt;.git/config&lt;/code&gt;: 이 파일은 Git Directory에 있고 특정 저장소(혹은 현재 작업 중인 프로젝트)에만 적용된다. 각 설정은 역순으로 우선시 된다. 그래서 &lt;code&gt;.git/config&lt;/code&gt;가 &lt;code&gt;/etc/gitconfig&lt;/code&gt;보다 우선한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;윈도우에서 Git은 &lt;code&gt;$HOME&lt;/code&gt; Directory(&lt;code&gt;C:\Documents and Settings\$USER&lt;/code&gt;)에 있는 &lt;code&gt;.gitconfig&lt;/code&gt; 파일을 찾는다. 그리고 msysGit도 /etc/gitconfig를 가지고 있다. 경로는 MSys 루트에 따른 상대 경로다. 인스톨러로 msysGit을 설치할 때 설치 경로를 선택할 수 있다.&lt;/p&gt;

&lt;h3 id='_'&gt;사용자 정보&lt;/h3&gt;

&lt;p&gt;Git을 설치하고 나서 가장 먼저 해야 하는 것은 사용자 이름과 이메일 주소를 설정하는 것이다. Git은 Commit 할 때마다 이 정보를 사용한다. 한 번 Commit 한 후에는 정보를 변경할 수 없다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global user.name &amp;quot;John Doe&amp;quot;
$ git config --global user.email johndoe@example.com&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다시 말하자면 &lt;code&gt;--global&lt;/code&gt; 옵션으로 설정한 것은 딱 한 번만 하면 된다. 해당 시스템에서 해당 사용자가 사용할 때에는 이 정보를 사용한다. 만약 프로젝트마다 다른 이름과 이메일 주소를 사용하고 싶으면 &lt;code&gt;--global&lt;/code&gt; 옵션을 빼고 명령을 실행한다.&lt;/p&gt;

&lt;h3 id='id41'&gt;편집기&lt;/h3&gt;

&lt;p&gt;사용자 정보를 설정하고 나면 Git에서 사용할 텍스트 편집기를 고른다. 기본적으로 Git은 시스템의 기본 편집기를 사용하고 보통 이것은 Vi나 Vim이다. 하지만, Emacs 같은 다른 텍스트 편집기를 사용하고 싶다면 다음과 같이 실행한다.:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global core.editor emacs&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='diff_'&gt;Diff 도구&lt;/h3&gt;

&lt;p&gt;Merge 충돌을 해결하기 위해 사용하는 Diff 도구를 설정할 수 있다. vimdiff를 사용하고 싶으면 다음과 같이 실행한다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global merge.tool vimdiff&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이렇게 kdiff3, tkdiff, meld, xxdif, emerge, vimdiff, gvimdiff, ecmerge, opendiff를 사용할 수 있다. 물론 다른 도구도 사용할 수 있다. 자세한 내용은 7장에서 다룬다.&lt;/p&gt;

&lt;h3 id='_'&gt;설정 확인&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;git config --list&lt;/code&gt; 명령을 실행하면 모든 설정 내용을 확인할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --list
user.name=Scott Chacon
user.email=schacon@gmail.com
color.status=auto
color.branch=auto
color.interactive=auto
color.diff=auto
...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git은 같은 키를 여러 파일(&lt;code&gt;/etc/gitconfig&lt;/code&gt;와 &lt;code&gt;~/.gitconfig&lt;/code&gt;같은)에서 읽기 때문에 같은 키가 하나 이상 나올 수도 있다. 이 경우에 Git은 나중 값을 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git config {key}&lt;/code&gt; 명령으로 Git이 특정 Key에 대해 어떤 값을 사용하는지 확인할 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config user.name
Scott Chacon&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='_'&gt;도움말 보기&lt;/h2&gt;

&lt;p&gt;명령어에 대한 도움말이 필요할 때 도움말을 보는 방법은 세 가지이다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git help &amp;lt;verb&amp;gt;
$ git &amp;lt;verb&amp;gt; --help
$ man git-&amp;lt;verb&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;예를 들어 다음과 같이 실행하면 config 명령에 대한 도움말을 볼 수 있다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git help config&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;도움말은 언제 어디서나 볼 수 있다. 오프라인 상태에서도 가능하다. 도움말과 이 책으로 부족하면 다른 사람의 도움을 받는 것이 필요하다. Freenode IRC 서버(irc.freenode.net)에 있는 &lt;code&gt;#git&lt;/code&gt;이나 &lt;code&gt;#github&lt;/code&gt; 채널로 찾아가라. 이 채널은 보통 수백 명의 사람이 접속해 있다. 이 사람들은 모두 Git에 대해 잘 알고 있다. 기꺼이 도와줄 것이다.&lt;/p&gt;

&lt;h2 id='id42'&gt;요약&lt;/h2&gt;

&lt;p&gt;우리는 Git이 무엇이고 지금까지 사용해 왔던 다른 CVCS와 어떻게 다른지 배웠다. 시스템에 Git을 설치하고 사용자 정보도 설정했다. 다음 장에서는 Git의 사용법을 배운다.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Pro Git - 0. README</title>
   <link href="http://ygpark.github.com/Pro Git/2012/08/29/pro-git-0-readme"/>
   <updated>2012-08-29T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Pro Git/2012/08/29/pro-git-0-readme</id>
   <content type="html">&lt;h1 id='pro_git__'&gt;Pro Git 책의 내용&lt;/h1&gt;

&lt;p&gt;이 것은 Pro Git의 source code이고 라이센스는 Creative Commons Attribution-Non Commercial-Share Alike 3.0를 따름니다. 나는 여러분이 즐겁게 git을 배웠으면 좋겠습니다. 또 나와 Apress를 위해 Amazon에서 책을 구입해주시면 감사하겠습니다:&lt;/p&gt;

&lt;p&gt;http://tinyurl.com/amazonprogit&lt;/p&gt;

&lt;h1 id='ebook__'&gt;Ebook을 만드는 법&lt;/h1&gt;

&lt;p&gt;페도라에서는 다음과 같이 하면 됩니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ yum install ruby calibre rubygems ruby-devel rubygem-ruby-debug 
$ gem install rdiscount
$ makeebooks en  # will produce a mobi&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id='id38'&gt;오류&lt;/h1&gt;

&lt;p&gt;틀린 부분이나 개선 해야 할 부분을 발견하면 주저 없이 나에게 메일을 보내주세요. (schacon at gmail dot com)&lt;/p&gt;

&lt;h1 id='id39'&gt;번역&lt;/h1&gt;

&lt;p&gt;이 책을 번역해서 알려주면 제가 progit.org에 번역본을 올릴 것입니다. 적당히(예를 들어: 이탈리어어 디렉토리로 &amp;#8216;it&amp;#8217;) 하위 디렉토리를 만들어 번역을 완성한 후 나에게 pull 요청을 보내주세요.&lt;/p&gt;

&lt;h1 id='_'&gt;역자 정보&lt;/h1&gt;

&lt;p&gt;번역, 박창우(Changwoo Park), pismute at gmail dot com, https://github.com/pismute/ 번역, 이성환(Sean Lee), lethee at gmail dot comt, https://github.com/lethee&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>gitweb 설치</title>
   <link href="http://ygpark.github.com/Git/2012/08/28/gitweb-for-ubuntu"/>
   <updated>2012-08-28T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Git/2012/08/28/gitweb-for-ubuntu</id>
   <content type="html">&lt;h3 id='gitweb_'&gt;gitweb 설치&lt;/h3&gt;

&lt;p&gt;이렇게 입력하면 웹으로 gitweb에 접근할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get install apache2 git-core gitweb
$
$ cd /var/www/
$ mkdir gitweb
$ cd gitweb
$ ln -s /usr/share/gitweb/* .&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='_'&gt;프로젝트 설정&lt;/h3&gt;

&lt;p&gt;다음으로 gitweb에 프로젝트를 추가하는 방법이다.&lt;/p&gt;

&lt;p&gt;기본적인 사용법은 아래와 같고&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /var/cache/git
$ ln -s /path/to/repo1/.git repo1.git&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음과 같이 디렉토리를 만들어서 사용자/프로젝트별로 구분할 수도 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /var/cache/git
$ mkdir username
$ cd username
$
$ ln -s /path/to/repo2/.git repo2.git
$ ln -s /path/to/repo3/.git repo3.git&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='id37'&gt;참조&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://wiki.kldp.org/wiki.php/gitweb'&gt;http://wiki.kldp.org/wiki.php/gitweb&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;a href='http://kldp.org/node/100726'&gt;http://kldp.org/node/100726&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 <entry>
   <title>Linux Kernel - 새 defconfig 만들기</title>
   <link href="http://ygpark.github.com/Linux Kernel/2012/08/28/creating-new-linux-kernel-defconfig"/>
   <updated>2012-08-28T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Linux Kernel/2012/08/28/creating-new-linux-kernel-defconfig</id>
   <content type="html">&lt;p&gt;초보 리눅스커널 개발자에게 유용한 팁입니다.&lt;/p&gt;

&lt;p&gt;우리는 커널 빌드할 때 &lt;strong&gt;make xxx_defconfig&lt;/strong&gt; 같은 명령을 입력합니다. 이 명령의 의미는 &amp;#8216;미리 만들어 놓은 &lt;strong&gt;.config&lt;/strong&gt; 파일을 사용하라&amp;#8217; 입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make xxx_defconfig
$ make&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;내 커널소스도 이렇게 만들고 싶은데 어떻게 해야할까요? 먼저 커널소스의 루트디렉토리에서 지금 쓰고있는 &lt;strong&gt;.config&lt;/strong&gt;를 찾습니다. 그리고 그것을 &lt;strong&gt;arch/arm/configs/&lt;/strong&gt; 디렉토리에 복사합니다. 이게 다에요. 다음엔 그냥 &lt;strong&gt;make xxx_defconfig&lt;/strong&gt; 명령을 사용하기만 하면 됩니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cp .config arch/arm/configs/xxx_defconfig
$ make xxx_defconfig&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이제 마음놓고 옵션들을 바꿀 수 있고 되돌릴 수도 있습니다. make distclean 같은 명령도 내릴 수 있죠. :D&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>gdb 매뉴얼 - core dump 사용하기</title>
   <link href="http://ygpark.github.com/Linux/2012/08/27/gdb-manual"/>
   <updated>2012-08-27T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Linux/2012/08/27/gdb-manual</id>
   <content type="html">&lt;p&gt;core dump란 충돌이 발생했던 순간의 memory를 저장한 파일을 말한다. gdb는 core dump 파일을 불러와서 디버깅을 하는 기능을 제공한다. 하지만 그전에 core dump가 저장될 수 있도록 하는 설정이 필요하다.&lt;/p&gt;

&lt;h2 id='id35'&gt;준비작업&lt;/h2&gt;

&lt;p&gt;core dump가 저장될 수 있도록 하는 설정은 &lt;code&gt;ulimit&lt;/code&gt; 명령을 사용한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 20
file size               (blocks, -f) unlimited
pending signals                 (-i) 16382
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) unlimited
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ulimit -a&lt;/code&gt;의 출력을 보면, 기본적으로 core file size가 0으로 잡혀있는 것을 확인할 수 있다. 이 상태에서는 core dump 파일이 생성되지 않는다. 따라서 core file size를 설정해 주어야 한다. 여기서는 unlimited로 설정한다.&lt;/p&gt;

&lt;p&gt;설정은 &lt;code&gt;ulimit -c unlimited&lt;/code&gt; 명령으로 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ulimit -c unlimited

$ ulimit -a
core file size          (blocks, -c) unlimited
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 20
file size               (blocks, -f) unlimited
pending signals                 (-i) 16382
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) unlimited
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같이 설정이 되었다면, 프로그램이 죽을 때 현재 디렉토리($PWD)에 core dump 파일이 생긴다.&lt;/p&gt;

&lt;h2 id='id36'&gt;사용법&lt;/h2&gt;

&lt;p&gt;core dump를 이용한 디버깅 방법은 다음과 같다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gdb [프로그램명] [덤프파일명]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gdb는 실행직후 core dump 파일을 로드하여 종료 직전의 메모리 상태를 만든다. 이 때 bt(backtrace)같은 gdb의 명령어셋을 사용하여 디버깅을 시작한다.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Makefile 예제</title>
   <link href="http://ygpark.github.com/Linux/2012/08/24/makefile-example"/>
   <updated>2012-08-24T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Linux/2012/08/24/makefile-example</id>
   <content type="html">&lt;h2 id='1_application'&gt;예제1. Application&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;CXX=g++
CFLAGS=-c -Wall
LDFLAGS=
SOURCES=main.cpp
OBJECTS=$(SOURCES:.cpp=.o)
EXECUTABLE=a.out

all: $(SOURCES) $(EXECUTABLE)

$(EXECUTABLE): $(OBJECTS)
	$(CXX) $(LDFLAGS) $(OBJECTS) -o $@

.cpp.o:
	$(CXX) $(CFLAGS) $&amp;lt; -o $@

clean:
	rm -f $(OBJECTS)&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='2_application__c_cpp_'&gt;예제2. Application - C와 CPP 복합&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;CC=gcc
CXX=g++

CFLAGS=-c -Wall
LDFLAGS=-lpthread

SOURCES=main.cpp VoiceSound2.cpp
OBJECTS=$(SOURCES:.cpp=.o)

SOURCES_C=sound/mixer.c sound/player.c
OBJECTS_C=$(SOURCES_C:.c=.o)

EXECUTABLE=test

all: $(SOURCES) $(EXECUTABLE)

$(EXECUTABLE): $(OBJECTS) $(OBJECTS_C)
	$(CXX) $(LDFLAGS) $(OBJECTS) $(OBJECTS_C) -o $@

.cpp.o:
	$(CXX) $(CFLAGS) $&amp;lt; -o $@
	
.c.o:
	$(CC) $(CFLAGS) $&amp;lt; -o $@

clean:
	rm -f $(OBJECTS) $(OBJECTS_C)&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='3_static_library'&gt;예제3. static library&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;CC=g++
CFLAGS=-c -Wall
SOURCES=GPSReader.cpp
OBJECTS=$(SOURCES:.cpp=.o)
TARGET=libnd100s

all: $(SOURCES) $(TARGET)

$(TARGET): $(OBJECTS)
	ar cr $(TARGET).a $(OBJECTS)

.cpp.o:
	$(CC) $(CFLAGS) $&amp;lt; -o $@

clean:
	rm -f $(OBJECTS) $(TARGET).a&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>Linux: CPU scaling governor</title>
   <link href="http://ygpark.github.com/Linux/2012/08/24/linux-cpu-scaling-governor"/>
   <updated>2012-08-24T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Linux/2012/08/24/linux-cpu-scaling-governor</id>
   <content type="html">&lt;h3 id='cpu_'&gt;CPU 정보&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cat /proc/cpuinfo&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='2__'&gt;2번째 코어 살리기&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;echo 1 &amp;gt; /sys/devices/system/cpu/cpu1/online 
grep &amp;quot;processor&amp;quot; /proc/cpuinfo&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>bash에서 검색하기</title>
   <link href="http://ygpark.github.com/Linux/2012/08/24/bash-find-xargs-grep"/>
   <updated>2012-08-24T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Linux/2012/08/24/bash-find-xargs-grep</id>
   <content type="html">&lt;p&gt;리눅스에서 일반적으로 파일을 찾을 때에는 find명령을, 텍스트를 걸러낼 때에는 grep명령을 사용합니다. 이 두 명령어는 없어서는 안될 중요한 명령입니다. 하지만 이 두 명령을 조합해서 쓴다면 더 막강한 힘을 발휘합니다. 바로 xargs으로 명령어들을 연결해주면 됩니다.&lt;/p&gt;

&lt;h3 id='find_xargs_grep_'&gt;find, xargs, grep의 조합&lt;/h3&gt;

&lt;p&gt;find, xargs, grep명령을 조합하여 사용방법입니다:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -name &amp;lt;파일명&amp;gt; | xargs grep --color -n &amp;lt;검색어&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이것이 가능한 이유는 find의 결과로 나오는 목록을 xargs가 grep의 마지막 인자로 넣어주기 때문입니다.&lt;/p&gt;

&lt;p&gt;리눅스 커널을 개발하는 경우는 아래와 같은 스크립트로 소스코드를 검색하곤 합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh
# grep-kernel.sh

find . -name &amp;quot;*.[chSs]&amp;quot; -o -name &amp;quot;*.cpp&amp;quot; -o -name &amp;quot;Makefile&amp;quot; -o -name &amp;quot;.config&amp;quot; | xargs grep --color -n $1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;혹은 이렇게 Kconfig를 검색하기도 하죠.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/sh
# grep-kconfig.sh

find . -name Kconfig | xargs grep --color -n $1&lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>alsa-lib-1.0.16 cross compile for arm</title>
   <link href="http://ygpark.github.com/Linux/2012/08/24/alsa-lib-1016-cross-compile-for-arm"/>
   <updated>2012-08-24T00:00:00+09:00</updated>
   <id>http://ygpark.github.com/Linux/2012/08/24/alsa-lib-1016-cross-compile-for-arm</id>
   <content type="html">&lt;h3 id='id32'&gt;요약&lt;/h3&gt;

&lt;p&gt;기본적인 크로스컴파일 방법과 configure시 libpython이 없다는 에러가 발생했을 때 대처법입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ CC=arm-linux-gcc ./configure --target=arm-linux --host=i686-linux
$ make&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;libpython이 없다는 에러가 나면 이렇게 하세요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ CC=arm-linux-gcc ./configure --target=arm-linux --host=i686-linux --disable-python
$ make&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='id33'&gt;경험담&lt;/h3&gt;

&lt;p&gt;alsa-lib를 컴파일할 일이 생겼습니다. 그런데 configure 에서 에러가 발생합니다.&lt;code&gt;cannot find -lpython2.6&lt;/code&gt; 뭐라는걸로 보아서 python 라이브러리가 필요한듯 하네요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ CC=arm-linux-gcc ./configure --target=arm-linux --host=i686-linux
...
...
...
/opt/arm/4.3.1-eabi-armv6/usr/bin-ccache/.........: cannot find -lpython2.6
collect2: ld returned 1 exit status
make[3]: *** [smixer-python.la] 오류 1
make[3]: Leaving directory `/home/ygpark/download/sound/alsa-lib-1.0.16/modules/mixer/simple&amp;#39;
make[2]: *** [all-recursive] 오류 1
make[2]: Leaving directory `/home/ygpark/download/sound/alsa-lib-1.0.16/modules/mixer&amp;#39;
make[1]: *** [all-recursive] 오류 1
make[1]: Leaving directory `/home/ygpark/download/sound/alsa-lib-1.0.16/modules&amp;#39;
make: *** [all-recursive] 오류 1&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;어떻게 해야 할까요? configure 실행중 외부 라이브러리 의존성에 관한 에러가 발생할 경우 &lt;code&gt;configure --help&lt;/code&gt; 명령으로 옵션을 찾아보면 해답을 찾을 수 있습니다. 여기서는 &amp;#8217;&amp;#8211;disable-python&amp;#8217;이란 옵션이 있네요.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./configure --help | grep python
  --disable-python        disable the python components
  --with-pythonlibs=ldflags
                          specify python libraries (-lpthread -lm -ldl
                          -lpython2.4)
  --with-pythonincludes=Cflags
                          specify python C header files
                          (-I/usr/include/python)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;configure에 &amp;#8217;&amp;#8211;disable-python&amp;#8217;옵션을 적용해서 다시 시도해 봅니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ CC=arm-linux-gcc ./configure --target=arm-linux --host=i686-linux --disable-python
$ make&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;configure가 완료되었고, 컴파일도 성공했군요. 컴파일된 결과물은 &lt;code&gt;./src/.libs/&lt;/code&gt; 에 있습니다.&lt;/p&gt;

&lt;h3 id='id34'&gt;참고&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href='http://omappedia.org/wiki/ALSA_Setup#ALSA_library'&gt;http://omappedia.org/wiki/ALSA_Setup#ALSA_library&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
 </entry>
 
 
</feed>