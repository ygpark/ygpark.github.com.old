
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>리눅스 API의 모든 것 Vol.2 - 박영기 BLOG</title>
    <meta name="description" content="">
    <meta name="author" content="Young-Gi Park">

    <META HTTP-EQUIV="Expires" CONTENT="Mon, 06 Jan 1990 00:00:01 GMT"> 
<!--
    <META HTTP-EQUIV="Expires" CONTENT="-1"> 
    <META HTTP-EQUIV="Pragma" CONTENT="no-cache">
    <META HTTP-EQUIV="Cache-Control" CONTENT="no-cache">
-->
    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">박영기 BLOG</a>
          <ul class="nav">
            <li><a href="/atom.xml"><img src="/images/rss.gif"/></a></li>
            <li><a href="/archive.html">Archive</a></li>
            <li><a href="/categories.html">Categories</a></li>
            <li><a href="/tags.html">Tags</a></li>
            <li><a href="/pages/documents.html">Documents</a></li>
            <li><a href="/pages/about.html">About</a></li>
	<!--
            
            
            


  
    
  
    
      
      	
      	<li><a href="/tags.html">Tags</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/pages.html">Pages</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/categories.html">Categories</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/archive.html">Archive</a></li>
      	
      
    
  
    
      
    
  


 -->
          </ul>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        
<div class="page-header">
  <h1>리눅스 API의 모든 것 Vol.2 </h1>
</div>

<div class="row">
  <div class="span12">
    <p>목차</p>

<ol>
<li><a href='/pages/linux_api_vol_2/00-readme.html'>README</a></li>

<li><a href='/pages/linux_api_vol_2/01-thread-introduce.html'>스레드: 소개</a></li>

<li><a href='/pages/linux_api_vol_2/02-thread-sync.html'>스레드: 스레드 동기화</a></li>

<li><a href='/pages/linux_api_vol_2/03-thread-safety-and-repository.html'>스레드: 스레드 안전성과 스레드별 저장소</a></li>

<li><a href='/pages/linux_api_vol_2/04-thread-cancel.html'>스레드: 스레드 취소</a></li>

<li><a href='/pages/linux_api_vol_2/05-thread-details.html'>스레드: 기타 세부사항</a></li>

<li><a href='/pages/linux_api_vol_2/06-ipc.html'>프로세스 간 통신 개요</a></li>

<li><a href='/pages/linux_api_vol_2/07-pipe-fifo.html'>파이프와 FIFO</a></li>

<li><a href='/pages/linux_api_vol_2/08-system-v-ipc.html'>시스템 V IPC 소개</a></li>

<li><a href='/pages/linux_api_vol_2/09-system-v-message-queue.html'>시스템 V 메시지 큐</a></li>

<li><a href='/pages/linux_api_vol_2/10-system-v-semaphore.html'>시스템 V 세마포어</a></li>

<li><a href='/pages/linux_api_vol_2/11-system-v-shared-memory.html'>시스템 V 공유 메모리</a></li>

<li><a href='/pages/linux_api_vol_2/12-memory-mapping.html'>메모리 매핑</a></li>

<li><a href='/pages/linux_api_vol_2/13-virtual-memory-operation.html'>가상 메모리 오퍼레이션</a></li>

<li><a href='/pages/linux_api_vol_2/14-posix-ipc.html'>POSIX IPC 소개</a></li>

<li><a href='/pages/linux_api_vol_2/15-posix-message-queue.html'>POSIX 메시지 큐</a></li>

<li><a href='/pages/linux_api_vol_2/16-posix-semaphore.html'>POSIX 세마포어</a></li>

<li><a href='/pages/linux_api_vol_2/17-posix-shared-memory.html'>POSIX 공유 메모리</a></li>

<li><a href='/pages/linux_api_vol_2/18-file-lock.html'>파일 잠금</a></li>

<li><a href='/pages/linux_api_vol_2/19-socket-introduction.html'>소켓: 소개</a></li>

<li><a href='/pages/linux_api_vol_2/20-socket-unix-domain.html'>소켓: 유닉스 도메인</a></li>

<li><a href='/pages/linux_api_vol_2/21-socket-tcp-ip-network.html'>소켓: TCP/IP 네트워크 기초</a></li>

<li><a href='/pages/linux_api_vol_2/22-socket-internet-domain.html'>소켓: 인터넷 도메인</a></li>

<li><a href='/pages/linux_api_vol_2/23-socket-design-server.html'>소켓: 서버 설계</a></li>

<li><a href='/pages/linux_api_vol_2/24-socket-advanced-option.html'>소켓: 고급 옵션</a></li>

<li><a href='/pages/linux_api_vol_2/25-terminal.html'>터미널</a></li>

<li><a href='/pages/linux_api_vol_2/26-alternative-io-model.html'>대체 I/O 모델</a></li>

<li><a href='/pages/linux_api_vol_2/27-virtual-terminal.html'>가상 터미널</a></li>
</ol>
<hr />
<h2 id='21_____'>2.1 공유 변수 접근 보호: 뮤텍스</h2>

<p>두 스레드에서 전역 변수를 잘못 증가시키는 예. 좁은 의미에서 보면 공유변수를 보호하기 위한 작업이고, 넓은 의미에서는 어떤 단위의 일(transaction)이 끝날때까지 보호한다는 의미도 가진다. 필자의 경험을 이야기 하자면 뮤텍스는 참 다용도로 활용될 수 있는 고마운 녀석이다.</p>

<pre><code>  1 #include &lt;stdio.h&gt;
  2 #include &lt;pthread.h&gt;
  3 #include &lt;stdlib.h&gt;
  4 #include &lt;unistd.h&gt;
  5 
  6 pthread_t tid1, tid2;
  7 static int glob = 0;
  8 
  9 void* thread(void* arg)
 10 {
 11     int cnt = *((int *)arg);
 12     for(int i=0; i &lt; cnt ; i++) {
 13         glob++;
 14     }
 15     return NULL;
 16 }
 17 
 18 int main(int argc, char *argv[])
 19 {
 20     int loop = (argc &gt; 1) ? atoi(argv[1]) : 1000;
 21     pthread_create(&amp;tid1, NULL, thread, &amp;loop);
 22     pthread_create(&amp;tid2, NULL, thread, &amp;loop);
 23     pthread_join(tid1, NULL);
 24     pthread_join(tid2, NULL);
 25     printf(&quot;glob: %d \n&quot;, glob);
 26     exit(EXIT_SUCCESS);
 27 }
 
결과:

$ ./a.out 
glob: 2000
$ ./a.out 100000
glob: 108221 
$ ./a.out 100000
glob: 113245 
$ ./a.out 100000
glob: 113365 
$ ./a.out 100000
glob: 112098 </code></pre>

<h2 id='211___'>2.1.1 정적으로 할당한 뮤텍스</h2>

<p>뮤텍스를 정적으로 초기화 하는 방법은 다음과 같다. 동적으로 초기화 할수도 있는데 2.1.5절에서 다룬다.</p>

<pre><code>pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;</code></pre>

<h2 id='212___'>2.1.2 뮤텍스의 잠금과 풀림</h2>

<pre><code>#include &lt;pthread.h&gt;

int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);

		성공하면 0을 리턴하고 에러가 발생하면 에러 번호(양수)를 리턴한다.</code></pre>

<h4 id='_'>예제 프로그램</h4>

<pre><code>  1 #include &lt;stdio.h&gt;
  2 #include &lt;pthread.h&gt;
  3 #include &lt;stdlib.h&gt;
  4 #include &lt;unistd.h&gt;
  5 #include &lt;string.h&gt;
  6 
  7 pthread_t tid1, tid2;
  8 static int glob = 0;
  9 pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
 10 
 11 void* thread(void* arg)
 12 {
 13     int cnt = *((int *)arg);
 14     int s;
 15     for(int i=0; i &lt; cnt ; i++) {
 16         s = pthread_mutex_lock(&amp;mtx);
 17         if(s != 0) {
 18             printf(&quot;pthread_mutex_lock(): %s \n&quot;, strerror(s));
 19             exit(EXIT_FAILURE);
 20         }
 21         glob++;
 22         s = pthread_mutex_unlock(&amp;mtx);
 23         if(s != 0) {
 24             printf(&quot;pthread_mutex_unlock(): %s \n&quot;, strerror(s));
 25             exit(EXIT_FAILURE);
 26         }
 27     }
 28     return NULL;
 29 }
 30 
 31 int main(int argc, char *argv[])
 32 {
 33     int loop = (argc &gt; 1) ? atoi(argv[1]) : 1000;
 34     pthread_create(&amp;tid1, NULL, thread, &amp;loop);
 35     pthread_create(&amp;tid2, NULL, thread, &amp;loop);
 36     pthread_join(tid1, NULL);
 37     pthread_join(tid2, NULL);
 38     printf(&quot;glob: %d \n&quot;, glob);
 39     exit(EXIT_SUCCESS);
 40 }
결과:

$ ./a.out 
glob: 2000
$ ./a.out 100000
glob: 200000
$ ./a.out 100000
glob: 200000 </code></pre>

<h4 id='pthread_mutex_trylock_pthread_mutex_timedlock'>pthread_mutex_trylock()과 pthread_mutex_timedlock()</h4>

<pre><code>#include &lt;pthread.h&gt;

int pthread_mutex_trylock(pthread_mutex_t *mutex);

		성공하면 0을 리턴하고 에러가 발생하면 에러 번호(양수)를 리턴한다.</code></pre>

<p>. #include <pre style='border: solid 3px red; background-color: pink' class='markdown-html-error'>REXML could not parse this XML/HTML: 
&lt;pthread.h&gt;
	#include &lt;time.h&gt;</pre></p>

<pre><code>int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex,
const struct timespec *restrict abs_timeout);

		성공하면 0을 리턴하고 에러가 발생하면 에러 번호(양수)를 리턴한다.</code></pre>

<p>Pthread API는 pthread_mutex_lock()함수의 두 가지 변종을 제공한다.</p>

<p>pthread_mutex_trylock()함수는 뮤텍스가 현재 잠겨있으면 에러 EBUSY를 리턴하면서 실패한다는 점을 제외하고는 pthread_mutex_lock()과 같다.</p>

<p>pthread_mutex_timedlock()함수는 호출자가 뮤텍스 잠금을 획득하려고 기다리면서 수면을 취하는 점을 제외하고는 pthread_mutex_lock()과 같다. 호출자가 뮤텍스 잠금을 얻지 못한 상태로 abstime 시간이 지나면, pthread_mutex_timedlock()은 에러 ETIMEDOUT을 리턴한다.</p>

<p>대부분의 잘 설계된 응용 프로그램에서는 뮤텍스가 짧은 시간동안만 잠근다. 그러므로 pthread_mutex_trylock()와 pthread_mutex_timedlock()가 필요한 상황이 생기면 설계가 올바로 되어있나 검토해 볼 필요가 있다.</p>

<h2 id='213__'>2.1.3 뮤텍스의 성능</h2>

<p>뮤텍스의 성능은 대체로 빠른 편에 속한다.</p>

<h2 id='214__'>2.1.4 뮤텍스 데드락</h2>
  </div>
</div>


      </div>

      <footer>
        <p>&copy; Young-Gi Park 2012 
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </footer>

    </div> <!-- /container -->

    
  </body>
</html>

