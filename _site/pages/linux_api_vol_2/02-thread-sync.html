
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>리눅스 API의 모든 것 Vol.2 - 박영기 BLOG</title>
    <meta name="description" content="">
    <meta name="author" content="Young-Gi Park">

    <META HTTP-EQUIV="Expires" CONTENT="Mon, 06 Jan 1990 00:00:01 GMT"> 
<!--
    <META HTTP-EQUIV="Expires" CONTENT="-1"> 
    <META HTTP-EQUIV="Pragma" CONTENT="no-cache">
    <META HTTP-EQUIV="Cache-Control" CONTENT="no-cache">
-->
    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">박영기 BLOG</a>
          <ul class="nav">
            <li><a href="/atom.xml"><img src="/images/rss.gif"/></a></li>
            <li><a href="/archive.html">Archive</a></li>
            <li><a href="/categories.html">Categories</a></li>
            <li><a href="/tags.html">Tags</a></li>
            <li><a href="/pages/documents.html">Documents</a></li>
            <li><a href="/pages/about.html">About</a></li>
	<!--
            
            
            


  
    
  
    
      
      	
      	<li><a href="/tags.html">Tags</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/pages.html">Pages</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/categories.html">Categories</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/archive.html">Archive</a></li>
      	
      
    
  
    
      
    
  


 -->
          </ul>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        
<div class="page-header">
  <h1>리눅스 API의 모든 것 Vol.2 </h1>
</div>

<div class="row">
  <div class="span12">
    <p>목차</p>

<ol>
<li><a href='/pages/linux_api_vol_2/00-readme.html'>README</a></li>

<li><a href='/pages/linux_api_vol_2/01-thread-introduce.html'>스레드: 소개</a></li>

<li><a href='/pages/linux_api_vol_2/02-thread-sync.html'>스레드: 스레드 동기화</a></li>

<li><a href='/pages/linux_api_vol_2/03-thread-safety-and-repository.html'>스레드: 스레드 안전성과 스레드별 저장소</a></li>

<li><a href='/pages/linux_api_vol_2/04-thread-cancel.html'>스레드: 스레드 취소</a></li>

<li><a href='/pages/linux_api_vol_2/05-thread-details.html'>스레드: 기타 세부사항</a></li>

<li><a href='/pages/linux_api_vol_2/06-ipc.html'>프로세스 간 통신 개요</a></li>

<li><a href='/pages/linux_api_vol_2/07-pipe-fifo.html'>파이프와 FIFO</a></li>

<li><a href='/pages/linux_api_vol_2/08-system-v-ipc.html'>시스템 V IPC 소개</a></li>

<li><a href='/pages/linux_api_vol_2/09-system-v-message-queue.html'>시스템 V 메시지 큐</a></li>

<li><a href='/pages/linux_api_vol_2/10-system-v-semaphore.html'>시스템 V 세마포어</a></li>

<li><a href='/pages/linux_api_vol_2/11-system-v-shared-memory.html'>시스템 V 공유 메모리</a></li>

<li><a href='/pages/linux_api_vol_2/12-memory-mapping.html'>메모리 매핑</a></li>

<li><a href='/pages/linux_api_vol_2/13-virtual-memory-operation.html'>가상 메모리 오퍼레이션</a></li>

<li><a href='/pages/linux_api_vol_2/14-posix-ipc.html'>POSIX IPC 소개</a></li>

<li><a href='/pages/linux_api_vol_2/15-posix-message-queue.html'>POSIX 메시지 큐</a></li>

<li><a href='/pages/linux_api_vol_2/16-posix-semaphore.html'>POSIX 세마포어</a></li>

<li><a href='/pages/linux_api_vol_2/17-posix-shared-memory.html'>POSIX 공유 메모리</a></li>

<li><a href='/pages/linux_api_vol_2/18-file-lock.html'>파일 잠금</a></li>

<li><a href='/pages/linux_api_vol_2/19-socket-introduction.html'>소켓: 소개</a></li>

<li><a href='/pages/linux_api_vol_2/20-socket-unix-domain.html'>소켓: 유닉스 도메인</a></li>

<li><a href='/pages/linux_api_vol_2/21-socket-tcp-ip-network.html'>소켓: TCP/IP 네트워크 기초</a></li>

<li><a href='/pages/linux_api_vol_2/22-socket-internet-domain.html'>소켓: 인터넷 도메인</a></li>

<li><a href='/pages/linux_api_vol_2/23-socket-design-server.html'>소켓: 서버 설계</a></li>

<li><a href='/pages/linux_api_vol_2/24-socket-advanced-option.html'>소켓: 고급 옵션</a></li>

<li><a href='/pages/linux_api_vol_2/25-terminal.html'>터미널</a></li>

<li><a href='/pages/linux_api_vol_2/26-alternative-io-model.html'>대체 I/O 모델</a></li>

<li><a href='/pages/linux_api_vol_2/27-virtual-terminal.html'>가상 터미널</a></li>
</ol>
<hr />
<h2 id='21_____'>2.1 공유 변수 접근 보호: 뮤텍스</h2>

<p>두 스레드에서 전역 변수를 잘못 증가시키는 예. 좁은 의미에서 보면 공유변수를 보호하기 위한 작업이고, 넓은 의미에서는 어떤 단위의 일(transaction)이 끝날때까지 보호한다는 의미도 가진다. 필자의 경험을 이야기 하자면 뮤텍스는 참 다용도로 활용될 수 있는 고마운 녀석이다.</p>

<pre><code>  1 #include &lt;stdio.h&gt;
  2 #include &lt;pthread.h&gt;
  3 #include &lt;stdlib.h&gt;
  4 #include &lt;unistd.h&gt;
  5 
  6 pthread_t tid1, tid2;
  7 static int glob = 0;
  8 
  9 void* thread(void* arg)
 10 {
 11     int cnt = *((int *)arg);
 12     for(int i=0; i &lt; cnt ; i++) {
 13         glob++;
 14     }
 15     return NULL;
 16 }
 17 
 18 int main(int argc, char *argv[])
 19 {
 20     int loop = (argc &gt; 1) ? atoi(argv[1]) : 1000;
 21     pthread_create(&amp;tid1, NULL, thread, &amp;loop);
 22     pthread_create(&amp;tid2, NULL, thread, &amp;loop);
 23     pthread_join(tid1, NULL);
 24     pthread_join(tid2, NULL);
 25     printf(&quot;glob: %d \n&quot;, glob);
 26     exit(EXIT_SUCCESS);
 27 }
 
결과:

$ ./a.out 
glob: 2000
$ ./a.out 100000
glob: 108221 
$ ./a.out 100000
glob: 113245 
$ ./a.out 100000
glob: 113365 
$ ./a.out 100000
glob: 112098 </code></pre>

<h3 id='211___'>2.1.1 정적으로 할당한 뮤텍스</h3>

<p>뮤텍스를 정적으로 초기화 하는 방법은 다음과 같다. 동적으로 초기화 할수도 있는데 2.1.5절에서 다룬다.</p>

<pre><code>pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;</code></pre>

<h3 id='212___'>2.1.2 뮤텍스의 잠금과 풀림</h3>

<pre><code>#include &lt;pthread.h&gt;

int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);

		성공하면 0을 리턴하고 에러가 발생하면 에러 번호(양수)를 리턴한다.</code></pre>

<h4 id='_'>예제 프로그램</h4>

<pre><code>  1 #include &lt;stdio.h&gt;
  2 #include &lt;pthread.h&gt;
  3 #include &lt;stdlib.h&gt;
  4 #include &lt;unistd.h&gt;
  5 #include &lt;string.h&gt;
  6 
  7 pthread_t tid1, tid2;
  8 static int glob = 0;
  9 pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
 10 
 11 void* thread(void* arg)
 12 {
 13     int cnt = *((int *)arg);
 14     int s;
 15     for(int i=0; i &lt; cnt ; i++) {
 16         s = pthread_mutex_lock(&amp;mtx);
 17         if(s != 0) {
 18             printf(&quot;pthread_mutex_lock(): %s \n&quot;, strerror(s));
 19             exit(EXIT_FAILURE);
 20         }
 21         glob++;
 22         s = pthread_mutex_unlock(&amp;mtx);
 23         if(s != 0) {
 24             printf(&quot;pthread_mutex_unlock(): %s \n&quot;, strerror(s));
 25             exit(EXIT_FAILURE);
 26         }
 27     }
 28     return NULL;
 29 }
 30 
 31 int main(int argc, char *argv[])
 32 {
 33     int loop = (argc &gt; 1) ? atoi(argv[1]) : 1000;
 34     pthread_create(&amp;tid1, NULL, thread, &amp;loop);
 35     pthread_create(&amp;tid2, NULL, thread, &amp;loop);
 36     pthread_join(tid1, NULL);
 37     pthread_join(tid2, NULL);
 38     printf(&quot;glob: %d \n&quot;, glob);
 39     exit(EXIT_SUCCESS);
 40 }
결과:

$ ./a.out 
glob: 2000
$ ./a.out 100000
glob: 200000
$ ./a.out 100000
glob: 200000 </code></pre>

<h4 id='pthread_mutex_trylock_pthread_mutex_timedlock'>pthread_mutex_trylock()과 pthread_mutex_timedlock()</h4>

<pre><code>#include &lt;pthread.h&gt;

int pthread_mutex_trylock(pthread_mutex_t *mutex);

		성공하면 0을 리턴하고 에러가 발생하면 에러 번호(양수)를 리턴한다.</code></pre>

<p>.</p>

<pre><code>#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex,
const struct timespec *restrict abs_timeout);

		성공하면 0을 리턴하고 에러가 발생하면 에러 번호(양수)를 리턴한다.</code></pre>

<p>Pthread API는 pthread_mutex_lock()함수의 두 가지 변종을 제공한다.</p>

<p>pthread_mutex_trylock()함수는 뮤텍스가 현재 잠겨있으면 에러 EBUSY를 리턴하면서 실패한다는 점을 제외하고는 pthread_mutex_lock()과 같다.</p>

<p>pthread_mutex_timedlock()함수는 호출자가 뮤텍스 잠금을 획득하려고 기다리면서 수면을 취하는 점을 제외하고는 pthread_mutex_lock()과 같다. 호출자가 뮤텍스 잠금을 얻지 못한 상태로 abstime 시간이 지나면, pthread_mutex_timedlock()은 에러 ETIMEDOUT을 리턴한다.</p>

<p>대부분의 잘 설계된 응용 프로그램에서는 뮤텍스가 짧은 시간동안만 잠근다. 그러므로 pthread_mutex_trylock()와 pthread_mutex_timedlock()가 필요한 상황이 생기면 설계가 올바로 되어있나 검토해 볼 필요가 있다.</p>

<h3 id='213__'>2.1.3 뮤텍스의 성능</h3>

<p>뮤텍스의 성능은 대체로 빠른 편에 속한다. 리눅스에서는 퓨텍스(futex, fast user space mutex)로 구현되어있고, 잠금 경합은 futex() 시스템 호출로 처리한다.</p>

<h3 id='214__'>2.1.4 뮤텍스 데드락</h3>

<h4 id='______'>두 스레드가 두 뮤텍스를 잠글 때의 데드락</h4>
<table border='1px'>

<tr>
	<td>스레드 A</td>
	<td>스레드B</td>
</tr>

<tr>
	<td>
		1. pthread_mutex_lock(mutex1); <br />
		2. pthread_mutex_lock(mutex2);
	</td>
	<td>
		1. pthread_mutex_lock(mutex2); <br />
		2. pthread_mutex_lock(mutex1);
</td>
</tr>
</table>
<h4 id='__'>데드락을 피하는 방법</h4>
<ol>
	<li>같은 스레드군을 잠글 때에는 같은 순서로 뮤텍스를 잠근다. (예를들어, mutex1을 잠근 다음 mutex2를 잠근다)</li>
	<li>pthread_mutex_lock()으로 잠근 다음, 나머지 뮤텍스를 pthread_mutex_trylock()으로 잠근다. 이 방법은 잠금서열을 정하는 것 보다 덜 효율적이다.</li>
</ol>
<h3 id='215___'>2.1.5 뮤텍스를 동적으로 초기화하기</h3>

<pre><code>#include &lt;pthread.h&gt;

int pthread_mutex_init(pthread_mutex_t *restrict mutex,
                       const pthread_mutexattr_t *restrict attr);

		성공하면 0을 리턴하고 에러가 발생하면 에러 번호(양수)를 리턴한다.</code></pre>

<p>attr을 NULL로 지정하면 기본 속성이 적용된다.</p>

<pre><code>#include &lt;pthread.h&gt;

int pthread_mutex_destroy(pthread_mutex_t *mutex);

		성공하면 0을 리턴하고 에러가 발생하면 에러 번호(양수)를 리턴한다.</code></pre>

<p>더이상 필요없으면 pthread_mutex_destroy()로 제거해야한다. 제거된 뮤텍스는 pthread_mutex_init()으로 다시 재사용할 수 있다.</p>

<h2 id='216__'>2.1.6 뮤텍스 속성</h2>

<p>생략</p>

<h3 id='217__'>2.1.7 뮤텍스의 종류</h3>

<p>뮤텍스를 사용할 때 하지말아야 할 것들이다. 각각의 경우 무슨일이 생길지는 뮤텍스의 종류에 따라 다르다.</p>
<ul>
	<li>하나의 스레드는 같은 뮤텍스를 두 번 잠그면 안된다.</li>
	<li>스레드는 자신이 소유하지 않은(즉 자신이 잠그지 않은) 뮤텍스를 풀면 안된다.</li>
	<li>스레드는 현재 잠겨있지 않은 뮤텍스를 풀면 안된다.</li>
</ul><ul>
	<li>PTHREAD_MUTEX_NORMAL: 기본값. 위 시나리오에서 알 수 없는 결과가 생긴다.</li>
	<li>PTHREAD_MUTEX_ERRORCHECK: 모든 오퍼레이션에 대해 에러 검사가 수행된다. 위 세가지 시나리오에서 에러값이 리턴된다. 디버그 도구로 사용할 수 있다.</li>
	<li>PTHREAD_MUTEX_RECURSIVE: 잠금 카운트가 적용된 재귀적 뮤텍스. 한 스레드 내에서 뮤텍스가 여러번 잠길 수 있고 카운트가 1씩 증가한다. 잠금이 해제될 때 마다 카운트가 1씩 감소하며 0이되면 해제된다.</li>
</ul>
<p>디버그용으로 사용하면 좋을 것 같은 예제를 인용한다. 에러체크는 생략한다.</p>

<pre><code>  1 pthread_mutex_t mtx;
  2 pthread_mutexattr_t mtxAttr;
  3 int s, type;
  4 
  5 pthread_mutex_attr_init(&amp;mtxAttr);
  6 
  7 pthread_mutexattr_settype(&amp;mtxAttr, PTHREAD_MUTEX_ERRORCHECK);
  8 
  9 pthread_muteX_init(&amp;mtx, &amp;mtxAttr);
 10 
 11 pthread_muteXattr_destroy(&amp;mtxAttr);</code></pre>

<h2 id='22____'>2.2 상태 변화 알리기: 조건변수</h2>

<p>이번에는 조건변수를 알 수 있는 예만 알아보고 가겠다. 마찬가지로 에러처리는 생략한다.</p>

<h3 id='221____'>2.2.1 정적으로 할당된 조건 변수</h3>

<pre><code>#include &lt;pthread.h&gt;

pthread_cont_t cond = PTHREAD_COND_INITIALIZER;</code></pre>

<h3 id='222_____'>2.2.2 조건 변수를 이용한 대기와 시그널</h3>

<pre><code>#include &lt;pthread.h&gt;

int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_signal(pthread_cond_t *cond); 

		성공하면 0을 리턴하고 에러가 발생하면 에러 번호(양수)를 리턴한다.</code></pre>

<p>.</p>

<pre><code>#include &lt;pthread.h&gt;

int pthread_cond_timedwait(pthread_cond_t *restrict cond,
                           pthread_mutex_t *restrict mutex,
                           const struct timespec *restrict abstime);
int pthread_cond_wait(pthread_cond_t *restrict cond,
                      pthread_mutex_t *restrict mutex);

		성공하면 0을 리턴하고 에러가 발생하면 에러 번호(양수)를 리턴한다.</code></pre>

<h4 id='_'>생산자-소비자 예제</h4>

<p>생산자 코드</p>

<pre><code>  1 pthread_mutex_lock(&amp;mtx);
  2 
  3 avail++;
  4 
  5 pthread_mutex_unlock(&amp;mtx); 
  6 
  7 pthread_cond_signal(&amp;cond); /*5번째 줄과 바꿔쓸 수 있다. */</code></pre>

<p>소비자 코드</p>

<pre><code>  1 pthread_mutex_lock(&amp;mtx);
  2 
  3 while(avail==0)                     /* if문이 아닌 while문을 써야 안전하다. */
  4 	pthread_cond_wait(&amp;cond, &amp;mtx); /* 흥미로운것은 이 줄에서 뮤텍스가 자동으로 풀린다는 것이다. */
  5 
  6 /* 작업을 수행한다. */
  7 
  8 pthread_mutex_unlock(&amp;mtx);</code></pre>

<p>소비자 코드의 3번째 줄에서 while문을 써야하는 이유는 드물게 시스템이 잘못 깨울 수도 있기 때문이다. (SUSv3에 명시되어 있다고 한다.)</p>

<h3 id='223____'>2.2.3 조건 변수의 조건문 검사하기</h3>

<p>생략</p>

<h3 id='224______'>2.2.4 예제 프로그램: 종료하는 모든 스레드와 조인하기</h3>

<p>생략 (그냥 재미있는 시도를 하는 예제였을 뿐..)</p>

<h3 id='225____'>2.2.5 동적으로 할당된 조건 변수</h3>

<pre><code>#include &lt;pthread.h&gt;

int pthread_cond_init(pthread_cond_t *restrict cond,
                      const pthread_condattr_t *restrict attr);

		성공하면 0을 리턴하고 에러가 발생하면 에러 번호(양수)를 리턴한다.</code></pre>

<p>attr이 NULL이면 기본값이 적용된다.</p>

<pre><code>#include &lt;pthread.h&gt;

int pthread_cond_destroy(pthread_cond_t *cond);

		성공하면 0을 리턴하고 에러가 발생하면 에러 번호(양수)를 리턴한다.</code></pre>

<h2 id='24_'>2.4 연습문제</h2>

<p>생략</p>
  </div>
</div>


      </div>

      <footer>
        <p>&copy; Young-Gi Park 2012 
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </footer>

    </div> <!-- /container -->

    
  </body>
</html>

